#' Conduct a PCA on individual genotypes stored in a (long) data table
#'
#' Takes a long data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function. Different options for scaling the genotypes
#' pre-PCA are available.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled? Set to
#' \code{'center'} (default) to scale to mean = 0 and variance = 1. Set to
#' \code{'patterson'} to use the Patteron et al. (2006) normalisation.
#' Set to \code{'none'} if you don't want to do any scaling pre-PCA.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @return Returns a \code{prcomp} object
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' # Data
#' data(genomalicious4pops)
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot()
#'
#' @export

pca_DTinds <- function(dat, scaling='center', sampCol='SAMPLE'
                       , locusCol='LOCUS', genoCol='GT', popCol=NULL){

  # BEGIN ...........

  # --------------------------------------------+
  # Libraries and assertions
  # --------------------------------------------+
  for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}

  if(!scaling %in% c('center', 'patterson', 'none')){
    stop('Argument scaling is invalid')
  }

  # --------------------------------------------+
  # Code
  # --------------------------------------------+
  # Convert to a genotype matrix
  genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)

  # Scale
  if(scaling=='center'){
    genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
  }

  if(scaling=='patterson'){
    genoMat <- normalise_patterson(genoMat)
  }

  # The PCA
  pca <- prcomp(genoMat, scale=FALSE, center=FALSE)

  # Was the population ID column specified?
  if(is.null(popCol)==FALSE){
    # Get population memberships for each sample
    popMems <- dat[, c(popCol, sampCol), with=FALSE]
    popMems <- subset(unique(popMems))
    # Match individuals in rows from genoMat with popMems
    pca$pops <- popMems[[popCol]][match(rownames(genoMat), popMems[[sampCol]])]
  }

  return(pca)

  # ........... END
}
