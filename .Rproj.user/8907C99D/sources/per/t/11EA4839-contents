#' Perform a DAPC of individual genotype data in a data table
#'
#' Takes a long-format data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function, then fits a DA using R's \code{lda()} function.
#' Can also be used to assess DA model fit using a leave-one-out cross-validation
#' or training-testing partitioning.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}. Genotypes can be coded as '/' separated characters
#' (e.g. '0/0', '0/1', '1/1'), or integers as Alt allele counts (e.g. 0, 1, 2).
#' Must contain the following columns,
#' \enumerate{
#'   \item The population designation (see param \code{popCol})
#'   \item The sampled individuals (see param \code{sampCol}).
#'   \item The locus ID (see param \code{locusCol}).
#'   \item The genotype column (see param \code{genoCol}).
#' }
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param scaling Character: How should the data (loci) be scaled?
#' Set to \code{'covar'} to scale to mean = 0, but variance is not
#' adjusted, i.e. PCA on a covariance matrix. Set to \code{'corr'}
#' to scale to mean = 0 and variance = 1, i.e. PCA on a
#' correlation matrix. Set to \code{'patterson'} to use the
#' Patteron et al. (2006) normalisation. Set to \code{'none'} to
#' if you do not want to do any scaling before PCA.
#'
#' @param pcPreds Integer: The number of leading PC axes to use as predictors
#' of among-population genetic differences in DA.
#'
#' @param method Character: The analysis to perform. Default is \code{'fit'},
#' which is a DAPC fitted to all the samples. \code{'loo_cv'} performs
#' leave-one-out cross-validation, and \code{'train_test'} performs
#' training-testing partitioning, for assessing model fit. See details
#'
#' @param numCores Integer: The number of cores to run leave-one-out cross-validation,
#' only required when \code{method=='loo_cv'}. Default is 1.
#'
#' @param trainProp Numeric: The proportion of the data to reserved as the
#' training set, with the remaining proportion used as the testing set.
#' Default is 0.7.


dapc_fit <- function(
  dat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', popCol='POP',
  scaling='covar', pcPreds, method='fit', numCores=1, trainProp=0.7
  ){
  # --------------------------------------------+
  # Libraries and assertions
  # --------------------------------------------+

  require(data.table)
  require(tidyverse)
  require(MASS)

  if(sum(c(popCol, sampCol, locusCol, genoCol) %in% colnames(dat)) != 4){
    stop('Argument `popCol`, `sampCol`, `locusCol` and `genoCol` must all be
       column names in argument `dat`. See ?dapc_fit.')
  }

  # Check that scaling is specified
  if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
    stop('Argument `scaling`` is invalid. See: ?pca_genos')
  }

  # Get the class of the genotypes
  gtClass <- class(dat[[genoCol]])

  # Check that genotypes are characters or counts
  if(!gtClass %in% c('character', 'numeric', 'integer')){
    stop("Check that genotypes are coded as '/' separated characters or as
         counts of the Alt allele. See: ?pca_genos")
  }

  # Convert characters of separated alleles to counts
  if(gtClass=='character'){
    dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
  }

  # Convert numeric allele counts to integers
  if(gtClass=='numeric'){
    dat[[genoCol]] <- as.integer(dat[[genoCol]])
  }

  # Check method is specified correctly
  if(!method %in% c('fit', 'loo_cv', 'train_test')){
    stop('Argument `method` must be one of "fit", "loo_cv", or "train_test".
       See ?dapc_fit.')
  }

  # Check that the training proportion is a proportion
  if(sum(c(trainProp<0,trainProp>1))>0){
    stop('Argument `trainProp` must be a proportion. See ?dapc_fit.')
  }

  # --------------------------------------------+
  # Internal function
  # --------------------------------------------+

  FUN_snp_da_contrib <- function(x){
    temp <- sum(x*x)
    if(temp < 1e-12) return(rep(0, length(x)))
    return(x*x / temp)
  }

  # --------------------------------------------+
  # Code
  # --------------------------------------------+

  # Rename columns
  colnames(dat)[match(c(sampCol, locusCol, popCol, genoCol),colnames(dat))] <- c(
    'SAMPLE','LOCUS','POP','GT'
  )

  ### The number of fitted populations
  k <- length(unique(dat$POP))

  ### Fit DAPC to all data
  if(method=='fit'){
    # Fit the PCA
    PCA <- pca_genos(dat, scaling=scaling, popCol=popCol)

    # Populations
    pops <- PCA$pops %>%  as.factor()

    # PC axes as predictors
    X <- PCA$x[, 1:pcPreds] %>% as.data.frame()

    # Fit the DA
    DA <- lda(X, pops, prior=rep(1,k)/k, tol=1e-30)

    # SNP loadings on LD axes
    snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
    snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
      as.data.frame() %>%
      rownames_to_column(., 'LOCUS') %>%
      as.data.table

    # Tables of DA and PCA scores
    DA.tab <- da2DT(DA, sampVec=rownames(X), obsPops=pops)
    PCA.tab <- pca2DT(PCA) %>%
      .[AXIS %in% paste0('PC', 1:pcPreds)]

    # Output
    list(
      da.fit=DA, da.tab=DA.tab,
      pca.fit=PCA, pca.tab=PCA.tab,
      snp.contrib=snp.da.contr
    ) %>%
      return()
  }

  ### Leave-one-out cross-validation
  if(method=='loo_cv'){
    # Samples
    samps <- dat$SAMPLE %>% unique

    # Cluster for parallelisation
    my.cluster <- makeCluster(numCores)
    registerDoParallel(my.cluster)

    # Predictions table
    predTab <- foreach(i=1:length(samps)) %dopar%{
      require(genomalicious)
      require(MASS)

      # PCA on training
      PCA.train <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')

      # DA on training
      DA.train <- lda(
        x=as.data.frame(PCA.train$x[, 1:pcPreds]),
        grouping=PCA.train$pops,
        prior=rep(1,k)/k,
        tol=1e-30)

      # Data for testing set
      dat.test <- dat[SAMPLE==samps[i],]

      # Predictors for testing set
      X.test <- DT2Mat_genos(dat.test) %*% PCA.train$rotation %>%
        .[, 1:pcPreds] %>%
        matrix(., ncol=pcPreds, nrow=1) %>%
        as.data.frame() %>%
        setnames(., new=paste0('PC', 1:pcPreds))

      # DA for testing set
      DA.test <- predict(DA.train, newdata = X.test[1,])

      # Output
      data.table(
        POP=dat.test$POP[1],
        SAMPLE=samps[i],
        POP.PRED=DA.test$class
      )
    } %>%
      do.call('rbind',.)
  }

  ### Training-testing partitioning
  if(method=='train_test'){
    # Samples
    samps.train <- dat %>%
      .[, c('POP','SAMPLE')] %>%
      unique %>%
      .[, sample(SAMPLE, round(length(unique(SAMPLE)))*trainProp), by=POP] %>%
      .[['V1']]

    samps.test <- dat %>%
      .[, c('POP','SAMPLE')] %>%
      unique %>%
      .[!SAMPLE%in%samps.train] %>%
      .[['SAMPLE']]

    # PCA fit to training set
    PCA.train <- dat %>%
      .[SAMPLE %in% samps.train] %>%
      pca_genos(., scaling=scaling, popCol='POP')

    # DA fit to training set
    DA.train <- lda(
      x=PCA.train$x[, 1:pcPreds],
      grouping=PCA.train$pops,
      prior=rep(1,k)/k,
      tol=1e-30
    )

    # Predictors for the testing set
    X.test <- dat[SAMPLE %in% samps.test] %>%
      dcast(., POP+SAMPLE~LOCUS, value.var='GT')

    # PCA fit to the testing set
    PCA.test <- as.matrix(X.test[, rownames(PCA.train$rotation), with=FALSE]) %*%
      PCA.train$rotation

    # DA fit to the testing set
    DA.test <- predict(DA.train, newdata=PCA.test[, 1:pcPreds])

    # Predictions
    predTab <- data.table(
      POP=X.test$POP,
      SAMPLE=X.test$SAMPLE,
      POP.PRED=DA.test$class
    )
  }

  ### CV statistics
  if(method %in% c('loo_cv','train_test')){
    pops.uniq <- dat$POP %>% unique

    global <- predTab[, sum(POP==POP.PRED)/length(SAMPLE)]

    popComps <- CJ(POP=pops.uniq, POP.PRED=pops.uniq)

    predPairsLong <- lapply(1:nrow(popComps), function(i){
      pop.obs <- popComps$POP[i]
      pop.pred <- popComps$POP.PRED[i]
      assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
      data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
    }) %>%
      do.call('rbind', .)

    predPairsWide <- predPairsLong %>%
      dcast(., POP~POP.PRED, value.var='ASSIGN')

    list(
      global=global, pairs.long=predPairsLong, pairs.wide=predPairsWide
    ) %>%
      return()
  }
}


