# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus, NUMER=msp-msg, DENOM=msp+(nc-1)*msg))
})
}
# --------------------------------------------+
# For individual genotypes
# --------------------------------------------+
if(input_type=='genos'){
popNames <- sort(unique(pop_id))
# The number of populations
r <- length(unique(pop_id))
# Create allele frequency, sample size, and heterozygosity matrices.
# ... (1) Get the values for each population
allpopVals <- lapply(popNames, function(pop){
popGenos <- dat[which(pop_id==pop),]
# Get values for each locus for the population
locpopVals <- apply(popGenos, 2, function(xx){
yy <- na.omit(xx)
n <- length(yy)
p <- sum(yy)/(length(yy)*2)
h <- sum(yy==1)/length(yy)
return(list(n=n, p=p, h=h))
})
# Combine information from all loci into single row
n <- do.call('cbind', lapply(locpopVals, function(xx){ xx$n }))
p <- do.call('cbind', lapply(locpopVals, function(xx){ xx$p }))
h <- do.call('cbind', lapply(locpopVals, function(xx){ xx$h }))
rownames(n) <- pop
rownames(p) <- pop
rownames(h) <- pop
return(list(n=n, p=p, h=h))
})
# ... (2) Now combine populations
sampMat <- do.call('rbind', lapply(allpopVals, function(xx){ xx$n }))
freqMat <- do.call('rbind', lapply(allpopVals, function(xx){ xx$p }))
hetMat <- do.call('rbind', lapply(allpopVals, function(xx){ xx$h }))
# Iterate over each locus
lociVar <- lapply(lociNames, function(locus){
ni <- sampMat[, locus]
pi <- freqMat[, locus]
hi <- hetMat[, locus]
# Reorder, just to be sure
ni <- ni[names(pi)]
hi <- hi[names(pi)]
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(LOCUS=locus, NUMER=a, DENOM=a+b+c))
})
}
# Merge list items together
lociVar <- do.call('rbind', lociVar)
# Return data table
return(lociVar)
# .......... END
}
# Number of loci
n <- ncol(dat)
#' Bootstrapped Weir & Cockerham's FST
#'
#' Generate a vector of bootstrapped Weir and Cockerham's FST from observed
#' genotype data.
#'
#' @param dat Matrix: Allele frequencies for populations, or biallelic genotypes of
#' of individuals scores as integer counts of the Alt allele (0, 1, 2).
#' Populations or individuals are in rows, loci are in columns.
#' Column names are loci IDs and must exactly match those in argument \code{samp_size}.
#' @param input_type Character: One of two possible values: 'genos', calcualte
#' variance components from genotype matrix, or 'freqs', calculate variance
#' components from an allele frequency matrix.
#'
#' @param pop_id  Charater: A vector of population IDs. Default is NULL and
#' is only required if \code{input_type=='genos'}. Must be the same length
#' as \code{nrow(dat)} and the order of values must match the order of rows in \code{dat}.
#'
#' @param samp_size Matrix: The sample size for each locus in each population.
#' Default is \code{NULL} and is required if \code{input_type=='freqs'}.
#' Allows for different sample sizes at each locus, for example, if there
#' is missing data. Populations in rows, loci in columns. Rows must be
#' in the same order as rows in \code{dat}. Column names are loci IDs
#' and must all occur in \code{dat}.
#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @return Returns a vector bootstrapped multilocus FST values.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#'
#' @export
fstWC_boot <- function(dat, input_type, pop_id=NULL, samp_size=NULL, boots=100){
require(pbapply)
# Number of loci
n <- ncol(dat)
# For each ith bootstrap...
cat('Performing FST bootstrap calculations', '\n')
fst_boot <- unlist(pblapply(1:boots, function(i){
# Get indices of the loci to boostrap resample
index <- sample(1:n, size=n, replace=TRUE)
# Get bootstrapped variance components
if(input_type=='genos'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, pop_id=pop_id)
} else if(input_type=='freqs'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, samp_size=samp_size)
}
# The mean permuted FST
fst <- sum(bootVarcomps$NUMER) / sum(bootVarcomps$DENOM)
return(fst)
}))
return(fst_boot)
}
fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
require(pbapply)
# Number of loci
n <- ncol(dat)
i
i <- 1
# Get indices of the loci to boostrap resample
index <- sample(1:n, size=n, replace=TRUE)
index
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, samp_size=samp_size)
dat[, index]
#' Bootstrapped Weir & Cockerham's FST
#'
#' Generate a vector of bootstrapped Weir and Cockerham's FST from observed
#' genotype data.
#'
#' @param dat Matrix: Allele frequencies for populations, or biallelic genotypes of
#' of individuals scores as integer counts of the Alt allele (0, 1, 2).
#' Populations or individuals are in rows, loci are in columns.
#' Column names are loci IDs and must exactly match those in argument \code{samp_size}.
#' @param input_type Character: One of two possible values: 'genos', calcualte
#' variance components from genotype matrix, or 'freqs', calculate variance
#' components from an allele frequency matrix.
#'
#' @param pop_id  Charater: A vector of population IDs. Default is NULL and
#' is only required if \code{input_type=='genos'}. Must be the same length
#' as \code{nrow(dat)} and the order of values must match the order of rows in \code{dat}.
#'
#' @param samp_size Matrix: The sample size for each locus in each population.
#' Default is \code{NULL} and is required if \code{input_type=='freqs'}.
#' Allows for different sample sizes at each locus, for example, if there
#' is missing data. Populations in rows, loci in columns. Rows must be
#' in the same order as rows in \code{dat}. Column names are loci IDs
#' and must all occur in \code{dat}.
#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @return Returns a vector bootstrapped multilocus FST values.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#'
#' @export
fstWC_boot <- function(dat, input_type, pop_id=NULL, samp_size=NULL, boots=100){
require(pbapply)
# Number of loci
n <- ncol(dat)
# For each ith bootstrap...
cat('Performing FST bootstrap calculations', '\n')
fst_boot <- unlist(pblapply(1:boots, function(i){
# Get indices of the loci to boostrap resample
index <- sample(1:n, size=n, replace=TRUE)
# Get bootstrapped variance components
if(input_type=='genos'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, pop_id=pop_id)
} else if(input_type=='freqs'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, samp_size=samp_size[, index])
}
# The mean permuted FST
fst <- sum(bootVarcomps$NUMER) / sum(bootVarcomps$DENOM)
return(fst)
}))
return(fst_boot)
}
fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
boot_fst <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
fstList
# Output list
fstList <- list()
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat, input_type='freqs', samp_size=sampMat)
# Theta across loci
fstList$multilocus.mean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.boot <- fst.boot
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
fstList
fst.locus <- lociVar$NUMER / lociVar$DENOM
names(fst.locus) <- lociVar$LOCUS
fstList$perlocus <- fst.locus
fstList
boots
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
# Output for each Xth pair
Xlist <- list()
# Population pairs
pairCombos <- combn(x=rownames(freqMat), m=2)
X <- pairCombos[,1]
X
# Output for each Xth pair
Xlist <- list()
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
Xlist
# Pair ID
pair_id <- paste(X, collapse='/')
pair_id
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
fst.ci
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
Xlist
# For the Xth pair
pairList <- apply(pairCombos, 2, function(X){
# Output for each Xth pair
Xlist <- list()
# Pair ID
pair_id <- paste(X, collapse='/')
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
}
# Theta per locus
if(perLocus==TRUE){
Xlist$perlocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
}
# Return the data for Xth pair
return(Xlist)
})
pairList
do.call('rbind', lapply(pairList, function(xx){ xx$boot }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairList, function(xx){ xx$ci }))
fstList
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
fstList$multilocus.mean
# Combine multilocus estimates
fstList$multilocus.mean <- do.call('rbind', lapply(pairList, function(xx){ xx$mean }))
fstList$multilocus.mean
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Add to the output list
fstList$multilocus.dist <- as.dist(fst.dist, diag=TRUE)
fstList$multilocus.dist
fstList$perlocus <- do.call('rbind', lapply(pairList, function(xx){ xx$perlocus }))
fstList
#' Calculate Weir and Cockerham's FST from allele frequencies
#'
#' Takes a matrix of biallelic allele frequencies, and a matrix of sample sizes,
#' and calculates Weir and Cockerham's FST, i.e. theta (Weir & Cockerham, 1984).
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param doPairs Logical: Should pairwise FST be calculated? Default = \code{FALSE},
#' which calculates the among population FST.
#'
#' @param bootCI Logical: Should bootstrap confidence intervals be estimated?
#' Default = \code{FALSE}.
#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @param doDist Logical: Should a a distance matrix of FST be returned?
#' Default = \code{FALSE}. Only applied when \code{doPairs==TRUE}.
#'
#' @param perLocus Logical: Should the per locus FST be returned?
#' Default = \code{FALSE}.
#'
#' @return A list with up to three different indices.
#' \enumerate{
#'    \item \code{$fst.mean}: contains the mean FST across loci. For among populations,
#'          this is a vector, whereas for pairwise analyses it is a data table
#'          with a \code{$POP1}, \code{$POP2}, and \code{$FST} column.
#'    \item \code{$fst.locus}: contains the locus-specific FST values
#'          if \code{perLocus==TRUE}. For amonong populations, this is a vector,
#'          but for pairwise analyses, this is a data table with population pairs.
#'    \item \code{$fst.dist}: will contain a distance matrix of FST values
#'          if \code{doPairs==TRUE} and \code{doDist==TRUE}.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' data(genomalicious_Freqs)
#' freqMat <- genomalicious_Freqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
#'
#' @export
fstWC_freqs <- function(freqMat, sampMat, doPairs=FALSE, bootCI=FALSE, boots=100, doDist=FALSE, perLocus=FALSE){
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
if(doDist==TRUE & doPairs==FALSE){
warning('Argument doDist set to TRUE, but doPairs set to FALSE: Will
only calcualte a distance matrix for pairwise analyses.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# Output list
fstList <- list()
# --------------------------------------------+
# Code: FST among all populations
# --------------------------------------------+
# Calculate among populations
if(doPairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat, input_type='freqs', samp_size=sampMat)
# Theta across loci
fstList$multilocus.mean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.boot <- fst.boot
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
}
# Theta per locus
if(perLocus==TRUE){
fst.locus <- lociVar$NUMER / lociVar$DENOM
names(fst.locus) <- lociVar$LOCUS
fstList$perlocus <- fst.locus
}
# Return among population analyses
return(fstList)
}
# --------------------------------------------+
# Code: FST between population pairs
# --------------------------------------------+
if(doPairs==TRUE){
# Population pairs
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairList <- apply(pairCombos, 2, function(X){
# Output for each Xth pair
Xlist <- list()
# Pair ID
pair_id <- paste(X, collapse='/')
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
}
# Theta per locus
if(perLocus==TRUE){
Xlist$perlocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
}
# Return the data for Xth pair
return(Xlist)
})
# Combine multilocus estimates
fstList$multilocus.mean <- do.call('rbind', lapply(pairList, function(xx){ xx$mean }))
# Combine bootstrap replicates
if(bootCI==TRUE){
fstList$multilocus.boot <- do.call('rbind', lapply(pairList, function(xx){ xx$boot }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairList, function(xx){ xx$ci }))
}
# If an FST distance matrix was requested:
if(doDist==TRUE){
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Add to the output list
fstList$multilocus.dist <- as.dist(fst.dist, diag=TRUE)
}
# Combine the per locus estimates
if(perLocus==TRUE){
fstList$perlocus <- do.call('rbind', lapply(pairList, function(xx){ xx$perlocus }))
}
# Return pairwise analyses
return(fstList)
}
}
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
roxygenise()
library(genomalicious)
?fstWC_genos
?fstWC_varcomps
?fstWC_boot
View(fstWC_boot)
?fstWC_perm
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
