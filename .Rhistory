stop('Argument `scatterLook` must be one of "ggplot" or "classic". See ?dapc_plot.')
}
if(class(popBarScale)!='numeric'){
stop('Argument `popBarScale` must be a numeric value. See ?dapc_plot.')
}
if(popBarScale<1){
stop('Argument `popBarScale` must be >=1. See ?dapc_plot.')
}
if(class(sampleShow)!='logical'){
stop('Argument `sampleShow` must be a logical value. See ?dapc_plot.')
}
if(!(legendPos%in%c('top','right','left','bottom','none'))){
stop('Argument `legendPos` must be a character value, one of
"top", "right", "left", "bottom", or "none". See ?dapc_plot.')
}
if(scatterLook=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position=legendPos, axis.ticks.length = unit(0.2, 'cm'))
} else if(scatterLook=='classic'){
plotTheme <- theme_bw() + theme(
panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position=legendPos
, axis.ticks.length=unit(0.2, 'cm'))
}
# Specific checks for each type
if(type=='scatter'){
# Check table
if(!'da.tab'%in%names(dapcList)){
stop(
'For `type=="scatter"`, the argument `dapcList` needs the index
`dapcList$da.tab`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.tab$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="scatter"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.tab$POP`. See ?dapc_plot.'
)
}
}
}
if(type=='probs'){
# Check table
if(!'da.prob'%in%names(dapcList)){
stop(
'For `type=="probs"`, the argument `dapcList` needs the index
`dapcList$da.prob`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.prob$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="probs"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.prob$POP`. See ?dapc_plot.'
)
}
}
}
if(type=='assign'){
if(!'pairs.long' %in% names(dapcList)){
stop('For `type==assign`, there must be index `dapcList$pairs.long`. See dapc_plot?')
}
if(!is.null(plotColours) & length(plotColours)<2){
stop('Argument `plotColours` requires 2 or more colours.')
}
if(is.null(plotColours)){
plotColours <- c('white', '#0030C1', '#D6012C')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
### Plot scatter
if(type=='scatter'){
plot.tab <- dapcList$da.tab
# Get axes
axX <- paste0('LD',axisIndex[1])
axY <- paste0('LD',axisIndex[2])
# Percent explained variance
eigvals <- dapcList$da.fit$svd^2
varX <- round(eigvals[axisIndex[1]]/sum(eigvals) * 100, 2)
varY <- round(eigvals[axisIndex[2]]/sum(eigvals) * 100, 2)
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY, colour='POP')) +
plotTheme +
theme(legend.position=legendPos) +
geom_point() +
stat_ellipse(type='norm') +
labs(
x=paste0('LD', axisIndex[1], ' (', varX, '%)')
, y=paste0('LD', axisIndex[2], ' (', varY, '%)')
, colour=NULL
)
# Add points and population colours if specified
if(is.null(plotColours)==FALSE){
gg <- gg + scale_colour_manual(values=plotColours) + labs(colour=NULL)
}
}
### Plot probabilities
if(type=='probs'){
plot.tab <- dapcList$da.prob
samp.order <- plot.tab %>%
.[, c('POP','SAMPLE')] %>%
unique %>%
setorder(., POP, SAMPLE) %>%
.[, ORDER:=(1:.N)]
plot.tab <- left_join(plot.tab, samp.order) %>% as.data.table
plot.pops <- left_join(
plot.tab[, .(MIN=(min(as.integer(ORDER)))-0.5), by=POP],
plot.tab[, .(MAX=(max(as.integer(ORDER)))+0.5), by=POP],
)
# Create skeleton of plot
gg <- ggplot() +
theme(
panel.border = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle=30, hjust=1),
axis.ticks.length.x = unit(1.5, 'mm'),
axis.ticks.length.y = unit(1.5, 'mm'),
legend.position=legendPos
) +
geom_col(
data=plot.tab,
mapping=aes(x=ORDER, y=PROB, fill=POP.PRED)
) +
geom_rect(
data=plot.pops,
mapping=aes(xmin=MIN, xmax=MAX, fill=POP),
ymax=-0.02,
ymin=-0.04*popBarScale,
inherit.aes=FALSE
) +
scale_x_continuous(
expand=c(0,0),
breaks=1:max(samp.order$ORDER),
labels=samp.order$SAMPLE
) +
scale_y_continuous(
expand=c(0,0),
limits=c(-0.04*popBarScale, 1.01)
) +
labs(x='Samples', y='Probability', fill=NULL)
# Add points and population colours if specified
if(is.null(plotColours)==FALSE){
gg <- gg + scale_fill_manual(values=plotColours) + labs(colour=NULL)
}
# Remove sample names if specified
if(sampleShow==FALSE){
gg <- gg + theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank()
)
}
}
### Plot assignment rates
if(type=='assign'){
plot.tab <- dapcList$pairs.long
gg <- ggplot(plot.tab, aes(x=POP, y=POP.PRED, fill=ASSIGN)) +
theme(
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks.length.x = unit(1.5, 'mm'),
axis.ticks.length.y = unit(1.5, 'mm'),
legend.position=legendPos
) +
geom_tile(colour='grey20') +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
scale_fill_gradientn(
colours=plotColours,
guide = guide_colorbar(frame.colour = "grey20", ticks.colour = "grey20")
) +
labs(x='Observed', y='Predicted', fill='Assignment rate')
}
### Output
return(gg)
}
dapc_plot(DAPC.fit, type='probs', popBarScale=5,
plotColours=c(Pop1='#08c7e0', Pop2='#4169e1', Pop3='#e46adf', Pop4='#ce0073'),
sampleShow=FALSE, legendPos='none'
)
library(genomalicious)
library(genomalicious)
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
dapc.list <- DAPC.fit
dapcList <- DAPC.fit
type='probs'
scatterLook='ggplot'
axisIndex=c(1,2)
popBarScale=1
sampleShow=TRUE
plotColours=NULL
legendPos='top'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2', 'tidyverse')){ require(lib, character.only = TRUE)}
# Check that the input is a list
if('list'!=class(dapcList)){
stop(
'Argument `dapcList` must be a list, and specifically generated using
the function, dapc_fit. See ?dapc_plot.')
}
# Parameter checks
if(!scatterLook %in% c('ggplot','classic')){
stop('Argument `scatterLook` must be one of "ggplot" or "classic". See ?dapc_plot.')
}
if(class(popBarScale)!='numeric'){
stop('Argument `popBarScale` must be a numeric value. See ?dapc_plot.')
}
if(popBarScale<1){
stop('Argument `popBarScale` must be >=1. See ?dapc_plot.')
}
if(class(sampleShow)!='logical'){
stop('Argument `sampleShow` must be a logical value. See ?dapc_plot.')
}
if(!(legendPos%in%c('top','right','left','bottom','none'))){
stop('Argument `legendPos` must be a character value, one of
"top", "right", "left", "bottom", or "none". See ?dapc_plot.')
}
if(scatterLook=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position=legendPos, axis.ticks.length = unit(0.2, 'cm'))
} else if(scatterLook=='classic'){
plotTheme <- theme_bw() + theme(
panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position=legendPos
, axis.ticks.length=unit(0.2, 'cm'))
}
# Specific checks for each type
if(type=='scatter'){
# Check table
if(!'da.tab'%in%names(dapcList)){
stop(
'For `type=="scatter"`, the argument `dapcList` needs the index
`dapcList$da.tab`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.tab$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="scatter"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.tab$POP`. See ?dapc_plot.'
)
}
}
}
stop(
'For `type=="probs"`, the argument `dapcList` needs the index
`dapcList$da.prob`. See ?dapc_plot.'
)
# Check table
if(!'da.prob'%in%names(dapcList)){
stop(
'For `type=="probs"`, the argument `dapcList` needs the index
`dapcList$da.prob`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.prob$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="probs"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.prob$POP`. See ?dapc_plot.'
)
}
}
if(type=='probs'){
# Check table
if(!'da.prob'%in%names(dapcList)){
stop(
'For `type=="probs"`, the argument `dapcList` needs the index
`dapcList$da.prob`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.prob$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="probs"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.prob$POP`. See ?dapc_plot.'
)
}
}
}
if(type=='assign'){
if(!'pairs.long' %in% names(dapcList)){
stop('For `type==assign`, there must be index `dapcList$pairs.long`. See dapc_plot?')
}
if(!is.null(plotColours) & length(plotColours)<2){
stop('Argument `plotColours` requires 2 or more colours.')
}
if(is.null(plotColours)){
plotColours <- c('white', '#0030C1', '#D6012C')
}
}
plot.tab <- dapcList$da.prob
plot.tab
plot.tab %>%
split(., by='POP')
plot.tab %>%
split(., by='POP') %>%
lapply(., function(D){
pop <- D$POP[1]
D[POP.PRED==pop] %>%
setorder(., -PROB) %>%
.[, c('POP','SAMPLE')]
})
plot.tab %>%
split(., by='POP') %>%
lapply(., function(D){
pop <- D$POP[1]
D[POP.PRED==pop] %>%
setorder(., -PROB) %>%
.[, c('POP','SAMPLE')]
}) %>%
do.call('rbind', .)
samp.order <- plot.tab %>%
# Split by pop
split(., by='POP') %>%
# Iterate through pop, and order by probability
lapply(., function(D){
pop <- D$POP[1]
D[POP.PRED==pop] %>%
setorder(., -PROB) %>%
.[, c('POP','SAMPLE')]
}) %>%
# Combine
do.call('rbind', .) %>%
# Add in an order ID
.[, ORDER:=1:.N]
plot.tab <- left_join(plot.tab, samp.order) %>% as.data.table
plot.pops <- left_join(
plot.tab[, .(MIN=(min(as.integer(ORDER)))-0.5), by=POP],
plot.tab[, .(MAX=(max(as.integer(ORDER)))+0.5), by=POP],
)
plot.pops
# Create skeleton of plot
gg <- ggplot() +
theme(
panel.border = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle=30, hjust=1),
axis.ticks.length.x = unit(1.5, 'mm'),
axis.ticks.length.y = unit(1.5, 'mm'),
legend.position=legendPos
) +
geom_col(
data=plot.tab,
mapping=aes(x=ORDER, y=PROB, fill=POP.PRED)
) +
geom_rect(
data=plot.pops,
mapping=aes(xmin=MIN, xmax=MAX, fill=POP),
ymax=-0.02,
ymin=-0.04*popBarScale,
inherit.aes=FALSE
) +
scale_x_continuous(
expand=c(0,0),
breaks=1:max(samp.order$ORDER),
labels=samp.order$SAMPLE
) +
scale_y_continuous(
expand=c(0,0),
limits=c(-0.04*popBarScale, 1.01)
) +
labs(x='Samples', y='Probability', fill=NULL)
# Add points and population colours if specified
if(is.null(plotColours)==FALSE){
gg <- gg + scale_fill_manual(values=plotColours) + labs(colour=NULL)
}
# Remove sample names if specified
if(sampleShow==FALSE){
gg <- gg + theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank()
)
}
gg
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
data(data_Genos)
dat <- data_Genos
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
flip=FALSE
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table'%in%class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table': see ?DT2Mat_genos")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix'%in%class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix': see ?DT2Mat_genos")
}
# If providing a matrix, check that there are row names.
if('matrix'%in%class(dat) & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names: see ?DT2Mat_genos")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if('data.table'%in%class(dat)){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol: see ?DT2Mat_genos")
}
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified: see ?DT2Mat_genos")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified: see ?DT2Mat_genos")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified: see ?DT2Mat_genos")
}
}
# Evaluate the genotype data type.
# genoInitClass stores the initial genotype score information.
if(flip==FALSE){
genoInitClass <- class(dat[[genoCol]])
} else if(flip==TRUE){
genoInitClass <- class(dat[, 1])
}
if(!genoInitClass %in% c('character', 'integer', 'numeric')){
stop('Genotypes must be either a character or integer class: see ?DT2Mat_genos')
}
# If genotypes counts are numerics, convert to integers.
if(genoInitClass=='numeric'){
if(class(dat)[1]=='data.table'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
} else if('matirx' %in% class(dat)){
dat <- apply(dat, 2, as.integer)
}
}
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
genoMat
genoMat
genoMat <- dat %>%
.[, c(sampCol, locusCol, genoCol), with=FALSE] %>%
spread(., key=locusCol, value=genoCol) %>%
as.data.table()
genoMat
genoMat <- dat %>%
.[, c(sampCol, locusCol, genoCol), with=FALSE] %>%
spread(., key=locusCol, value=genoCol) %>%
as.data.table()
sampVals <- genoMat[[sampCol]]
sampVals
?dcast
genoMat <- dat %>%
.[, c(sampCol, locusCol, genoCol), with=FALSE] %>%
spread(., key=locusCol, value=genoCol) %>%
as.data.table
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
genoMat
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
?lda
?MASS::lda
library(genomalicious)
# Make just those documents that have changed
roxygenise()
