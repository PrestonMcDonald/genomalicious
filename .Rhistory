#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data.table
#' vcf2DT(vcfPath)
#'
#' @export
vcf2DT <- function(vcfFile){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Return the data.table
return(vcfDT[, !dropCols, with=FALSE])
}
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
readLines(vcfPath)
vcf2DT(vcfPath)
#' VCF file to data table
#'
#' Reads a VCF file and converts to a data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @return A data.table with all the columns contained in the original VCF file with
#' some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value as the $ID column.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = ''.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data.table
#' vcf2DT(vcfPath)
#'
#' @export
vcf2DT <- function(vcfFile, dropCols=''){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Return the data.table
return(vcfDT[, !dropCols, with=FALSE])
}
vcfPath
vcf2DT(vcfPath)
#' VCF file to data table
#'
#' Reads a VCF file and converts to a data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @return A data.table with all the columns contained in the original VCF file with
#' some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value as the $ID column.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = ''.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data.table
#' vcf2DT(vcfPath)
#'
#' @export
vcf2DT <- function(vcfFile, dropCols=NULL){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Return the data.table
return(vcfDT[, !dropCols, with=FALSE])
}
vcf2DT(vcfPath)
#' VCF file to data table
#'
#' Reads a VCF file and converts to a data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @return A data.table with all the columns contained in the original VCF file with
#' some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value as the $ID column.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = ''.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data.table
#' vcf2DT(vcfPath)
#'
#' @export
vcf2DT <- function(vcfFile, dropCols=NULL){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Return the data.table
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
vcf2DT(vcfPath)
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID'))
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO'))
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO'))
vcf2DT(vcfPath)
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL'))
vcf2DT(vcfPath)
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL'))
vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')) ->x
x
attributes(x)
attributes(x, 'vcf_head') <- 'hi'
attributes(x, 'vcf_head', 'hi')
attr(x)
attr(x=x)
attr(x=x, 'vcf_head') <- 'hi'
x
attributes(x)
?fread
vcfFile <- vcfPath
vcfFile
?readLInes
?readLines
vcfFile
readLines(vcfFile, n=headPos-1)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
headPos
readLines(vcfFile, n=headPos-1)
readLines(vcfFile, n=headPos)
readLines(vcfFile, n=headPos-1)
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
#' VCF file to data table
#'
#' Reads a VCF file and converts to a data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @return A data.table with all the columns contained in the original VCF file with
#' some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value as the $ID column.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = \code{NULL}.
#'
#' @param keepComments Logical: Should the VCF comments be kept? Default = \code{FALSE},
#' however, if \code{TRUE}, this is returned as an attribute of the data table.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data table
#' vcf2DT(vcfPath)
#'
#' # Read in VCF, but drop some columns
#' vcf2DT(vcfPath, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL'))
#'
#' @export
vcf2DT <- function(vcfFile, dropCols=NULL, keepHead=FALSE){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
, keepComments=TRUE)
#'
#' # Now read it in as a data table
#' vcf2DT(vcfPath)
#'
#' # Read in VCF, but drop some columns, and keep comments
#' vcf2DT(vcfPath
#'     , dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
#'     , keepComments=TRUE)
#'
#' @export
vcf2DT <- function(vcfFile, dropCols=NULL, keepComments=FALSE){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code                                ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(2/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Generate a LOCUS column
cat('(3/4) Generating locus IDs', sep='\n')
vcfDT[, LOCUS:=paste(CHROM, POS, sep='_')]
# Extract the first value in the FORMAT column as a vector
format <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
# Iterate through each index in 'format', then access the DATA column from vcfDT
# and pull out that specific value.
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
for(f in 1:length(format)){
vcfDT[, format[f]] <- unlist(lapply(strsplit(vcfDT$DATA, ':'), function(d){ d[f] }))
}
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
, keepComments=TRUE)
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
, keepComments=TRUE)
readVcf2
attr(readVcf2, 'keep_comments')
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
attr(readVcf2, 'vcf_comments')
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'INFO', 'QUAL')
, keepComments=TRUE)
readVcf2
attr(readVcf2, 'vcf_comments')
