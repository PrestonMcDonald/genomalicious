, iters=50)
fst_among <- fstWC_genos(data_4pops
, permTest=TRUE
, bootCI=TRUE
, iters=50)
#' Calculate Weir and Cockerham's FST from genotypes
#'
#' Function takes a long format genotype data table and calculates
#' Weir & Cockerhams FST, i.e. theta (Weir & Cockerham, 1984). Can
#' also conduct permutation testing and calculate bootstrap
#' confidence intervals.
#'
#' @param dat Data table: A long format data table of biallelic genotypes,
#' coded as '/' separated alleles ('0/0', '0/1', '1/1'), or counts
#' of the Alt alleles (0, 1, 2, repsectively).
#' Four columns are required:
#' \enumerate{
#'    \item The population ID (see param \code{popCol}).
#'    \item The sampled individual ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The genotype (see param \code{genoCol}).
#' }
#'
#' @param popCol Character: The column name with the population information.
#' Default = \code{'POP'}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default = \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default = \code{'GT'}.
#'
#' @param num.cores Integer: Number of cores. Default is 1.
#'
#' @param iters Integer: The number of permutations or bootstrap replicates.
#' Default = 100.
#'
#' @param permTest Logical: Should a permutation test be conducted?
#' Default = \code{FALSE}.
#'
#' @param bootCI Logical: Should bootstrap confidence intervals be estimated?
#' Default = \code{FALSE}.
#'
#' @param doPairs Logical: Should pairwise FST be calculated? Default = \code{FALSE},
#' which calculates the among population FST.
#'
#' @param doDist Logical: Should a a distance matrix of FST be returned?
#' Default = \code{FALSE}. Only applied when \code{doPairs==TRUE}.
#'
#' @param perLocus Logical: Should the per locus FST be returned?
#' Default = \code{FALSE}.
#'
#' @details Permutation tests involve random shuffling of individuals
#' among populations, recalculating FST, and testing the hypothesis
#' that the permuted FST > observed FST. The p-value represents the
#' proportion of iterations that were "TRUE" to this expression. \cr \cr
#' Bootstrapping randomly samples the loci with replacement
#' to estimate the distribution of FST values around the multilocus
#' FST. Confidence intervals are calculated as the 2.5 and
#' 97.5 percentiles of the obtained bootstrapped FST values.
#'
#' @return Returns a list, the contents vary depending on argument choices. \cr
#' When \code{doPairs==FALSE}, the analysis is among populations.
#' \enumerate{
#'    \item \code{$multilocus.mean}: the multilocus FST.
#'    \item \code{$multilocus.perms}: a vector of permuted FST values.
#'    \item \code{$multilocus.pval}: the p-value from permutation tests.
#'    \item \code{$multilocus.ci}: a vector of bootstrap confidence intervals.
#'    \item \code{$perlocus}: a data table of the FST for each locus.
#' }
#' When \code{doPairs==TRUE}, the analysis is between population pairs.
#' \enumerate{
#'    \item \code{$multilocus.mean}: a data table of multilocus FST.
#'    \item \code{$multilocus.ci}: a data table of bootstrap confidence intervals.
#'    \item \code{$multilocus.dist}: a distance matrix of multilocus FST values.
#'    \item \code{$perlocus}: a data table of the FST for each locus.
#' }
#'
#' @examples
#' data(data_4pops)
#'
#' # Among popuation FST, with permutation tests
#' # and bootstrap confidence intervals.
#' fst_among <- fstWC_genos(data_4pops
#'                 , permTest=TRUE
#'                 , bootCI=TRUE
#'                 , iters=50)
#'
#' # Pairwise FST, with per locus estimates
#' # and a distance matrix
#' fst_pairs <- fstWC_genos(data_4pops
#'                 , doPairs=TRUE
#'                 , doDist=TRUE
#'                 , perLocus=TRUE)
#'
#' @export
fstWC_genos <- function(dat, popCol='POP', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', num.cores=1
, permTest=FALSE, bootCI=FALSE, iters=100
, doPairs=FALSE, doDist=FALSE, perLocus=FALSE){
# BEGIN ...........
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that all columns are specified correctly
if(sum(c(popCol, sampCol, locusCol, genoCol) %in% colnames(dat)) != 4){
stop('Arguments popCol, sampCol, locusCol, and genoCol must be
columns in dat. See ?genos2freqs.')
}
# Rename columns
colnames(dat)[
match(c(sampCol, popCol, locusCol, genoCol), colnames(dat))
] <- c('SAMPLE', 'POP', 'LOCUS', 'GT')
# Get genotype class
genoClass <- class(dat$GT)
# Convert to integer
if(genoClass=='character'){
dat[, GT:=genoscore_converter(GT)]
} else if(genoClass=='numeric'){
dat[, GT:=as.integer(GT)]
}
# --------------------------------------------+
# Register parallel cluster if requested
# --------------------------------------------+
if(num.cores>1){
my.cluster <- makeCluster(num.cores)
registerDoParallel(my.cluster)
}
# --------------------------------------------+
# Code: Set up key parameters
# --------------------------------------------+
# Get the unique population and sample combinations
popsampDt <- unique(dat[, c('POP', 'SAMPLE')])
# Create a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT')
# Match genoMat rows to populations in popsampDt to
# create a population ID
pop_id <- popsampDt$POP[match(rownames(genoMat), popsampDt$SAMPLE)]
# Create an empty list to store values in
fstList <- list()
# --------------------------------------------+
# Code: FST among all populations
# --------------------------------------------+
if(doPairs==FALSE){
# START AMONG
# Observed variance components
obsVarcomps <- fstWC_varcomps(dat=genoMat, input_type='genos', pop_id=pop_id, num.cores=num.cores)
# The observed FST
fstList$multilocus.mean <- sum(obsVarcomps$NUMER) / sum(obsVarcomps$DENOM)
if(permTest==TRUE){
fstList$multilocus.perms <- fstWC_perm(genoMat=genoMat, pop_id=pop_id, perms=iters, num.cores=num.cores)
# p-value for permutations
fstList$multilocus.pval <- sum(fstList$multilocus.perms > fstList$multilocus.mean) / iters
}
if(bootCI==TRUE){
fstList$multilocus.boots <- fstWC_boot(dat=genoMat, input_type='genos', pop_id=pop_id, boots=iters, num.cores=num.cores)
# Percentiles
fstList$multilocus.ci <- quantile(fstList$multilocus.boots, c(0.025, 0.975))
}
if(perLocus==TRUE){
obsVarcomps[, FST:=NUMER/DENOM]
fstList$perlocus <- obsVarcomps[, c('LOCUS', 'FST')]
}
# Kill cluster if run in parallel
if(num.cores>1){
gc()
stopCluster(my.cluster)
}
# Output
return(fstList)
# END AMONG
}
# --------------------------------------------+
# Code: FST between population pairs
# --------------------------------------------+
if(doPairs==TRUE){
# START PAIRWISE
# Unique populations
uniq_pops <- unique(pop_id)
# Population pair combinations
pairCombos <- combn(uniq_pops, 2)
# Get the pairwise variance components
cat('Performing pairwise FST calculations', '\n')
pairCalcs <- apply(pairCombos, 2, function(pops){
cat('....', pops, '\n')
# Create a list to return
popList <- list()
# Get the population ID indices
pop1 <- which(pop_id==pops[1])
pop2 <- which(pop_id==pops[2])
# Pair name
pair_id <- paste(pops[1], pops[2], sep='/')
# Subset the genotypes and ID
genoSub <- genoMat[c(pop1, pop2),]
pop_id_sub <- pop_id[c(pop1, pop2)]
# Calculate the variance components
cat('........ Variance components', '\n')
popsVarcomps <- fstWC_varcomps(dat=genoSub, input_type='genos', pop_id=pop_id_sub, num.cores=num.cores)
popsVarcomps$POP1 <- pops[1]
popsVarcomps$POP2 <- pops[2]
popsVarcomps$PAIR <- pair_id
# Multilocus FST
popList$multilocus.mean <- data.table(
popsVarcomps[1, c('POP1', 'POP2', 'PAIR')]
, FST=sum(popsVarcomps$NUMER)/sum(popsVarcomps$DENOM))
# Permutation tests
if(permTest==TRUE){
cat('........ Permutation tests', '\n')
boot_fst <- fstWC_perm(genoMat=genoSub, pop_id=pop_id_sub, perms=iters, num.cores=num.cores)
boot_pval <- sum(boot_fst > popList$multilocus.mean) / iters
popList$multilocus.perms <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], PERM=1:iters, FST=boot_fst)
popList$multilocus.pval <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], PVAL=boot_pval)
}
# Bootstrap confidence intervals
if(bootCI==TRUE){
cat('........ Bootstrap confidence intervals', '\n')
boot_fst <- fstWC_boot(dat=genoSub, pop_id=pop_id_sub, boots=iters, num.cores=num.cores)
popList$multilocus.boots <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], BOOT=1:iters, FST=boot_fst)
boot_ci <- quantile(boot_fst, c(0.025, 0.975))
popList$multilocus.ci <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], CI025=boot_ci[1], CI975=boot_ci[2])
}
# Calculate per Locus FST
if(perLocus==TRUE){
cat('........ Per locus FST', '\n')
popsVarcomps[, FST:=NUMER/DENOM]
popList$perlocus <- popsVarcomps[, c('PAIR', 'POP1', 'POP2', 'FST')]
}
# Return all the calculations for this population pair
return(popList)
})
# Combine multilocus FST pairwise data
fstList$multilocus.mean <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.mean }))
# If permutation test conducted, combine pairwise data
if(doPairs==TRUE){
fstList$multilocus.perms <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.perms }))
fstList$multilocus.pvals <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.pval }))
}
# If bootstrapped CI calculated, combine pairwise data
if(bootCI==TRUE){
fstList$multilocus.boots <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.boots }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.ci }))
}
# If a distance matrix is required, make it.
if(doDist==TRUE){
distMat <- matrix(0, nrow=length(uniq_pops), ncol=length(uniq_pops), dimnames=list(uniq_pops, uniq_pops))
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
distMat[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
fstList$multilocus.dist <- as.dist(distMat, diag=TRUE)
}
}
# If per locus FST estimates calculated, combine pairwise data
if(perLocus==TRUE){
fstList$perlocus <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$perlocus }))
}
# Kill cluster if run in parallel
if(num.cores>1){
gc()
stopCluster(my.cluster)
}
# Output
return(fstList)
# END PAIRWISE
}
# ............ END
}
fst_among <- fstWC_genos(data_4pops
, permTest=TRUE
, bootCI=TRUE
, iters=50)
fst_among <- fstWC_genos(data_4pops
, permTest=TRUE
, bootCI=TRUE
, iters=10)
fst_among <- fstWC_genos(data_4pops
, permTest=TRUE
, bootCI=TRUE
, iters=10, num.cores=3)
?fstWC_freqs
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, num.cores = 3)
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, num.cores = 3, boot=20)
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, num.cores = 3, boots=20)
data(data_Freqs)
freqMat <- data_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, num.cores = 3, boots=20, bootCI=TRUE)
warnings()
library(genomalicious)
data(data_4pops)
dat=data_4pops
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
popCol='POP'
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Create a genlight object
genoMat <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
genLight <- new('genlight', as.list(as.data.frame(t(genoMat))))
library(genomalicious)
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Create a genlight object
genoMat <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
genLight <- new('genlight', as.list(as.data.frame(t(genoMat))))
?genlight
genLight@ind.names
genLight@loc.names
colnames(genoMat)
# Add in locus names
genLight@loc.names <- colnames(genoMat)
genLight@loc.names
#' Convert a long genotype data table into a \code{genlight} object
#'
#' For a data table with samples and loci as rows (long-format data table),
#' create a \code{genlight} object, as per the \code{adegenet} package
#' (Jombart 2011 Bioinformatics). Must be biallelic.
#'
#' @param dat Data.table: Contains samples and loci in rows, with a
#' separate column endcoding genotypes, where each allele is separated
#' by a '/', or as a count of ref alleles (0, 1 or 2). Assumes biallelic loci.
#' Code missing data as './.' for characters, and \code{NA} for Ref allele counts.
#'
#' @param sampCol Character: Column with sample information. Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: Column with locus information. Default = \code{'LOCUS'}.
#'
#' @param genoCol Character: Column with genotype information. Default = \code{'GT'}.
#'
#' @param popCol Character: Column with population information. Optional.
#'
#' @return A \code{genind} object, with the slot \code{pop} slot filled if argumnet
#' \code{popCol} is specified.
#'
#' @references
#' Jombart (2008) adegenet 1.3-1: new tools for the analysis of genome-wide SNP data. Bioinformatics.
#'
#' @examples
#' data(data_4pops)
#'
#' data_4pops
#'
#' adegenet_DT2genlight(data_4pops)
#' adegenet_DT2genlight(data_4pops, popCol='POP')
#'
#' @export
adegenet_DT2genlight <- function(dat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', popCol=NULL){
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Create a genlight object
genoMat <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
genLight <- new('genlight', as.list(as.data.frame(t(genoMat))))
# Add in locus names
genLight@loc.names <- colnames(genoMat)
if(is.null(popCol)==FALSE){
# The population and samples
popDat <- unique(dat[, c(sampCol, popCol), with=FALSE])
genLight@pop <- as.factor(popDat[[popCol]][match(genLight@ind.names, popDat[[sampCol]])])
}
return(genLight)
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
#' Parametric bootstrap of \code{poolne_estim} allele frequencies
#'
#' Takes the results of \code{poolne_estim} (Gautier et al. 2013) and
#' performs a parametric bootstrap of Ref allele frequencies based on their
#' pi (estimated Ref allele frequency) and sd (the standard deviation).
#'
#' @param dat Data table: the \code{poolne_estim} data. For example, the
#' output from \code{genomalicious::poolne_estim_output()}. Requires 4 columns: \cr
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$PI}, the estimated population frequency for the Ref allele. \cr
#'    \item \code{$SD}, the standard deviation for PI.
#' }
#'
#' @param num.sims Numeric, the number of simulations to generate. Default = \code{100}.
#'
#' @return A data table, with the following columns:
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$BOOT.NUM}, the simulation number. \cr
#'    \item \code{$BOOT.PI}, the simulated pi (Ref allele frequency).
#' }
#'
#' @details The values of \code{PI} and \code{SD} in \code{dat} are used to generate
#' the alpha and beta paramters of a beta distribution, where: \cr
#' \cr
#' \code{alpha = ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2} \cr
#' \code{beta = alpha * (1 / Mu - 1)} \cr
#' \cr
#' Here, values of \code{dat$PI} take on the values of \code{Mu} (the mean) and
#' \code{(dat$SD)^2} take on the values of \code{Var} (the variance). \cr
#' \cr
#' From the resulting beta distribution, \code{num.sims} values are drawn to create
#' a distribution of possible allele frequencies (for each locus) that might exist in the sampled
#' populations (given the associated mean and error estimated by \code{poolne_estim}).
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # Get the poolne estimat pi estimates
#' pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
#'
#' # Simulate potential distributions
#' pi.sims <- poolne_estim_boot_pi(pi.data, 100)
#' pi.sims
#'
#' @export
poolne_estim_boot_pi <- function(dat, num.sims=100){
# BEGIN ...................
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'pbapply')){ require(lib, character.only=TRUE)}
# Check the class of dat.
if(!'data.table' %in% class(dat)){
stop("Argument dat needs to be class 'data.table'.")
}
# Check that the correct columns are in dat.
if(length(which((c('POOL', 'LOCUS', 'PI', 'SD') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POOL, $LOCUS, $PI, and $SD.")
}
# --------------------------------------------+
# Internal function
# --------------------------------------------+
beta_est <- function(Mu, Var) {
# Estimates beta distribution shape params from the mean and variance of
# a sample.
#
# INPUTS:
#   Mu    (numeric)   The sample mean
#   Var   (numeric)   The sample variance
#
# OUTPUTS:
#   A list: $alpha = alpha param, $beta = beta param
# BEGIN ............
alpha <- ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2
beta <- alpha * (1 / Mu - 1)
return(params = list(alpha = alpha, beta = beta))
# ............ END
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# 1. Get parameters for beta distribution per locus.
# 2. Use parameters to simulate allele frequencies.
freq.sims <- dat[, beta_est(PI, SD^2), by=c('POOL','LOCUS')] %>%
.[, .(BOOT.PI=rbeta(num.sims, shape1=alpha, shape2=beta)), by=c('POOL','LOCUS')] %>%
.[, BOOT.NUM:=1:.N, by=c('POOL','LOCUS')]
# Return final dataset
return(do.call('rbind', freq.sims))
# ................... END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
