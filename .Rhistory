return(lociDivpar)
}
idip4pops <- idip_DTfreqs(freqDat=genomalicious_PoolPi, strucMat=metaPop
, popCol='POOL', locusCol='LOCUS', freqCol='PI')
idip
idip4pops
als3 <- data.table(POP=c(rep('Pop1', 3), rep('Pop2', 3))
, LOCUS=rep('Locus1', 6), ALLELE=c(letters[1:3], letters[1:3])
, FREQ=c(0.5, 0.25, 0.25, 0.9, 0.05, 0.05))
als3
idip3als <- idip_DTfreqs(freqDat=als3
, strucMat=matrix(c(rep('metapop', 2), 'Pop1', 'Pop2'), ncol=2, byrow=TRUE)
, popCol='POP'
, locusCol='LOCUS'
, freqCol='FREQ'
, alleleCol='ALLELE')
idip3als
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
#' # Create a population hierarchy
#' metapop <- matrix(c(rep('metapop', 4)
#'                , paste('Group', c(1,1,2,2))
#'                , paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#'
#' # Run IDIP
#' idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
#'              , popCol='POP', locusCol='LOCUS', genoCol='GT')
#'
#' @export
idip_DTgenos <- function(snpDat, strucMat, popCol='POP'
, locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
# Stop if strucMat doesn't meet min rows
if(nrow(strucMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
# Population check
uniqPops <- unique(snpDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
# Correction in case some alleles are not recorded
# for all populations (mostly a problem for non-biallelic data).
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
# Combine into a matrx
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
return(lociDivpar)
}
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
metapop <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
# Run IDIP
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
idipGenos <- idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metaPop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
idipGenos[, 1:6]
grps <- list(A=c(1:100), B=c(20:100, 101:120), C=c(1:50, 70:120))
grps
sig <- list(A=c(1,8,88), B=c(88, 101), C=c(88, 102, 118, 120))
grps <- list(A=c(1:100), B=c(20:100, 101:120), C=c(1:50, 70:120))
sig <- list(A=c(1,8,88), B=c(88, 101), C=c(88, 102, 118, 120))
lociList <- grps
lociSig <- sig
perms <- 1000L
intersect(lociList)
if(is.null(names(lociList))){ names(lociList) <- paste0('group', length(lociList)) }
if(is.null(names(lociList))){ names(lociList) <- paste0('group', length(lociList)) }
if(is.null(names(lociSig))){ names(lociSig) <- paste0('group', length(lociSig)) }
lociList
grps <- list(A=c(1:101), B=c(20:100, 101:120), C=c(1:50, 70:120))
sig <- list(A=c(1,8,88), B=c(88, 101), C=c(88, 102, 118, 120))
lociList
grps <- list(A=c(1:101), B=c(20:100, 101:120), C=c(1:50, 70:120))
lociList <- grps
lociList
combn(names(lociList), 2)
apply(combn(names(lociList), 2), 2, function(pair){
length(intersect(lociSig[pair[1]], lociSig[pair[2]]))
})
lociSig
apply(combn(names(lociList), 2), 2, function(pair){
length(intersect(lociSig[[pair[1]]], lociSig[pair[[2]]]))
})
combn(names(lociList), 2)
pair <- combn(names(lociList), 2)[,1]
pair
pair[1]
lociSig[[pair[1]]]
lociSig[pair[[2]]]
pair[[2]]
pair[[2]]
pair[[2]]
length(intersect(lociSig[[pair[1]]], lociSig[[pair[2]]]))
apply(combn(names(lociList), 2), 2, function(pair){
length(intersect(lociSig[[pair[1]]], lociSig[[pair[2]]]))
})
unlist(lociSig)
unique(unlist(lociSig))
unlist(lociSig)
table(unlist(lociSig))
shareCount <- table(unlist(lociSig))
shareCount > 1
shareCount[shareCount > 1]
names(shareCount)[shareCount > 1]
shareCount[shareCount > 1]
length(shareCount[shareCount > 1])
shareCount
sigCount <- table(unlist(lociSig))
numGrps <- length(lociSig)
sigCount <- table(unlist(lociSig))
length(sigCount[sigCount >= numGrps])
length(sigCount[sigCount > numGrps])
length(sigCount[sigCount > numGrps])
length(sigCount[sigCount > numGrps])
length(sigCount[sigCount == numGrps])
length(sigCount[sigCount==numGrps])
shareSize <- length(sigCount[sigCount==numGrps])
numShares <- length(sigCount[sigCount==numGrps])
numShares
numShares <- length(sigCount[sigCount==numGrps])
lapply(lociSig, length)
numSigs <- lapply(lociSig, length)
grpNames <- names(lociSig)
grpNames
numSigs[[n]]
n <- 'A'
numSigs[[n]]
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
})
sharePerm <- lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
})
sharePerm <- lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
})
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm
sharePerm <- table(sharePerm)
sharePerm
sharePerm==numGrps
sum(sharePerm==numGrps)
lapply(1:perms, function(i){
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm <- table(sharePerm)
return(sum(sharePerm==numGrps))
})
permDat <- lapply(1:perms, function(i){
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm <- table(sharePerm)
return(sum(sharePerm==numGrps))
})
permDat
permDat <- unlist(permDat)
permDat
permDat >= numSigs
permDat
numSigs
numShares
permDat >= numShares
sum(permDat >= numShares)
sum(permDat >= numShares)/perms
data(genomalicious_PoolPi)
datFreqs <- genomalicious_PoolPi
pca <- pca_DTfreqs(datFreqs)
data(genomalicious_4pops)
datGt <- genomalicious_4pops
data(genomalicious_4pops)
datGt <- genomalicious_4pops
pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
pca_scatter(pca)
pca_plot(pca)
gg <- pca_plot(pca)
gg + xlabs('PC1 (1%)')
gg + xlab('PC1 (1%)')
data(genomalicious_4pops)
datGt <- genomalicious_4pops
pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
pca_plot(pca)
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca, type='scree')
pca_plot(pca, type='scree')
pca_plot(pca$sdev^2, type='scree')
#'
#' # Plot scree of eigenvalues, using prcomp or numeric object
#' pca_plot(pca, type='scree')
#' pca_plot(pca$sdev^2, type='scree')
#'
#' # Plot cumulative explained variance, using prcomp or numeric object
#' pca_plot(pca, type='expvar', look='classic')
#' pca_plot(pca$sdev^2, type='expvar', look='classic')
#'
#' @export
pca_plot <- function(dat, type='scatter', axisIndex=c(1,2)
, pops=NULL, popColours=NULL, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(type=='scatter'){
if(class(dat)!='prcomp' | !class(dat)[1]%in%c('data.table','data.frame','matrix')){
stop('Argument dat must be one of the following object classes for making
scatter plots: prcomp, data.table, data.frame, or matrix.')
}
} else if(type %in% c('scree', 'expvar')){
if(class(dat)!='prcomp' | class(dat)!='numeric'){
stop('Argument dat must be prcomp or numeric class object to make a scree
or cumulative explained variance plot.')
}
}
# Check that type is specified correctly
if(!type %in% c('scatter', 'scree', 'expvar')){
stop("Argument type must be either: 'scatter', 'scree', or 'expvar'.")
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popColours are all in pops.
if(is.null(pops)==FALSE & is.null(popColours)==FALSE &
!sum(names(popColours)%in%unique(pops))==length(unique(pops))){
stop("Argument popColours misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plotTheme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popColours)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popColours)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'expvar')){
# Vector of number PCs for X axis
if(class(dat)=='prcomp'){
dat <- dat$sdev^2
X <- 1:length(dat)
} else if(class(dat)=='numeric'){
X <- 1:length(dat)
}
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='expvar'){
Y <- 1- dat/sum(dat); axY <- 'Cumulative explained variance'
} else{ Y <- dat; axY <- 'Eigenvalue'}
# The plot
gg <- (ggplot(data.frame(X, Y), aes(x=X, y=Y))
+ plotTheme
+ geom_line()
+ geom_point()
+ labs(x='PC axis', y=axY)
)
}
# Plot and return
plot(gg)
return(gg)
}
pca_plot(pca, type='scree')
dat <- pca
class(dat)!='prcomp'
class(dat)!='numeric'
#'
#' # Plot scree of eigenvalues, using prcomp or numeric object
#' pca_plot(pca, type='scree')
#' pca_plot(pca$sdev^2, type='scree')
#'
#' # Plot cumulative explained variance, using prcomp or numeric object
#' pca_plot(pca, type='expvar', look='classic')
#' pca_plot(pca$sdev^2, type='expvar', look='classic')
#'
#' @export
pca_plot <- function(dat, type='scatter', axisIndex=c(1,2)
, pops=NULL, popColours=NULL, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(type=='scatter'){
if(!class(dat)[1]%in%c('data.table','data.frame','matrix','prcomp')){
stop('Argument dat must be one of the following object classes for making
scatter plots: prcomp, data.table, data.frame, or matrix.')
}
} else if(type %in% c('scree', 'expvar')){
if(!class(dat)[1]%in%c('numeric','prcomp')){
stop('Argument dat must be prcomp or numeric class object to make a scree
or cumulative explained variance plot.')
}
}
# Check that type is specified correctly
if(!type %in% c('scatter', 'scree', 'expvar')){
stop("Argument type must be either: 'scatter', 'scree', or 'expvar'.")
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popColours are all in pops.
if(is.null(pops)==FALSE & is.null(popColours)==FALSE &
!sum(names(popColours)%in%unique(pops))==length(unique(pops))){
stop("Argument popColours misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plotTheme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popColours)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popColours)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'expvar')){
# Vector of number PCs for X axis
if(class(dat)=='prcomp'){
dat <- dat$sdev^2
X <- 1:length(dat)
} else if(class(dat)=='numeric'){
X <- 1:length(dat)
}
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='expvar'){
Y <- 1- dat/sum(dat); axY <- 'Cumulative explained variance'
} else{ Y <- dat; axY <- 'Eigenvalue'}
# The plot
gg <- (ggplot(data.frame(X, Y), aes(x=X, y=Y))
+ plotTheme
+ geom_line()
+ geom_point()
+ labs(x='PC axis', y=axY)
)
}
# Plot and return
plot(gg)
return(gg)
}
pca_plot(pca, type='scree')
pca_plot(pca$sdev^2, type='scree')
pca_plot(pca, type='expvar', look='classic')
pca_plot(pca$sdev^2, type='expvar', look='classic')
pca_plot(pca$sdev^2, type='expvar', look='classic')
pca_plot(pca)
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca)
# Get more specific on scatter
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
X
poolfstat_DT(X, genomalicious_PoolInfo)
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
class(Y)
Y$Fst
Y$pooldat
class(Y$pooldat)
Y$pooldat
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
poolFst <- poolfstat_DT(X, genomalicious_PoolInfo)
bootFst <- poolfstat_boot(poolFst$pooldat, 100)
bootFst
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
data("genomalicious_4pops")
?genomalicious_4pops
?poolfstat_boot
?idip_DTfreqs
?idip_DTgenos
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
