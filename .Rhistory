stats <- dat[, sum(is.na(GT))/length(GT), by=c(focus, 'POP')]
gg <- (ggplot(stats, aes(x=V1))
+ plotTheme + theme(strip.text.x=element_text(face='bold'))
+ geom_histogram(fill=plotColours[1], colour='black')
+ labs(x='Missing genotypes (%)'
, y=paste0('Number of ', plotBy))
+ facet_wrap(~ POP, ncol=plotNCol))
}
# Finish up
plot(gg)
return(gg)
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
data(data_4pops)
datGt <- data_4pops
datGt <- do.call('rbind'
, lapply(split(datGt, datGt$SAMPLE), function(x){
if(x$POP[1]=='Pop1'){ pr <- 0.1
} else if(x$POP[1]=='Pop2'){ pr <- 0.2
} else{ pr <- 0.05}
numMiss <- rnbinom(1, size=8, prob=pr)
idxMiss <- sample(1:nrow(x), size=numMiss, replace=FALSE)
x$GT[idxMiss] <- NA
return(x)
}))
head(datGt, 10)
missHeatmap(datGt)
missHeatmap(datGt, plotColours=c('black', 'plum2'))
dat=datGt
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
popCol='POP'
plotColours='white'
plotNCol=2
# --------------------------------------------+
# Libraries, assertions, and setup
# --------------------------------------------+
for(lib in c('ggplot2', 'data.table','gridExtra')){ require(lib, character.only = TRUE)}
# Rename columns
colnames(dat)[
match(c(locusCol, genoCol, sampCol), colnames(dat))
] <- c('LOCUS', 'GT', 'SAMPLE')
# Rename the population column, if it was specified
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
# Make two colours, if only one specified
if(length(plotColours)<2){
plotColours <- c('white', 'royalblue')
}
# Assign a new column to record missing data
dat[, MISS:=as.integer(!is.na(GT))]
if(is.na(popCol)){
# If no population column is specified (NA)
gg <- (ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.tile = element_text(size=11)
,panel.border=element_rect(fill=NA, colour='black')
,panel.background=element_blank()
,panel.grid=element_blank()
,legend.position='none'
)
)
} else {
# If population column is specified, make indiviudal plot
# for each population
ggLs <- lapply(unique(dat$POP), function(pop){
g <- (ggplot(dat[POP==pop], aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus', title=pop)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,legend.position='none'
)
)
return(g)
})
gg <- do.call('grid.arrange', c(ggLs, ncol=plotNCol))
}
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus', title=pop)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,facet_wrap(~POP)
,legend.position='none'
)
)
dat
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus', title=pop)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,facet_wrap(~POP)
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus', title=pop)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,facet_wrap(~POP)
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,facet_wrap(~POP)
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,facet_wrap(~POP)
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
,facet_wrap(~POP)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ facet_wrap(~POP)
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,legend.position='none'
)
)
(ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ facet_wrap(~POP, scales='free_x')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,legend.position='none'
)
)
#' Plot a heatmap of missing information
#'
#' Use to visualise the presence or absence of genetic information
#' for all sample and locus combinations. Can also be subset
#' by population.
#'
#' @param dat Data table: Contains genetic information and must have
#' the following columns,
#' \enumerate{
#'   \item The sampled individuals (see param \code{sampCol}).
#'   \item The locus ID (see param \code{locusCol}).
#'   \item The genotype column, e.g. a genotype of allele frequency,
#'   (see param \code{genoCol}).
#' }
#'
#' @param sampCol Character: The column name with the sampled
#' individual ID. Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus ID.
#' Default = \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype info.
#' Default = \code{'GT'}. Missing data should be represeted by \code{NA}.
#'
#' @param popCol Character: The column name with the population ID.
#' Optional parameter. Default = \code{NA}.
#'
#' @param plotColours Character: Vector of colours to use in plotting.
#' Size depends on values specified for parameters \code{type} and
#' \code{popCol}, see Details.
#'
#' @param plotNCol Integer: The number of columns to arrange indiviudal
#' population plots into. Only takes effect when \code{popCol} is specified.
#' Default = 2.
#'
#' @examples
#' ####   MISSING GENOTYPE DATA   ####
#' data(data_4pops)
#' datGt <- data_4pops
#'
#' # Add missing values
#' datGt <- do.call('rbind'
#'                 , lapply(split(datGt, datGt$SAMPLE), function(x){
#'                   if(x$POP[1]=='Pop1'){ pr <- 0.1
#'                   } else if(x$POP[1]=='Pop2'){ pr <- 0.2
#'                   } else{ pr <- 0.05}
#'                   numMiss <- rnbinom(1, size=8, prob=pr)
#'                   idxMiss <- sample(1:nrow(x), size=numMiss, replace=FALSE)
#'                   x$GT[idxMiss] <- NA
#'                  return(x)
#'                 }))
#'
#' head(datGt, 10)
#'
#' # Heatmaps, default and specified colours
#' missHeatmap(datGt)
#' missHeatmap(datGt, plotColours=c('black', 'plum2'))
#'
#' # Heatmaps, by population
#' missHeatmap(datGt, popCol='POP')
#'
#' ####   CATCH PLOT OUTPUT FOR LATER USE   ####
#' gg4pops <- missHeatmap(datGt, popCol='POP')
#' plot(gg4pops)
#'
#' @export
missHeatmap <- function(dat
, sampCol='SAMPLE', locusCol='LOCUS'
, genoCol='GT', popCol=NA
, plotColours='white', plotNCol=2){
# --------------------------------------------+
# Libraries, assertions, and setup
# --------------------------------------------+
for(lib in c('ggplot2', 'data.table','gridExtra')){ require(lib, character.only = TRUE)}
# Rename columns
colnames(dat)[
match(c(locusCol, genoCol, sampCol), colnames(dat))
] <- c('LOCUS', 'GT', 'SAMPLE')
# Rename the population column, if it was specified
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Make two colours, if only one specified
if(length(plotColours)<2){
plotColours <- c('white', 'royalblue')
}
# Assign a new column to record missing data
dat[, MISS:=as.integer(!is.na(GT))]
if(is.na(popCol)){
# If no population column is specified (NA)
gg <- (ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.tile = element_text(size=11)
,panel.border=element_rect(fill=NA, colour='black')
,panel.background=element_blank()
,panel.grid=element_blank()
,legend.position='none'
)
)
} else {
# If population column is specified, make indiviudal plot
# for each population
ggLs <- lapply(unique(dat$POP), function(pop){
g <- (ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ facet_wrap(~POP, scales='free_x')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,plot.title=element_text(hjust=0.5, size=11, face='bold')
,legend.position='none'
)
)
return(g)
})
gg <- do.call('grid.arrange', c(ggLs, ncol=plotNCol))
}
# Finish up
plot(gg)
return(gg)
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
data(data_PoolPi)
data(data_PoolInfo)
bayescan_inputs_pool(dat=data_PoolPi
, pool.info=data_PoolInfo
, file.bayescan='Bayescan_input.txt'
, file.loci='Bayescan_loci.txt'
, poolCol='POOL', locusCol='LOCUS', freqCol='PI')
library(genomalicious)
bayescan_inputs_pool(dat=data_PoolPi
, pool.info=data_PoolInfo
, file.bayescan='Bayescan_input.txt'
, file.loci='Bayescan_loci.txt'
, poolCol='POOL', locusCol='LOCUS', freqCol='PI')
data_PoolPi
dat=data_PoolPi
pool.info=data_PoolInfo
file.bayescan='Bayescan_input.txt'
file.loci='Bayescan_loci.txt'
poolCol='POOL'
locusCol='LOCUS'
freqCol='PI'
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table')){ require(lib, character.only=TRUE) }
# Check class of dat.
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check class of pool.info.
if(!'data.table' %in% class(pool.info)){ stop("Argument pool.info isn't a data table") }
# Test for the necessary columns in dat.
if(sum(c(poolCol, locusCol, freqCol) %in% colnames(dat))!= 3){
stop("Argument dat needs the columns specified by the arguments: poolCol, locusCol, freqCol")
}
# Test for the necessary columns in pool.info.
if(sum(c('POOL', 'INDS') %in% colnames(pool.info))!=2){
stop("Argument pool.info needs the columns $POOL and $INDS.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','P')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $P,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=(INDS*2)-REF.COUNT]
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, INDS=X$INDS, ALLELES=2
, REF=X$REF.COUNT, ALT=X$ALT.COUNT)
return(BS.dt)
})
dat.spl
dat.spl[[1]] %>% X
dat.spl[[1]] -> X
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X$INDS <- pool.info[POOL==pool]$IND
X
pool.info
pool.info[POOL==pool]$IND
pool <- X$POOL[1]
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=(INDS*2)-REF.COUNT]
X
X
X[, c('P', 'INDS')]
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=(INDS*2)-REF.COUNT]
X
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, INDS=X$INDS, ALLELES=2
, REF=X$REF.COUNT, ALT=X$ALT.COUNT)
return(BS.dt)
BS.dt
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $P,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=(INDS*2)-REF.COUNT]
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, INDS=X$INDS, ALLELES=2
, REF=X$REF.COUNT, ALT=X$ALT.COUNT)
return(BS.dt)
})
# Write (append) lines to txt file.
# First open the file
# Next append the number of loci and number of pops
# Then iterate through each j-th population in BS.ls and write data to file
file.create(file.bayescan)
for(i in c(num.loci,'',num.pops,'')){ write(i,file=file.bayescan,append=TRUE) }
for(j in 1:length(names(BS.ls))){
write(paste0('[pop]=',j),file=file.bayescan,append=TRUE)
write.table(BS.ls[[j]][,-'LOCUS'],file=file.bayescan,append=TRUE,col.names=FALSE,row.names=FALSE)
write('',file=file.bayescan,append=TRUE)
}
# Create a file of marker/locus order
fwrite(x=BS.ls[[1]][,c('MARKER','LOCUS')], file=file.loci, sep='\t')
