# Percentiles
fstList$multilocus.ci <- quantile(fstList$multilocus.boots, c(0.025, 0.975))
}
if(perLocus==TRUE){
obsVarcomps[, FST:=NUMER/DENOM]
fstList$perlocus <- obsVarcomps[, c('LOCUS', 'FST')]
}
# Kill cluster if run in parallel
if(num.cores>1){
gc()
stopCluster(my.cluster)
}
# Output
return(fstList)
# END AMONG
}
# --------------------------------------------+
# Code: FST between population pairs
# --------------------------------------------+
if(doPairs==TRUE){
# START PAIRWISE
# Unique populations
uniq_pops <- unique(pop_id)
# Population pair combinations
pairCombos <- combn(uniq_pops, 2)
# Get the pairwise variance components
cat('Performing pairwise FST calculations', '\n')
pairCalcs <- apply(pairCombos, 2, function(pops){
cat('....', pops, '\n')
# Create a list to return
popList <- list()
# Get the population ID indices
pop1 <- which(pop_id==pops[1])
pop2 <- which(pop_id==pops[2])
# Pair name
pair_id <- paste(pops[1], pops[2], sep='/')
# Subset the genotypes and ID
genoSub <- genoMat[c(pop1, pop2),]
pop_id_sub <- pop_id[c(pop1, pop2)]
# Calculate the variance components
cat('........ Variance components', '\n')
popsVarcomps <- fstWC_varcomps(dat=genoSub, input_type='genos', pop_id=pop_id_sub, num.cores=num.cores)
popsVarcomps$POP1 <- pops[1]
popsVarcomps$POP2 <- pops[2]
popsVarcomps$PAIR <- pair_id
# Multilocus FST
popList$multilocus.mean <- data.table(
popsVarcomps[1, c('POP1', 'POP2', 'PAIR')]
, FST=sum(popsVarcomps$NUMER)/sum(popsVarcomps$DENOM))
# Permutation tests
if(permTest==TRUE){
cat('........ Permutation tests', '\n')
boot_fst <- fstWC_perm(genoMat=genoSub, pop_id=pop_id_sub, perms=iters, num.cores=num.cores)
boot_pval <- sum(boot_fst > popList$multilocus.mean) / iters
popList$multilocus.perms <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], PERM=1:iters, FST=boot_fst)
popList$multilocus.pval <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], PVAL=boot_pval)
}
# Bootstrap confidence intervals
if(bootCI==TRUE){
cat('........ Bootstrap confidence intervals', '\n')
boot_fst <- fstWC_boot(dat=genoSub, pop_id=pop_id_sub, boots=iters, num.cores=num.cores)
popList$multilocus.boots <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], BOOT=1:iters, FST=boot_fst)
boot_ci <- quantile(boot_fst, c(0.025, 0.975))
popList$multilocus.ci <- data.table(PAIR=pair_id, POP1=pops[1], POP2=pops[2], CI025=boot_ci[1], CI975=boot_ci[2])
}
# Calculate per Locus FST
if(perLocus==TRUE){
cat('........ Per locus FST', '\n')
popsVarcomps[, FST:=NUMER/DENOM]
popList$perlocus <- popsVarcomps[, c('PAIR', 'POP1', 'POP2', 'LOCUS', 'FST')]
}
# Return all the calculations for this population pair
return(popList)
})
# Combine multilocus FST pairwise data
fstList$multilocus.mean <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.mean }))
# If permutation test conducted, combine pairwise data
if(doPairs==TRUE){
fstList$multilocus.perms <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.perms }))
fstList$multilocus.pvals <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.pval }))
}
# If bootstrapped CI calculated, combine pairwise data
if(bootCI==TRUE){
fstList$multilocus.boots <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.boots }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$multilocus.ci }))
}
# If a distance matrix is required, make it.
if(doDist==TRUE){
distMat <- matrix(0, nrow=length(uniq_pops), ncol=length(uniq_pops), dimnames=list(uniq_pops, uniq_pops))
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
distMat[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
fstList$multilocus.dist <- as.dist(distMat, diag=TRUE)
}
}
# If per locus FST estimates calculated, combine pairwise data
if(perLocus==TRUE){
fstList$perlocus <- do.call('rbind', lapply(pairCalcs, function(pops){ pops$perlocus }))
}
# Kill cluster if run in parallel
if(num.cores>1){
gc()
stopCluster(my.cluster)
}
# Output
return(fstList)
# END PAIRWISE
}
# ............ END
}
fst_pairs <- fstWC_genos(data_4pops
, doPairs=TRUE
, doDist=TRUE
, perLocus=TRUE)
fst_pairs
pbapply
?pbapply
dat=data_4pops
popCol='POP'
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
num.cores=1
permTest=FALSE
bootCI=FALSE
iters=100
doPairs=FALSE
doDist=FALSE
perLocus=FALSE
dat
popPermTab <- dat[, c('POP','SAMPLE')]
popPermTab <- dat[, c('POP','SAMPLE')] %>% unique()
popPermTab
fst_among <- fstWC_genos(data_4pops
, permTest=TRUE
, bootCI=TRUE
, iters=50)
fst_among
dat
# --------------------------------------------+
# For allele frequencies
# --------------------------------------------+
FUN_freqs_varcomp <- function(pi, ni, r){
# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Output as data.table
data.table(NUMER=msp-msg, DENOM=msp+(nc-1)*msg)
}
dat[, sum(GT)/length(GT), by=c('POP','LOCUS')]
dat[, sum(GT==1)/length(GT), by=c('POP','LOCUS')]
dat[, sum(GT)/length(GT), by=c('POP','LOCUS')]
dat
dat[, sum(GT)/length(GT), by=c('POP','LOCUS')]
dat[, sum(GT)/(length(GT)*2), by=c('POP','LOCUS')]
# Make pool data
data_PoolFreqs <- data_4pops %>%
.[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('CHROM','POS','LOCUS','ALT','REF','POP')] %>%
.[, DP:=rnbinom(1, 20, prob=0.2), by=c('POP','CHROM','LOCUS')] %>%
.[, AO:=rbinom(n=1, size=DP, prob=FREQ)] %>%
.[, RO:=DP-AO] %>%
setnames(., old='POP', new='POOL') %>%
.[, INDS:=30]
data_PoolFreqs
data_PoolFreqs
data_PoolFreqs$FREQ
data_PoolFreqs <- data_4pops %>%
.[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('CHROM','POS','LOCUS','ALT','REF','POP')] %>%
.[, DP:=rnbinom(1, 20, prob=0.2), by=c('POP','CHROM','LOCUS')] %>%
.[, AO:=rbinom(n=1, size=DP, prob=FREQ)] %>%
.[, RO:=DP-AO] %>%
setnames(., old='POP', new='POOL') %>%
.[, INDS:=30]
save(data_PoolFreqs, file='data/data_PoolFreqs.RData')
data_PoolFreqs <- data_4pops %>%
.[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('CHROM','POS','LOCUS','ALT','REF','POP')] %>%
.[, DP:=rnbinom(1, 20, prob=0.2), by=c('POP','CHROM','LOCUS')] %>%
.[, AO:=rbinom(n=1, size=DP, prob=FREQ)] %>%
.[, RO:=DP-AO] %>%
setnames(., old='POP', new='POOL') %>%
.[, INDS:=30]
save(data_PoolFreqs, file='data/data_PoolFreqs.RData')
# Make pool info data
data_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(data_PoolInfo, file='data/data_PoolInfo.RData')
# Make a frequency matrix
data_FreqsMat <- data_PoolFreqs %>%
dcast(., POOL~LOCUS, value.var='FREQ') %>%
as.data.frame() %>%
column_to_rownames(., 'POOL') %>%
as.matrix()
save(data_FreqsMat,file='data/data_FreqsMat.RData')
# Make VCFs
vcf_head <- "##This is a toy dataset for the R package genomalicious - it emulates a VCF file
##INFO=<ID=DP,Number=1,Type=Integer,Description='The total depth across samples'>
##FORMAT=<ID=GT,Number=1,Type=String,Description='Genotype'>
##FORMAT=<ID=DP,Number=1,Type=Integer,Description='The total depth in a sample'>
##FORMAT=<ID=RO,Number=1,Type=Integer,Description='The reference allele counts in a sample'>
##FORMAT=<ID=AO,Number=1,Type=Integer,Description='The alternate allele counts in a sample'>"
# Make a VCF from 4 pop genotypes
vcf4pops <- do.call('rbind', lapply(unique(data_4pops$LOCUS), function(locus){
X <- data_4pops[LOCUS==locus]
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
vcfPools <- vcf4pops <- do.call('rbind', lapply(unique(data_PoolFreqs$LOCUS), function(locus){
X <- data_PoolFreqs[LOCUS==locus] %>%
copy %>%
.[, GT:='0/1']
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','POOL')] %>%
dcast(., LOCUS ~ POOL, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcfPools, 'inst/extdata/data_poolseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_poolseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_poolseq.vcf')
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
data("data_4pops")
dat <- data_4pops
dat[, sum(GT)/(length(GT)*2), by=c('POP','LOCUS')]
dat[, sum(GT==1)/length(GT), by=c('POP','LOCUS')]
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')]
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
)
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., .[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
)
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., .[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
)
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
)
# --------------------------------------------+
# For individual genotypes
# --------------------------------------------+
FUN_genos_varcomps <- function(ni, pi, hi, r){
# Reorder, just to be sure
ni <- ni[names(pi)]
hi <- hi[names(pi)]
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_freqs_varcomp(ni=N, pi=FREQ, hi=HO, r=sum(N)), by=LOCUS]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomp_genos(ni=N, pi=FREQ, hi=HO, r=sum(N)), by=LOCUS]
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomp_genos(ni=N, pi=FREQ, hi=HO, r=sum(N)), by=LOCUS]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=sum(N)), by=LOCUS]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
)
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=sum(N)), by=LOCUS]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
)
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[LOCUS=='Contig6_85']
D <- left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[LOCUS=='Contig6_85']
FUN_varcomps_genos(ni=D$N, pi=D$FREQ, hi=D$HO, r=sum(D$N))
D
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS]
left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM] %>%
print
fstTab <- left_join(
dat[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
dat[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., dat[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
fstTab
fstTab
fstTab[, sum(NUMER)/sum(DENOM)]
D <- data_PoolFreqs
FUN_varcomps_freqs <- function(pi, ni, r){
# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Output as data.table
data.table(NUMER=msp-msg, DENOM=msp+(nc-1)*msg)
}
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
D
dat <- data_PoolFreqs %>% copy %>% setnames(., old='POOL', new='POP')
dat
dat[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS]
# For frequencies
dat <- data_PoolFreqs %>% copy %>% setnames(., old='POOL', new='POP')
dat[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS]
fstLoc <- dat %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS]
fstLoc
fstLocus <- dat %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS]
fstGlobal <- fstLocus[, sum(NUMER)/sum(DENOM)]
fstGlobal
# For genotypes
dat <- data_4pops
FUN_fst_genos <- function(D){
left_join(
D[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
D[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')]
) %>%
left_join(
., D[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')]
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
}
fstLocus <- FUN_fst_genos(dat)
fstLocus
fstLocus
# Global FST
fstGlobal <- fstLocus[, sum(NUMER)/sum(DENOM)]
fstGlobal
# For genotype permutations
popPermTab <- dat[, c('POP','SAMPLE')] %>% unique
popPermTab
