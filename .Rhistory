#'
#' @param popCol Character: The column name with the population information.
#'
#' @param lociCol Character: The column name with the locus information.
#'
#' @param freqCol Character: The column name with the Ref allele frequency.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{lociCol}, and \code{freqCol} become void.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- freqs_DT2Mat(genomaliciousPi, popCol='POOL', lociCol='LOCUS', freqCol='PI', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- freqs_DT2Mat(freqMat, flip=TRUE)
#'
#' export
freqs_DT2Mat <- function(dat, popCol=NA, lociCol=NA, freqCol=NA, flip=FALSE){
# BEGIN ............
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is frequency matrix, but has no population IDs in the row names.")
}
# If providing a data table, check that popCol, lociCol, and freqCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(popCol, lociCol, freqCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, lociCol, or freqCol.")
}
}
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(freqCol)){
stop("Argument freqCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
freqDT <- spread(dat[, c(popCol, freqCol, lociCol), with=FALSE], key=lociCol, value=freqCol)
freqMat <- as.matrix(freqDT[, !popCol, with=FALSE])
rownames(freqMat) <- freqDT[[popCol]]
return(freqMat)
} else if(flip==TRUE){
freqDT <- data.table(dat, keep.rownames=TRUE)
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- 'POP'
locusNames <- colnames(freqDT)[which(colnames(freqDT)!='POP')]
freqDT <- melt(freqDT, id.vars='POP', variable='LOCUS', value='FREQ')
return(freqDT)
}
}
freqs_DT2Mat(freqMat, flip=TRUE)
genomaliciousFreqsLong
freqs_DT2Mat(genomaliciousFreqsLong, popCol='POOL', lociCol='LOCUS', freqCol='PI', flip=FALSE)
genomaliciousFreqsLong
freqs_DT2Mat(genomaliciousFreqsLong, popCol='POP', lociCol='LOCUS', freqCol='FREQ', flip=FALSE)
freqMat <- freqs_DT2Mat(genomaliciousFreqsLong, popCol='POP', lociCol='LOCUS', freqCol='FREQ', flip=FALSE)
freqs_DT2Mat(freqMat, flip=TRUE)
#' Convert a data table of allele frequencies into a matrix (or vice versa)
#'
#' Takes a data table of allele frequencies in long format and converts it into
#' a matrix in wide format (loci in columns and populations in rows). The reverse
#' can also be done.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of allele frequencies, then three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{lociCol}).
#'    \item (3) The Ref allele frequency (see param \code{freqCol}).
#' }
#' The population pool column serves as the pivot point to convert the long data table into a wide matrix.
#' If convertin from a frequency matrix to a data table, see argument \code{flip}.
#'
#' @param popCol Character: The column name with the population information.
#'
#' @param lociCol Character: The column name with the locus information.
#'
#' @param freqCol Character: The column name with the Ref allele frequency.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{lociCol}, and \code{freqCol} become void.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- freqs_DT2Mat(genomaliciousFreqsLong, popCol='POP', lociCol='LOCUS', freqCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- freqs_DT2Mat(freqMat, flip=TRUE)
#'
#' export
freqs_DT2Mat <- function(dat, popCol=NA, lociCol=NA, freqCol=NA, flip=FALSE){
# BEGIN ............
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is frequency matrix, but has no population IDs in the row names.")
}
# If providing a data table, check that popCol, lociCol, and freqCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(popCol, lociCol, freqCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, lociCol, or freqCol.")
}
}
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(freqCol)){
stop("Argument freqCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
freqDT <- spread(dat[, c(popCol, freqCol, lociCol), with=FALSE], key=lociCol, value=freqCol)
freqMat <- as.matrix(freqDT[, !popCol, with=FALSE])
rownames(freqMat) <- freqDT[[popCol]]
return(freqMat)
} else if(flip==TRUE){
freqDT <- data.table(dat, keep.rownames=TRUE)
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- 'POP'
locusNames <- colnames(freqDT)[which(colnames(freqDT)!='POP')]
freqDT <- melt(freqDT, id.vars='POP', variable='LOCUS', value='FREQ')
return(freqDT)
}
}
document()
genomaliciousReads
genos2freqs
data(genomaliciousGenos)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.Rdata')
genomaliciousGenos
genomaliciousGenos
genos2freqs(pgposerGenos)
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID; and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(pgposerGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
genos2freqs(genomaliciousGenos)
genomaliciousGenos
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.Rdata')
genos2freqs(genomaliciousGenos)
genomaliciousGenos
genos2freqs(genomaliciousGenos)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.Rdata')
genos2freqs(genomaliciousGenos)
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GENO}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)=='data.table'){
if(length(which((c('POP', 'IND', 'LOCUS', 'GENO') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $IND, $LOCUS, and $GENO.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
genomaliciousFreqsLong
genomaliciousGenos
genomalicious::genos2freqs(genomaliciousGenos)
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID;
#' and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
genos2freqs(genomaliciousGenos)
filter_maf(genomaliciousGenos, maf=0.1, type=genos)
filter_maf(genomaliciousGenos, maf=0.1, type='genos')
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' # ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.4
#' filter_maf(genomaliciousGenos, maf=0.1, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
filter_maf(genomaliciousGenos, maf=0.1, type='genos')
filter_maf(genomaliciousGenos, maf=0.4, type='genos')
filter_maf(genomaliciousGenos, maf=0.35, type='genos')
genomaliciousGenos
genos2freqs(genomaliciousGenos)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.Rdata')
genomaliciousGenos
genos2freqs(genomaliciousGenos)
3/20
filter_maf(genomaliciousGenos, maf=0.05, type='genos')
data(genomaliciousFreqs)
genomaliciousFreqs
filter_maf(genomaliciousFreqs, maf=0.05, type='freqs)
filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
document()
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
