# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(type=='scatter'){
if(!class(dat)[1]%in%c('data.table','data.frame','matrix','prcomp')){
stop('Argument dat must be one of the following object classes for making
scatter plots: prcomp, data.table, data.frame, or matrix.')
}
} else if(type %in% c('scree', 'expvar')){
if(!class(dat)[1]%in%c('numeric','prcomp')){
stop('Argument dat must be prcomp or numeric class object to make a scree
or cumulative explained variance plot.')
}
}
# Check that type is specified correctly
if(!type %in% c('scatter', 'scree', 'expvar')){
stop("Argument type must be either: 'scatter', 'scree', or 'expvar'.")
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popColours are all in pops.
if(is.null(pops)==FALSE & is.null(popColours)==FALSE &
!sum(names(popColours)%in%unique(pops))==length(unique(pops))){
stop("Argument popColours misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top', axis.ticks.length = unit(0.2, 'cm'))
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top'
, axis.ticks.length=unit(0.2, 'cm'))
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plotTheme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popColours)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popColours)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'expvar')){
# Vector of number PCs for X axis
if(class(dat)=='prcomp'){
dat <- dat$sdev^2
X <- 1:length(dat)
} else if(class(dat)=='numeric'){
X <- 1:length(dat)
}
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='expvar'){
Y <- 1- dat/sum(dat); axY <- 'Cumulative explained variance'
} else{ Y <- dat; axY <- 'Eigenvalue'}
# The plot
gg <- (ggplot(data.frame(X, Y), aes(x=X, y=Y))
+ plotTheme
+ geom_line()
+ geom_point()
+ labs(x='PC axis', y=axY)
)
}
# Plot and return
plot(gg)
return(gg)
}
pca_plot(pca, 'classic')
pca_plot(pca, look='classic')
dat <- genomalicious_4pops
dat
sampCol='SAMPLE'
popCol='POP'
locusCol='LOCUS'
refCol='REF'
altCol='ALT'
genoCol='GT'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
popSub <- c('Pop1', 'Pop2')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POOL %in% popSub]
}
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
genomalicious_PoolPi
dat
data(genomalicious_4pops)
datgt <- copy(genomalicious_4pops)
datgt
rm(datgt)
datGt <- copy(genomalicious_4pops)
unique(datGt$GT)[1:10]
unique(datGt$LOCUS)[1:10]
datGt <- datGt[LOCUS %in% unique(datGt$LOCUS)[1:10]]
datGt
sample(c('G', 'A', 'T', 'C'), nrow(datGt))
sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
datGt$REF <- sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
datGt$ALT <- sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
dat <- datGt
dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
dat[, sum(GT), by=c('LOCUS', 'REF', 'ALT', 'POP')]
dat[, sum(GT), by=c('LOCUS', 'POP')]
dat[, length(unique(SAMPLE)), by=POP]
dat[, sum(GT), by=c('LOCUS', 'POP')]
data(genomalicious_PoolPi)
genomalicious_PoolPi
dadi_inputs_pools(dat=genomalicious_PoolPi
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=c('Pop1', 'Pop2'))
a <- dat[, sum(GT), by=c('LOCUS', 'POP')]
a
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
r
r$V1 + a$V1
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- dat[, sum(GT), by=c('LOCUS', 'POP')]
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')]
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
r
a
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
dadi_inputs_pools(dat=genomalicious_PoolPi
, poolCol='POOL'
, locusCol='LOCUS'
, altCol='ALT'
, freqCol='PI'
, refCol='REF'
, indsCol='INDS'
, poolSub=c('Pop1', 'Pop2'))
r
spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
a
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
datGt
datGt -> dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')]
?allele_counts
dat[, allele_counts, by=c('POP', 'LOCUS')]
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
dat <- datGt
dat
acount <- genoscore_converter(dat$GT)
paste(acount, dat$GT)
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
datGt
unique(datGt$LOCUS)[1:10]
loci10 <- unique(datGt$LOCUS)[1:10]
loci10
sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
?sample
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
ref10
alt10
match(datGt$LOCUS, names(ref10))
ref10[match(datGt$LOCUS, names(ref10))]
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
data(genomalicious_4pops)
datGt <- copy(genomalicious_4pops)
# Subset data for example (10 loci) and create artificial Ref and Alt
# nucleotides for the purpose of illustration
loci10 <- unique(datGt$LOCUS)[1:10]
datGt <- datGt[LOCUS %in% loci10]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
dat <- datGt
dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
r
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
r
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
a
r
a$Pop1 + r$Pop1
a$Pop2 + r$Pop2
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
#' Genertate dadi input from individual genotype data
#'
#' Creates an input file for the program dadi, described in Gutenkunst et al. (2009).
#'
#' @param dat Data table: Contains population and genotype information. Genotypes
#' must be coded as '/' separated characters (e.g. '0/0', '0/1', or '1/1') or
#' integers of Alt allele counts (e.g. 0, 1, 2). Must contain the following columns:
#' \enumerate{
#' \item Sample ID (see argument \code{sampCol})
#' \item Population ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Genotyp
#' }
#'
#' @param sampCol Character: Sample ID. Default = \code{'SAMPLE'}.
#' @param popCol Character: Population pool ID. Default = \code{'POP'}.
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}.
#' @param refCol Character: Reference allele. Default = \code{'REF'}.
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}.
#' @param genoCol Character: The genotype. Default = \code{'GT'}.
#' @param popSub Character: The populations to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data table in the dadi input format.
#'
#' @references Gutenkunst et al. (2009) Inferring the joint demographic history of multiply populations
#' from multidimensional SNP frequency data. PLoS Genetics: 10, e1000695.
#'
#' @examples
#' data(genomalicious_4pops)
#' datGt <- copy(genomalicious_4pops)
#'
#' # Subset data for example (10 loci) and create artificial Ref and Alt
#' # nucleotides for the purpose of illustration
#' loci10 <- unique(datGt$LOCUS)[1:10]
#' datGt <- datGt[LOCUS %in% loci10]
#' ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(ref10) <- loci10
#'
#' alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(alt10) <- loci10
#'
#' datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
#' datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
#'
#'
#'
dat_input_genos <- function(dat
, sampCol='SAMPLE'
, popCol='POP'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, genoCol='GT'
, popSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
return(
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
)
# .......... END
}
dat_input_genos(dat=datGt, popSub=c('Pop1', 'Pop2'))
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
