alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
# Write (append) lines to txt file.
# First open the file
# Next append the number of loci and number of pops
# Then iterate through each j-th population in BS.ls and write data to file
file.create(file.bayescan)
for(i in c(num.loci,'',num.pops,'')){ write(i,file=file.bayescan,append=T) }
for(j in 1:length(names(BS.ls))){
write(paste0('[pop]=',j),file=file.bayescan,append=T)
write.table(BS.ls[[j]][,-'LOCUS'],file=file.bayescan,append=T,col.names=F,row.names=F)
write('',file=file.bayescan,append=T)
}
# Create a file of marker/locus order
fwrite(x=BS.ls[[1]][,c('MARKER','LOCUS')], file=file.loci, sep='\t')
# ........... END
}
data(genomaliciousPi)
data(genomaliciousInfo)
Bayescan_inputs(genomaliciousPi, genomaliciousInfo, 'Bayescan_input.txt', 'Bayescan_loci.txt')
bayescan_inputs(genomaliciousPi, genomaliciousInfo, 'Bayescan_input.txt', 'Bayescan_loci.txt')
dat <- genomaliciousPi
popCol='POOL'
locusCol='LOCUS'
freqCol='PI'
# --------------------------------------------+
# Code
# --------------------------------------------+
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
dat$POOL
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename population, locus, and frequency columns
setnames(dat, c(popCol, locusCol, freqCol), c('POOL', 'LOCUS', 'PI'))
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','PI')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
dat.spl
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $PI,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$PI*genomes)
alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
BS.ls
#' Generate \code{bayescan} input files
#'
#' Generates an input file for Bayescan from pooled allele frequencies. \cr
#' \cr
#' It assumes that these pooled allele frequencies have been estimated from Gautier et al. (2013)'s
#' \code{poolne_estim}, and have been imported into \code{R} with \code{genomalicious}.
#'
#' @param dat Data.table: The biallelic SNP data. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{POOL} = The population pool ID. \cr
#'                \item \code{LOCUS} = The locus ID. \cr
#'                \item \code{PI} = The population Ref allele frequency. \cr
#'              }
#'
#' @param pool.info Data table: The population pool metadata. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{$POOL} = The population pool ID. \cr
#'                \item \code{$INDS} = The number of diploid individuals in each pooled library.
#'              }
#'
#' @param file.bayescan Character: The name of the input file for \code{bayescan}/
#'
#' @param file.loci Character: A file that contains an information about the locus ID in
#' the \code{bayescan} input file (i.e., \code{file.bayescan}).
#'
#' @details The allele counts in the Bayescan input file generated reflect the number of haploid
#' genomes pooled. E.g. if 20 individuals were pooled, i.e. 40 genomes, and the Ref allele was
#' estimated at a frequency of, the counts would be Ref=28 and Alt=12.
#'
#' @examples
#' data(genomaliciousPi)
#' data(genomaliciousInfo)
#'
#' bayescan_inputs_pool(dat=genomaliciousPi
#'                      , pool.info=genomaliciousInfo
#'                      , file.bayescan='Bayescan_input.txt'
#'                      , file.loci='Bayescan_loci.txt'
#'                      , popCol='POOL', locusCol='LOCUS', freqCol='PI')
#'
#' @export
bayescan_inputs_pool <- function(dat, pool.info, file.bayescan, file.loci, popCol, locusCol, freqCol) {
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table')){ require(lib, character.only=TRUE) }
# Check class of dat.
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check class of pool.info.
if(!'data.table' %in% class(pool.info)){ stop("Argument pool.info isn't a data table") }
# Test for the necessary columns in dat.
if(sum(c(popCol, locusCol, freqCol) %in% colnames(dat))!= 3){
stop("Argument dat needs the columns specified by the arguments: popCol, locusCol, freqCol")
}
# Test for the necessary columns in pool.info.
if(sum(c('POOL', 'INDS') %in% colnames(pool.info))!=2){
stop("Argument pool.info needs the columns $POOL and $INDS.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename population, locus, and frequency columns
setnames(dat, c(popCol, locusCol, freqCol), c('POOL', 'LOCUS', 'PI'))
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','PI')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $PI,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$PI*genomes)
alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
# Write (append) lines to txt file.
# First open the file
# Next append the number of loci and number of pops
# Then iterate through each j-th population in BS.ls and write data to file
file.create(file.bayescan)
for(i in c(num.loci,'',num.pops,'')){ write(i,file=file.bayescan,append=T) }
for(j in 1:length(names(BS.ls))){
write(paste0('[pop]=',j),file=file.bayescan,append=T)
write.table(BS.ls[[j]][,-'LOCUS'],file=file.bayescan,append=T,col.names=F,row.names=F)
write('',file=file.bayescan,append=T)
}
# Create a file of marker/locus order
fwrite(x=BS.ls[[1]][,c('MARKER','LOCUS')], file=file.loci, sep='\t')
# ........... END
}
bayescan_inputs_pool(dat=genomaliciousPi
, pool.info=genomaliciousInfo
, file.bayescan='Bayescan_input.txt'
, file.loci='Bayescan_loci.txt'
, popCol='POOL', locusCol='LOCUS', freqCol='PI')
?bayescan_inputs_pool
document()
library(genomalicious)
?bayescan_inputs
library(genomalicious)
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
getwd()
getwd()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
?document
roxygenise(clean=TRUE)
devtools::install_github("gustavdelius/roxygen")
devtools::document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygen2::roxygenise()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages("roxygen2")
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
devtools::install_github("gustavdelius/roxygen")
document()
library(genomalicious)
bayescan_inputs_pool
?bayescan_inputs_pool
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
devtools::install_github("klutometis/roxygen")
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
\
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
devtools::document()
roxygenize()
roxygenise()
document()
update_imports()
file.access()
file.access('.')
?file.access
file.access('.',2)
file.access('./',2)
file.access('../',2)
file.access('../genomalicious/',2)
file.access('../genomalicious/man/',2)
file.access('../genomalicious/',2)
file.access('../genomalicious/',4)
file.access('../genomalicious/',1)
file.access('../genomalicious/',0)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
sessionInfo()
document()
roxygenise(clean=TRUE)
roxygenise(clean=TRUE)
?file
traceback()
document()
traceback()
devtools::install_github("hadley/devtools")
devtools
devtools::install_github("hadley/devtools")
installed.packages('git2r')
install.packages('git2r')
installed.packages(devtools)
install.packages('devtools')
install.packages('roxygen2')
install.packages('testthat')
install.packages('knitr')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
?document()
file.access
file.access('R/*.R')
file.access('R/*.R', 2)
?file.access
file.access('R/*.R', 4)
file.access('R/bayescan_inputs_pool.R', 4)
file.access('R/bayescan_inputs_pool.R', 2)
file.access('R/', 2)
roxygen2::roxygenise(clean = TRUE)
remove.packages('roxygen2')
'roxygen2'
library(git2r)
library(devtools)
devtools::install_github("gustavdelius/roxygen")
<<<<<<< HEAD
lociA <- c(1, 2, 3, 4, 5)
lociB <- c(5, 6, 7, 8, 9)
intersect(selA, selB)
lociB <- c(5, 6, 7, 8, 9)
lociA <- c(1, 2, 3, 4, 5)
lociB <- c(5, 6, 7, 8, 9)
selA <- c(5, 1)
selB <- 5
intersect(selA, selB)
shareObs <- length(intersect(selA, selB))
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
randB
shareNull <- length(intersect(randA, randB))
shareNull
replicate(100, length(intersect(randA, randB)))
shareNull <- as.integer()
for(i in 1:iters){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
shareNull <- c(shareNull, length(intersect(randA, randB)))
}
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- as.integer()
for(i in 1:iters){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
shareNull <- c(shareNull, length(intersect(randA, randB)))
}
lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
hist(shareNull)
shareNull > shareObs
sum(shareNull > shareObs)
lociA <- 1:100
lociB <- 50:150
selA <- c(5, 1)
selB <- 5
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
shareNull <- unlist(shareNull)
hist(shareNull)
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
randA
randB
lociA <- 1:100
lociB <- 1:100
selA <- c(5, 1)
selB <- 5
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
hist(shareNull)
sum(shareNull > shareObs)
sum(shareNull >= shareObs)
sum(shareNull >= shareObs)/iters
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages("roxygen2")
devtools::install_github("hadley/devtools")
install.packages('devtools')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages('backports')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
roxygenise('./', clean = TRUE)
=======
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
session_info()
remove.packages('roxygen2')
remove.packages(lib='roxygen2')
remove.packages(pkgs='roxygen2')
library(roxygen2)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
devtools::install_github('gustavdelius/roxygen')
install.packages('digest')
install.packages("digest")
devtools::install_github('gustavdelius/roxygen')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
document()
traceback()
View(document)
roxygenize()
roxygenise()
remove.packages('roxygen2')
>>>>>>> 533ac4a23eec8afb651bf694cf85b496a8b70f93
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
doucment()
roxygenise()
roxygenise('./', clean=TRUE)
roxygenise('../genomalicious/', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
#' Convert a data table of allele frequencies into a matrix (or vice versa)
#'
#' Takes a data table of allele frequencies in long format and converts it into
#' a matrix in wide format (loci in columns and populations in rows). The reverse
#' can also be done.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of allele frequencies, then three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{lociCol}).
#'    \item (3) The Ref allele frequency (see param \code{freqCol}).
#' }
#' The population pool column serves as the pivot point to convert the long data table into a wide matrix.
#' If convertin from a frequency matrix to a data table, see argument \code{flip}.
#'
#' @param popCol Character: The column name with the population information.
#'
#' @param lociCol Character: The column name with the locus information.
#'
#' @param freqCol Character: The column name with the Ref allele frequency.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{lociCol}, and \code{freqCol} become void.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', lociCol='LOCUS', freqCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, flip=TRUE)
#'
#' @export
DT2Mat_freqs <- function(dat, popCol=NA, lociCol=NA, freqCol=NA, flip=FALSE){
# BEGIN ............
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is frequency matrix, but has no population IDs in the row names.")
}
# If providing a data table, check that popCol, lociCol, and freqCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(popCol, lociCol, freqCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, lociCol, or freqCol.")
}
}
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(freqCol)){
stop("Argument freqCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
freqDT <- spread(dat[, c(popCol, freqCol, lociCol), with=FALSE], key=lociCol, value=freqCol)
freqMat <- as.matrix(freqDT[, !popCol, with=FALSE])
rownames(freqMat) <- freqDT[[popCol]]
return(freqMat)
} else if(flip==TRUE){
freqDT <- data.table(dat, keep.rownames=TRUE)
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- 'POP'
locusNames <- colnames(freqDT)[which(colnames(freqDT)!='POP')]
freqDT <- melt(freqDT, id.vars='POP', variable='LOCUS', value='FREQ')
return(freqDT)
}
}
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
