#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
#' Perform the Patterson et al. (2006) normalisation to a genotype matrix
#' @param dat Matrix: Counts of Ref allele. E.g. the C(i,j) table described
#' in Patterson et al. (2006).
#'
#' @return Returns a matrix with the same deminsions as \code{dat}, but with
#' genotypes normalised
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @export
normalise_patterson <- function(dat){
# Iterate over each j locus, normalise genotypes
M <- apply(dat, 2, function(j){
# Locus j correction factor
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
# The normalised genotypes
corrected_genos <- j - u
drift_effect <- sqrt(p * (1-p))
return(corrected_genos/drift_effect)
})
return(M)
}
pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
pca
pca_scatter(pca)
#' Create a scatter plot of a PCA on genotypes
#'
#' Plots the results of a PCA. Can accept an object of class \code{prcomp},
#' but can also take wide-format tabular data. Points can be coloured by
#' population.
#'
#' @param dat Prcomp/Data table/Data frame/Matrix: Contains the PCA scores for
#' each individual. If not using a \code{prcomp} object, the tabular data must
#' be wide-format: rows are indivdiuals, columns are PC axes. See also
#' \code{pca_DTinds()} to perform PCA on SNP genotypes.
#'
#' @param axisIndex Integer: Vector of lenght = 2. Corresponds to the column
#' index to plots, i.e. the PC axes. Default = \code{c(1,2)}, the first and second
#' PC axis column tabulated in \code{dat}.
#'
#' @param pops Character
#'
#' @export
pca_scatter <- function(dat, axisIndex=c(1,2), pops=NULL, popCols=NULL
, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(class(dat)!='prcomp' & !class(dat)[1]%in%c('data.table','data.frame','matrix')){
stop('Argument dat must be one of the following object classes:
prcomp, data.table, data.frame, or matrix')
}
# Check that axisIndex is only length == 2
if(length(axisIndex2)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that type is scatter or eigen.
if(!type%in%c('scatter', 'eigen')){
stop("Argument scatter is not one of: 'scatter' or 'eigen'.")
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
return(gg)
}
pca_scatter(pca)
#' Create a scatter plot of a PCA on genotypes
#'
#' Plots the results of a PCA. Can accept an object of class \code{prcomp},
#' but can also take wide-format tabular data. Points can be coloured by
#' population.
#'
#' @param dat Prcomp/Data table/Data frame/Matrix: Contains the PCA scores for
#' each individual. If not using a \code{prcomp} object, the tabular data must
#' be wide-format: rows are indivdiuals, columns are PC axes. See also
#' \code{pca_DTinds()} to perform PCA on SNP genotypes.
#'
#' @param axisIndex Integer: Vector of lenght = 2. Corresponds to the column
#' index to plots, i.e. the PC axes. Default = \code{c(1,2)}, the first and second
#' PC axis column tabulated in \code{dat}.
#'
#' @param pops Character
#'
#' @export
pca_scatter <- function(dat, axisIndex=c(1,2), pops=NULL, popCols=NULL
, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(class(dat)!='prcomp' & !class(dat)[1]%in%c('data.table','data.frame','matrix')){
stop('Argument dat must be one of the following object classes:
prcomp, data.table, data.frame, or matrix')
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that type is scatter or eigen.
if(!type%in%c('scatter', 'eigen')){
stop("Argument scatter is not one of: 'scatter' or 'eigen'.")
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
return(gg)
}
pca_scatter(pca)
#' Create a scatter plot of a PCA on genotypes
#'
#' Plots the results of a PCA. Can accept an object of class \code{prcomp},
#' but can also take wide-format tabular data. Points can be coloured by
#' population.
#'
#' @param dat Prcomp/Data table/Data frame/Matrix: Contains the PCA scores for
#' each individual. If not using a \code{prcomp} object, the tabular data must
#' be wide-format: rows are indivdiuals, columns are PC axes. See also
#' \code{pca_DTinds()} to perform PCA on SNP genotypes.
#'
#' @param axisIndex Integer: Vector of lenght = 2. Corresponds to the column
#' index to plots, i.e. the PC axes. Default = \code{c(1,2)}, the first and second
#' PC axis column tabulated in \code{dat}.
#'
#' @param pops Character: A vector of population ID, should match the
#' rows in \code{dat}, but is an optional argument. Default = \code{NULL}.
#' If \code{dat} is a \code{prcomp} object, function will search for \code{dat$pops}
#' to assign to this argument.
#'
#' @param popCols Character: A vector of colours to use for each unique population
#' in \code{pops}, but is an optional argument. Default = \code{NULL}.
#' The name of each colour must correspond to a population in \code{pops}.
#'
#' @param look Character: The look of the plot. Default = \code{'ggplot'}, the
#' typical gray background with gridlines produced by \code{ggplot2}. Alternatively,
#' when set to \code{'classic'}, produces a base R style plot.
#'
#' @export
pca_scatter <- function(dat, axisIndex=c(1,2), pops=NULL, popCols=NULL
, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(class(dat)!='prcomp' & !class(dat)[1]%in%c('data.table','data.frame','matrix')){
stop('Argument dat must be one of the following object classes:
prcomp, data.table, data.frame, or matrix')
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popCols are all in pops.
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
# Plot and return
plot(gg)
return(gg)
}
gg
data(genomalicious4pops)
pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
pca_scatter(pca)
#' Create a scatter plot of a PCA on genotypes
#'
#' Plots the results of a PCA. Can accept an object of class \code{prcomp},
#' but can also take wide-format tabular data. Points can be coloured by
#' population.
#'
#' @param dat Prcomp/Data table/Data frame/Matrix: Contains the PCA scores for
#' each individual. If not using a \code{prcomp} object, the tabular data must
#' be wide-format: rows are indivdiuals, columns are PC axes. See also
#' \code{pca_DTinds()} to perform PCA on SNP genotypes.
#'
#' @param axisIndex Integer: Vector of lenght = 2. Corresponds to the column
#' index to plots, i.e. the PC axes. Default = \code{c(1,2)}, the first and second
#' PC axis column tabulated in \code{dat}.
#'
#' @param pops Character: A vector of population ID, should match the
#' rows in \code{dat}, but is an optional argument. Default = \code{NULL}.
#' If \code{dat} is a \code{prcomp} object, function will search for \code{dat$pops}
#' to assign to this argument.
#'
#' @param popCols Character: A vector of colours to use for each unique population
#' in \code{pops}, but is an optional argument. Default = \code{NULL}.
#' The name of each colour must correspond to a population in \code{pops}.
#'
#' @param look Character: The look of the plot. Default = \code{'ggplot'}, the
#' typical gray background with gridlines produced by \code{ggplot2}. Alternatively,
#' when set to \code{'classic'}, produces a base R style plot.
#'
#' @return Produces the PCA scatter plot, and also returns a gg object.
#'
#' @examples
#' # Data
#' data(genomalicious4pops)
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_scatter(pca)
#' @export
pca_scatter <- function(dat, axisIndex=c(1,2), pops=NULL, popCols=NULL
, look='ggplot'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the dat is the correct data class
if(class(dat)!='prcomp' & !class(dat)[1]%in%c('data.table','data.frame','matrix')){
stop('Argument dat must be one of the following object classes:
prcomp, data.table, data.frame, or matrix')
}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popCols are all in pops.
if(is.null(pops)==FALSE & is.null(popCols)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
# Plot and return
plot(gg)
return(gg)
}
pca_scatter(pca)
gg <- pca_scatter(pca)
class(gg)
, popCols=c(Pop1='red', Pop2='blue', Pop3='lavendar', Pop4='black'))
c(Pop1='red', Pop2='blue', Pop3='lavendar', Pop4='black')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='red', Pop2='blue', Pop3='lavendar', Pop4='black')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='red', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='black', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='darkgray', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='darkgray8', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
' pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum1')
, look='classic')
pca_scatter(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popCols=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
