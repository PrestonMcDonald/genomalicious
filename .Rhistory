ss <- sum(ni * (pi - p.mean)^2)
return((1/(length(pi)-1)) * ss)
})
mspLocus
ni * pi * (1-pi)
sum(ni * pi * (1-pi))
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
(1/(length(pi)-1))
(1/(length(pi)-1)) * ssp
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
varg <- sum(ni * pi * (1-pi))
msp <- (1/(length(pi)-1)) * ssp
msp
(1/sum(ni-1))
sum(ni-1)
(1/sum(ni-1)) * varg
msp <- (1/(length(pi)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
msp
msg
ni - (sum(ni^2)/sum(ni))
sum(ni)
(sum(ni^2)/sum(ni))
sum(ni) - (sum(ni^2)/sum(ni))
(1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
data.table(LOCUS=locus, MSP=msp, MSG=msg, NC=nc)
lociVarcomps <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus, MSP=msp, MSG=msg, NC=nc))
})
lociVarcomps <- do.call('rbind', lociVarcomps)
lociVarcomps
require(data.table)
lociV
lociVarcomps
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg)
lociVarcomps <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVarcomps <- do.call('rbind', lociVarcomps)
lociVarcomps
rm(lociVarcomps)
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVars <- do.call('rbind', lociVar)
lociVars
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
rm(lociVars)
sum(lociVar$NUMER) / sum(lociVar$DENOM)
lociVar <- do.call('rbind', lociVar)
sum(lociVar$NUMER) / sum(lociVar$DENOM)
thetaAv <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
rm(thetaA)
rm(thetaAv)
thetaLocus <- lociVar$NUMER / lociVar$DENOM
thetaLocus
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
thetaLocus
freqMat
# Calculate variance per locus
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(numPops-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(numPops-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVar <- do.call('rbind', lociVar)
lociVar
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
thetaMean
thetaLocus
#' Calculate the variance components of Weir & Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampleMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
fstWC_varcomps <- function(freqMat, sampleMat){
lociNames <- colnames(freqMat)
numPops <- nrow(freqMat)
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVar <- do.call('rbind', lociVar)
return(lociVar)
}
lociVar <- fstWC_varcomps(freqMat, sampleMat)
lociVar
sum(lociVar$NUMER) / sum(lociVar$DENOM)
lociVar$NUMER / lociVar$DENOM
mean(lociVar$NUMER / lociVar$DENOM)
rownames(freqMat)
combn(x=rownames(freqMat), m=2)
pairCombos <- combn(x=rownames(freqMat), m=2)
X <- pairCombos[,1]
X
freqMat[X,]
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
lociVar
sum(lociVar$NUMER) / sum(lociVar$DENOM)
lociVar$NUMER / lociVar$DENOM
data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# For the Xth pair
apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
lapply(pairLs, function(X){ X$mean})
do.call('rbind', lapply(pairLs, function(X){ X$mean}))
do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
do.call('rbind', lapply(pairLs, function(X){ X$mean}))
do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
list(fst.mean=thetaMean, fst.locus=thetaLocus)
list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
)
list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
)
freqMat %in% sampMat)
rownames(freqMat) %in% sampMat
freqMat
rownames(freqMat)
matrix(rep(30, 32), nrow=4, ncol=8, row.names=paste0('Pop', 1:4))
rownames(sampMat) <- paste0('Pop', 1:4)
sampMat
sum(rownames(freqMat) %in% sampMat)!=nrow(sampMat)
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
c(class(freqMat), class(sampMat))
c(class(freqMat), class(sampMat))=='matrix'
#' Calculate the variance components of Weir & Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
fstWC_varcomps <- function(freqMat, sampleMat){
lociNames <- colnames(freqMat)
numPops <- nrow(freqMat)
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVar <- do.call('rbind', lociVar)
return(lociVar)
}
#' Calculate Weir and Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param pairs Logical: Should pairwise FSTwc be calculated (TRUE) or the
#' among population FSTwc (FALSE)?
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \n
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' freqMat <- genomaliciousFreqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC(freqMat, sampMat)
#'
#' @export
fstWC <- function(freqMat, sampMat, pairs=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# --------------------------------------------+
# Code
# --------------------------------------------+
if(pairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat, sampleMat)
# Theta across loci
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Theta per locus
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
# Return
return(list(fst.mean=thetaMean, fst.locus=thetaLocus))
} else if(pairs==TRUE){
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
# Return
return(list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
))
}
}
fstWC(freqMat, sampMat, pairs=TRUE)
fstWC(freqMat, sampMat, pairs=FALSE)
#' Calculate Weir and Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param pairs Logical: Should pairwise FSTwc be calculated (TRUE) or the
#' among population FSTwc (FALSE)?
#'
#' @return A list with two indices. \code{$fst.mean} contains the mean FST. In pairwise analyses,
#' this is a data table with population pairs. \code{$fst.locus} contains the locus-specific
#' FST values. If analysis was not pairwise, this is a vector, but for pairwise analyses,
#' this is a data table with population pairs.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \n
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' freqMat <- genomaliciousFreqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC(freqMat, sampMat, pairs=FALSE)
#' fstWC(freqMat, sampMat, pairs=TRUE)
#'
#' @export
fstWC <- function(freqMat, sampMat, pairs=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# --------------------------------------------+
# Code
# --------------------------------------------+
if(pairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat, sampleMat)
# Theta across loci
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Theta per locus
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
# Return
return(list(fst.mean=thetaMean, fst.locus=thetaLocus))
} else if(pairs==TRUE){
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
# Return
return(list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
))
}
}
fstWC(freqMat, sampMat, pairs=FALSE)
fstWC(freqMat, sampMat, pairs=TRUE)
roxygenise('./', clean=TRUE)
library(genomalicious)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.RData')
library(genomalicious)
?HierDpart
library(HierDpart)
?iDip
?iDIP
HierDpart::IDIP()
?HierDpart::IDIP()
str=Str(nreg=4,r=c(7,4,2,3),n=16)
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
IDIP(abu,str)
