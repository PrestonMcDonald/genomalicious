d1 <- rtw(5000, 1)
d2 <- rtw(5000, 2)
d4 <- rtw(5000, 4)
c1 <- density(d1)
c2 <- density(d2)
c4 <- density(d4)
plot(c1, col='red', ylim=c(0, 0.6))
lines(c2, col='black')
lines(c4, col='blue')
0.084 > d1
sum(0.084 > d1)/length(d1)
ptw(0.084, 1)
ptw(0.084, 1, lower.tail = FALSE)
sum(0.084 < d1)/length(d1)
ptw(0.084, 1, lower.tail = FALSE)
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Load currently installed genomalicious
library(genomalicious)
?adegenet_DT2genind
data(genomalicious_PoolPi)
dat <- genomalicious_PoolPi
poolCol='POOL'
locusCol='LOCUS'
refCol='REF'
altCol='ALT'
freqCol='PI'
indsCol='INDS'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(poolCol, locusCol, refCol, altCol, freqCol, indsCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS')
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
poolSub=NULL
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
dat
dat[, P*INDS]
round(1.9)
round(0.3)
round(0.5)
round(0.6)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
apply(dat, function(X){
ref.count <- X[['P']] * X[['INDS']]
})
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
apply(dat, 1, function(X){
ref.count <- X[['P']] * X[['INDS']]
return(ref.count)
})
dat[, c('P', 'INDS')]
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
apply(dat[, c('P', 'INDS')], 1, function(X){
ref.count <- X[['P']] * X[['INDS']]
return(ref.count)
})
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
return(ref.count)
})
round(1.2)
round(1.5)
round(0.5)
round(0.8)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat[, ALT.COUNT:=INDS-REF.COUNT]
dat
apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else if(p < 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else if(p < 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat
#' Genertate dadi input from pool-seq data
#'
#' Creates an input file for the program dadi, described in Gutenkunst et al. (2009).
#'
#' @param dat Data table: Must contain columns with the following information,
#' \enumerate{
#' \item Population pool ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Reference allele freuqency
#' \item Number of individuals per population pool
#'             }
#' @param poolCol Character: Population pool ID. Default = \code{'POOL'}
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}
#' @param refCol Character: Reference allele. Default = \code{'REF'}
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}
#' @param freqCol Character: The reference allele frequency. Default = \code{'FREQ'}.
#' @param indsCol Character: The number of individuals per population pool. Default = \code{'INDS'}.
#' @param poolSub Character: The pools to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data table in the dadi input format.
#'
#' @references Gutenkunst et al. (2009) Inferring the joint demographic history of multiply populations
#' from multidimensional SNP frequency data. PLoS Genetics: 10, e1000695.
#'
#' @examples
#' data(genomalicious_PoolPi)
#' genomalicious_PoolPi
#'
#' dadi_inputs_pools(dat=genomalicious_PoolPi
#'                   , poolCol='POOL'
#'                   , locusCol='LOCUS'
#'                   , refCol='REF'
#'                   , altCol='ALT'
#'                   , freqCol='PI'
#'                   , indsCol='INDS'
#'                   , poolSub=c('Pop1', 'Pop2'))
#'
#'
#' @export
dadi_inputs_pools <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(poolCol, locusCol, refCol, altCol, freqCol, indsCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS')
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(dat[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
match(c(poolCol, locusCol, freqCol), colnames(dat))
dat <- data(genomalicious_PoolPi)
pool.info <- data(genomalicious_PoolInfo)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
freqCol
dat
dat <- genomalicious_PoolPi
pool.info <- genomalicious_PoolInfo
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','P')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
dat.spl
X <- dat.spl
X <- dat.spl[[1]]
X
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$P*genomes)
alt <- genomes - ref
ref
alt
genomaes
genomaes
genomes
X$P*genomes
integer(0.4)
integer(0.5)
ref <- X$P*genomes
ref
X$P
genomes
ref <- p * genomes
pool <- X$POOL[1]
p <- X$P
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- p * genomes
ref
ref
ref <- p * genomes
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref. <- round(ref)
}
ref <- p * genomes
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref <- round(ref)
}
ref
lapply(ref, function(ref){
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref <- round(ref)
}
return(ref)
})
X
pool <- X$POOL[1]
p <- X$P
X$INDS <- pool.info[POOL==pool]$IND
apply(X, 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
apply(X, 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
X$INDS <- pool.info[POOL==pool]$IND
dat.spl
X <- dat.spl[[1]]
X
X$INDS <- pool.info[POOL==pool]$IND
apply(X, 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
apply(X[, x('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=INDS-REF.COUNT]
X
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $P,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=INDS-REF.COUNT]
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, INDS=X$INDS, ALLELES=2
, REF=X$REF.COUNT, ALT=X$ALT.COUNT)
return(BS.dt)
})
BS.ls
BS.ls[[1]][,c('MARKER','LOCUS')]
BS.ls[[j]][,-'LOCUS']
j <- 1
BS.ls[[j]][,-'LOCUS']
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
round(1.4)
round(1.5)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?adegenet_DT2genind
data(genomalicious_4pops)
genomalicious_4pops
DT2genind(genomalicious_4pops)
DT2genind(genomalicious_4pops, popCol='POP')
# Make documents
roxygenise('./', clean=TRUE)
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?genomalicious
library(genomalicious)
?genomalicious
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
genomalicious_Freqs
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?genomalicious_4pops
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
