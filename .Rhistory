# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
data(data_Genos)
DAPC.fit <- dapc_fit(dat=data_Genos, pcPreds=3, method='fit')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
library(genomalicious)
data(data_Genos)
### Fit the DAPC with the first 3 PC axes as predictors
DAPC.fit <- dapc_fit(dat=data_Genos, pcPreds=3, method='fit')
DAPC.fit$da.fit
DAPC.fit$da.fit$exp.var
library(genomalicious)
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
library(genomalicious)
data(data_Genos)
### Fit the DAPC with the first 3 PC axes as predictors
DAPC.fit <- dapc_fit(dat=data_Genos, pcPreds=3, method='fit')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
library(genomalicious)
data(data_Genos)
data(data_PoolFreqs)
data(data_PoolInfo)
dat <- data_Genos
type='pairs'
fstat=NULL
popCol='POP'
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
freqCol='FREQ'
indsCol='INDS'
global=TRUE
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
require(data.table); require(tidyverse)
# Make sure dat is a data.table
dat <- as.data.table(dat)
# Has type been specified correctly?
if(!type %in% c('genos','freqs')){
stop('Argument `type` must be one of "genos" or "freqs".')
}
combn(unique(dat$POP), 2)
combn(unique(dat$POP), 2) %>%
t(0)
combn(unique(dat$POP), 2) %>%
t()
combn(unique(dat$POP), 2) %>%
t() %>%
as.data.table() %>%
setnames(., new=c('POP1','POP2'))
pair.comp <- combn(unique(dat$POP), 2) %>%
t() %>%
as.data.table() %>%
setnames(., new=c('POP1','POP2'))
num.pairs <- nrow(pair.comp)
num.pairs
result <- list(genome=list(), locus=list(), permute=list(fstat=NULL, pval=NULL))
# START: Iterate over i pairs
for(i in 1:nrow(pair.comp)){
cat('Estimates for pair:', i, '/', num.pairs, '\n')
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
# Calculate genome-wide and locus-wise F-statistics
pair.calc <- dat[POP %in% c(pop1, pop2)] %>%
fstat_subfun(., type='genos', fstat=fstat) %>%
lapply(., function(D){
data.table(POP1=pop1, POP2=pop2, D)
})
# Add genome-wide values into main result
result$genome[[i]] <- pair.calc$genome
result$locus[[i]] <- pair.calc$locus
# If permuting
if(permute==TRUE){
# Perform the permutation
pair.perm <- fstat_permute(
dat[POP %in% c(pop1, pop2)],
fstat=fstat, numPerms=numPerms, numCores=numCores
) %>%
data.table(POP1=pop1, POP2=pop2, .)
# Get the p-value
pair.pval <- lapply(fstat, function(fx){
p <- sum(pair.perm[[fx]] > pair.calc$genome[[fx]]) / numPerms
data.table(STAT=fx, PVAL=p)
}) %>%
do.call('rbind', .) %>%
data.table(POP1=pop1, POP2=pop2, .)
# Add permutations into main results
result$permute$fstat[[i]] <- pair.perm
result$permute$pval[[i]] <- pair.pval
} else{
result$permute <- NULL
}
rm(i)
# END: Iterate over i pairs
}
library(genomalicious)
