X@snp.info <- lociDF
X@poolsizes <- pool.sizes[colnames(dpDF)]
X@poolnames <- pool.names[colnames(dpDF)]
return(list(Fst=computeFST(X, method=method, snp.index=snp.index), pooldat=X))
Fst=computeFST(X, method=method, snp.index=snp.index), pooldat=X)
computeFST(X)
method='Anova'
computeFST(X, method=method, snp.index=snp.index)
list(Fst=computeFST(X, method=method), pooldat=X)
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @return Returns a \code{pooldata} object as per the \code{poolfstat} package.
#' # Load in the pool metadata and reads
#' data(data_PoolInfo)
#' data(data_PoolReads)
#'
#' # Convert to pooldata object
#' pool <- poolfstat_DT2pooldata(data_PoolReads, data_PoolInfo)
poolfstat_DT2pooldata <- function(dat, pool.info){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
dat[, LOCUS:=paste(CHROM, POS, sep='_')]
dat$DP <- dat$AO + dat$RO
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
# Depth count as wide format data frame
dpDF <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Reference allele counts as wide format data frame
roDF <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Locus information
lociDF <- dat[, c('CHROM', 'POS', 'REF', 'ALT')] %>%
unique() %>%
.[, LOCUS:=paste(CHROM, POS, sep='_')] %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS') %>%
setnames(., new=c("Chromosome", "Position", "RefAllele", "AltAllele"))
# Sort so all data frames are ordered the same
roDF <- roDF[rownames(dpDF),]
lociDF <- lociDF[rownames(dpDF),]
# Pool sizes
pool.sizes <- pool.info$INDS*2
names(pool.sizes) <- pool.info$POOL
# Pool names
pool.names <- pool.info$POOL
names(pool.names) <- pool.info$POOL
# Compile pooldata object
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(lociDF)
X@refallele.readcount <- as.matrix(roDF)
X@readcoverage <- as.matrix(dpDF)
X@snp.info <- lociDF
X@poolsizes <- pool.sizes[colnames(dpDF)]
X@poolnames <- pool.names[colnames(dpDF)]
# Output
return(X)
}
# --------------------------------------------+
# Code
# --------------------------------------------+
X <- poolfstat_DT2pooldata(dat=dat, pool.info=pool.info)
data(data_PoolInfo)
data(data_PoolReads)
# Pool info
data_PoolInfo
# Replicate samples for each pool
data_PoolReads
# Subset to keep only Rep1 reads.
X <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
# Need to add pool ID: the ID used to match $POOL in data_PoolInfo
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @param method Character: Either 'Anova' (default) or 'Identity'. Passed to \code{method} argument
#' in \code{poolfstat::computeFST}.
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(data_PoolInfo)
#' data(data_PoolReads)
#'
#' # Pool info
#' data_PoolInfo
#'
#' # Replicate samples for each pool
#' data_PoolReads
#'
#' # Subset to keep only Rep1 reads.
#' X <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
#'
#' # Need to add pool ID: the ID used to match $POOL in data_PoolInfo
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' Y <- poolfstat_DT2Fst(X, data_PoolInfo)
#'
#' # Output is a list
#' class(Y)
#'
#' # Outout from poolfstat::computeFST
#' Y$Fst
#'
#' # The pooldata class object, generated from data table of pooled reads
#' class(Y$pooldat)
#' Y$pooldat
#'
#'@export
poolfstat_DT2Fst <- function(dat, pool.info, method='Anova'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
X <- poolfstat_DT2pooldata(dat=dat, pool.info=pool.info)
# Output
return(list(Fst=computeFST(X, method=method), pooldat=X))
rm(X)
}
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @return Returns a \code{pooldata} object as per the \code{poolfstat} package.
#' # Load in the pool metadata and reads
#' data(data_PoolInfo)
#' data(data_PoolReads)
#'
#' # Convert to pooldata object
#' pool <- poolfstat_DT2pooldata(data_PoolReads, data_PoolInfo)
poolfstat_DT2pooldata <- function(dat, pool.info){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
dat[, LOCUS:=paste(CHROM, POS, sep='_')]
dat$DP <- dat$AO + dat$RO
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
# Depth count as wide format data frame
dpDF <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Reference allele counts as wide format data frame
roDF <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Locus information
lociDF <- dat[, c('CHROM', 'POS', 'REF', 'ALT')] %>%
unique() %>%
.[, LOCUS:=paste(CHROM, POS, sep='_')] %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS') %>%
setnames(., new=c("Chromosome", "Position", "RefAllele", "AltAllele"))
# Sort so all data frames are ordered the same
roDF <- roDF[rownames(dpDF),]
lociDF <- lociDF[rownames(dpDF),]
# Pool sizes
pool.sizes <- pool.info$INDS*2
names(pool.sizes) <- pool.info$POOL
# Pool names
pool.names <- pool.info$POOL
names(pool.names) <- pool.info$POOL
# Compile pooldata object
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(lociDF)
X@refallele.readcount <- as.matrix(roDF)
X@readcoverage <- as.matrix(dpDF)
X@snp.info <- lociDF
X@poolsizes <- pool.sizes[colnames(dpDF)]
X@poolnames <- pool.names[colnames(dpDF)]
# Output
return(X)
}
X <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
# Need to add pool ID: the ID used to match $POOL in data_PoolInfo
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
# Calculate FST using poolfstat
Y <- poolfstat_DT2Fst(X, data_PoolInfo)
X <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
# Need to add pool ID: the ID used to match $POOL in data_PoolInfo
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
X
dat<-X
subReads$POOL <- unlist(lapply(strsplit(subReads$SAMPLE, '_'), function(X){ return(X[1]) }))
subReads <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
# Need to add pool ID: the ID used to match $POOL in data_PoolInfo
subReads$POOL <- unlist(lapply(strsplit(subReads$SAMPLE, '_'), function(X){ return(X[1]) }))
subReads
Y <- poolfstat_DT2Fst(subReads, data_PoolInfo)
dat <- subReads
pool.info <- data_PoolInfo
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 7){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @return Returns a \code{pooldata} object as per the \code{poolfstat} package.
#' # Load in the pool metadata and reads
#' data(data_PoolInfo)
#' data(data_PoolReads)
#'
#' # Convert to pooldata object
#' pool <- poolfstat_DT2pooldata(data_PoolReads, data_PoolInfo)
poolfstat_DT2pooldata <- function(dat, pool.info){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 7){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
dat[, LOCUS:=paste(CHROM, POS, sep='_')]
dat$DP <- dat$AO + dat$RO
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
# Depth count as wide format data frame
dpDF <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Reference allele counts as wide format data frame
roDF <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO) %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS')
# Locus information
lociDF <- dat[, c('CHROM', 'POS', 'REF', 'ALT')] %>%
unique() %>%
.[, LOCUS:=paste(CHROM, POS, sep='_')] %>%
as.data.frame() %>%
column_to_rownames(., 'LOCUS') %>%
setnames(., new=c("Chromosome", "Position", "RefAllele", "AltAllele"))
# Sort so all data frames are ordered the same
roDF <- roDF[rownames(dpDF),]
lociDF <- lociDF[rownames(dpDF),]
# Pool sizes
pool.sizes <- pool.info$INDS*2
names(pool.sizes) <- pool.info$POOL
# Pool names
pool.names <- pool.info$POOL
names(pool.names) <- pool.info$POOL
# Compile pooldata object
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(lociDF)
X@refallele.readcount <- as.matrix(roDF)
X@readcoverage <- as.matrix(dpDF)
X@snp.info <- lociDF
X@poolsizes <- pool.sizes[colnames(dpDF)]
X@poolnames <- pool.names[colnames(dpDF)]
# Output
return(X)
}
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @param method Character: Either 'Anova' (default) or 'Identity'. Passed to \code{method} argument
#' in \code{poolfstat::computeFST}.
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(data_PoolInfo)
#' data(data_PoolReads)
#'
#' # Pool info
#' data_PoolInfo
#'
#' # Replicate samples for each pool
#' data_PoolReads
#'
#' # Subset to keep only Rep1 reads.
#' subReads <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
#'
#' # Need to add pool ID: the ID used to match $POOL in data_PoolInfo
#' subReads$POOL <- unlist(lapply(strsplit(subReads$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' Y <- poolfstat_DT2Fst(subReads, data_PoolInfo)
#'
#' # Output is a list
#' class(Y)
#'
#' # Outout from poolfstat::computeFST
#' Y$Fst
#'
#' # The pooldata class object, generated from data table of pooled reads
#' class(Y$pooldat)
#' Y$pooldat
#'
#'@export
poolfstat_DT2Fst <- function(dat, pool.info, method='Anova'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 7){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
X <- poolfstat_DT2pooldata(dat=dat, pool.info=pool.info)
# Output
return(list(Fst=computeFST(X, method=method), pooldat=X))
rm(X)
}
subReads <- data_PoolReads[grep(pattern='Rep1', x=data_PoolReads$SAMPLE)]
# Need to add pool ID: the ID used to match $POOL in data_PoolInfo
subReads$POOL <- unlist(lapply(strsplit(subReads$SAMPLE, '_'), function(X){ return(X[1]) }))
Y <- poolfstat_DT2Fst(subReads, data_PoolInfo)
class(Y)
Y$Fst
class(Y$pooldat)
Y$pooldat
pooldataObj <-poolfstat_DT2pooldata(subReads, data_PoolInfo)
pooldataObj
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
