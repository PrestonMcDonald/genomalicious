dat
genomalicious_PoolPi
dat
data(genomalicious_4pops)
datgt <- copy(genomalicious_4pops)
datgt
rm(datgt)
datGt <- copy(genomalicious_4pops)
unique(datGt$GT)[1:10]
unique(datGt$LOCUS)[1:10]
datGt <- datGt[LOCUS %in% unique(datGt$LOCUS)[1:10]]
datGt
sample(c('G', 'A', 'T', 'C'), nrow(datGt))
sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
datGt$REF <- sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
datGt$ALT <- sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
dat <- datGt
dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
dat[, sum(GT), by=c('LOCUS', 'REF', 'ALT', 'POP')]
dat[, sum(GT), by=c('LOCUS', 'POP')]
dat[, length(unique(SAMPLE)), by=POP]
dat[, sum(GT), by=c('LOCUS', 'POP')]
data(genomalicious_PoolPi)
genomalicious_PoolPi
dadi_inputs_pools(dat=genomalicious_PoolPi
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=c('Pop1', 'Pop2'))
a <- dat[, sum(GT), by=c('LOCUS', 'POP')]
a
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
r
r$V1 + a$V1
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- dat[, sum(GT), by=c('LOCUS', 'POP')]
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
r <- dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')]
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
r
a
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
dadi_inputs_pools(dat=genomalicious_PoolPi
, poolCol='POOL'
, locusCol='LOCUS'
, altCol='ALT'
, freqCol='PI'
, refCol='REF'
, indsCol='INDS'
, poolSub=c('Pop1', 'Pop2'))
r
spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
a
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
datGt
datGt -> dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')]
?allele_counts
dat[, allele_counts, by=c('POP', 'LOCUS')]
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
dat <- datGt
dat
acount <- genoscore_converter(dat$GT)
paste(acount, dat$GT)
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
datGt
unique(datGt$LOCUS)[1:10]
loci10 <- unique(datGt$LOCUS)[1:10]
loci10
sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
?sample
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
ref10
alt10
match(datGt$LOCUS, names(ref10))
ref10[match(datGt$LOCUS, names(ref10))]
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
data(genomalicious_4pops)
datGt <- copy(genomalicious_4pops)
# Subset data for example (10 loci) and create artificial Ref and Alt
# nucleotides for the purpose of illustration
loci10 <- unique(datGt$LOCUS)[1:10]
datGt <- datGt[LOCUS %in% loci10]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
dat <- datGt
dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
r
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
r
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
a
r
a$Pop1 + r$Pop1
a$Pop2 + r$Pop2
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
#' Genertate dadi input from individual genotype data
#'
#' Creates an input file for the program dadi, described in Gutenkunst et al. (2009).
#'
#' @param dat Data table: Contains population and genotype information. Genotypes
#' must be coded as '/' separated characters (e.g. '0/0', '0/1', or '1/1') or
#' integers of Alt allele counts (e.g. 0, 1, 2). Must contain the following columns:
#' \enumerate{
#' \item Sample ID (see argument \code{sampCol})
#' \item Population ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Genotyp
#' }
#'
#' @param sampCol Character: Sample ID. Default = \code{'SAMPLE'}.
#' @param popCol Character: Population pool ID. Default = \code{'POP'}.
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}.
#' @param refCol Character: Reference allele. Default = \code{'REF'}.
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}.
#' @param genoCol Character: The genotype. Default = \code{'GT'}.
#' @param popSub Character: The populations to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data table in the dadi input format.
#'
#' @references Gutenkunst et al. (2009) Inferring the joint demographic history of multiply populations
#' from multidimensional SNP frequency data. PLoS Genetics: 10, e1000695.
#'
#' @examples
#' data(genomalicious_4pops)
#' datGt <- copy(genomalicious_4pops)
#'
#' # Subset data for example (10 loci) and create artificial Ref and Alt
#' # nucleotides for the purpose of illustration
#' loci10 <- unique(datGt$LOCUS)[1:10]
#' datGt <- datGt[LOCUS %in% loci10]
#' ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(ref10) <- loci10
#'
#' alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(alt10) <- loci10
#'
#' datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
#' datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
#'
#'
#'
dat_input_genos <- function(dat
, sampCol='SAMPLE'
, popCol='POP'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, genoCol='GT'
, popSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
return(
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
)
# .......... END
}
dat_input_genos(dat=datGt, popSub=c('Pop1', 'Pop2'))
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
library(genomalicious)
dat <- genomalicious_4pops
x <- DT2Mat_genos(dat)
x <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
x
y[, 1:3]
x[, 1:3]
y <- DT2Mat_genos(x, 'SAMPLE', 'LOCUS', 'GT', flip=TRUE)
y
yy <- copy(y)
yy[, GT:=genoscore_converter]
yy[, GT:=genoscore_converter(GT)]
yy
paste(y$GT, yy$GT)
?DT2Mat_genos
?DT2Mat_genos
View(DT2Mat_genos())
View(DT2Mat_genos)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
getwd
getwd()
?roxygenise
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?DT2Mat_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
getwd()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
View(fstWC_genos)
?fstWC_genos
library(genomalicious)
?fstWC_genos
fstWC_genos
?fstWC_genos
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
?fstWC_genos
?fstWCgenos
library(genomalicious)
?fstWCgenos
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
fst_among <- fstWC_genos(genomalicious_4pops, permTest=TRUE
, bootCI=TRUE, iters=50)
fst_pairs <- fstWC_genos(genomalicious_4pops, doPairs=TRUE
, doDist=TRUE, perLocus=TRUE)
fst_pairs
fst_among
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
source('~/GitHub/genomalicious/R/fstWC_genos.R', echo=TRUE)
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
