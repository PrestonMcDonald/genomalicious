#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
library(genomalicious)
data("genomaliciousPi")
genomaliciousPi
>>>>>>> master
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
genomaliciousFreqs <- readRDS('inst/extdata/genomaliciousFreqs.RDS')
save(genomaliciousFreqs, file='data/genomaliciousFreqs.RData')
genomaliciousFreqsLong <- as.data.table(genomaliciousFreqs)
genomaliciousFreqsLong$POP <- rownames(genomaliciousFreqs)
genomaliciousFreqsLong <- melt(genomaliciousFreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
save(genomaliciousFreqsLong, file='data/genomaliciousFreqsLong.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
roxygenise('./', clean=TRUE)
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
snpDat <- genomalicious4pops
data(genomalicious4pops)
snpDat <- genomalicious4pops
snpDat
genomalicious_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
genomalicious_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
genomalicious_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(genomalicious_PoolInfo, file='data/genomalicious_PoolInfo.RData')
genomalicious_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(genomalicious_PoolInfo, file='data/genomalicious_PoolInfo.RData')
genomalicious_PoolReads <- fread('inst/extdata/genomaliciousReads.csv')
genomalicious_PoolReads <- fread('inst/extdata/genomalicious_PoolReads.csv')
genomalicious_PoolReads <- fread('inst/extdata/genomalicious_PoolReads.csv')
save(genomalicious_PoolReads, file='data/genomalicious_PoolReads.RData')
refalt <- unique(genomalicious_PoolReads[, c('LOCUS', 'REF', 'ALT')])
genomaliciousPi <- fread('inst/extdata/genomalicious_PoolPi.csv')
genomalicious_PoolPi <- fread('inst/extdata/genomalicious_PoolPi.csv')
genomalicious_PoolPi <- fread('inst/extdata/genomalicious_PoolPi.csv')
genomalicious_PoolPi <- cbind(genomalicious_PoolPi, refalt[match(genomalicious_PoolPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomalicious_PoolInfo$INDS[match(genomalicious_PoolPi$POOL, genomalicious_PoolInfo$POOL)]
)
save(genomalicious_PoolPi, file='data/genomalicious_PoolPi.RData')
genomalicious_Freqs <- readRDS('inst/extdata/genomalicious_Freqs.RDS')
genomalicious_Freqs <- readRDS('inst/extdata/genomalicious_Freqs.RDS')
save(genomalicious_Freqs, file='data/genomalicious_Freqs.RData')
genomalicious_FreqsLong <- as.data.table(genomalicious_Freqs)
genomalicious_FreqsLong$POP <- rownames(genomalicious_Freqs)
genomalicious_FreqsLong <- melt(genomalicious_FreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
genomalicious_FreqsLong <- melt(genomalicious_FreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
genomalicious_FreqsLong <- as.data.table(genomalicious_Freqs)
genomalicious_FreqsLong$POP <- rownames(genomalicious_Freqs)
genomalicious_FreqsLong <- melt(genomalicious_FreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
save(genomalicious_FreqsLong, file='data/genomalicious_FreqsLong.RData')
genomalicious_4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
library(genomalicious)
setnames(genomalicious_4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious_4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious_4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious_4pops, file='data/genomalicious_4pops.RData')
roxygenise('./', clean=TRUE)
library(genomalicious)
struMat <- matrix(c(rep('metapop', 4), paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
data(genomalicious_4pops)
snpDat <- genomalicious_4pops
snpDat
?allele_counts
uniqPops <- unique(snpDat$POP)
uniqLoci <- unique(snpDat$LOCUS)
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))
popCol='POP'
genoCol='GT'
locusCol='LOCUS'
sampCol='SAMPLE'
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
uniqPops <- unique(snpDat$POP)
uniqLoci <- unique(snpDat$LOCUS)
lapply(uniqLoci, function(locus){
lapply(uniqPop, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
})
uniqPops <- unique(snpDat$POP)
uniqLoci <- unique(snpDat$LOCUS)
lapply(uniqLoci, function(locus){
lapply(uniqPop, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
})
lapply(uniqLoci, function(locus){
lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
})
locus <- uniqLoci[1]
uniqPops -> pops[1]
uniqPops[1] -> pops
pops
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
uniqPops[1] -> pop
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
do.call('rbind', als)
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
do.call('rbind', als)
row.names(als) <- uniqPop
row.names(als) <- uniqPops
rownames(als) <- uniqPops
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
als
lociAls <- lapply(uniqLoci, function(locus){
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
})
lociAls <- lapply(uniqLoci, function(locus){
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
return(als)
})
lociAls
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
IDIP(abun=als, struc=strucMat)
snpDat <- genomalicious_4pops
struMat <- matrix(c(rep('metapop', 4), paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
IDIP(abun=als, struc=strucMat)
strucMat <- matrix(c(rep('metapop', 4), paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
IDIP(abun=als, struc=strucMat)
str=Str(nreg=4,r=c(7,4,2,3),n=16)
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
IDIP(abu,str)
str
abu
t(als)
IDIP(abun=t(as.matrix(als)), struc=strucMat)
strucMat <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
IDIP(abun=t(as.matrix(als)), struc=strucMat)
lociAls <- sapply(uniqLoci, function(locus){
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociAls
lociAls[, 1:4]
lociAls <- lapply(uniqLoci, function(locus){
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- lapply(uniqLoci, function(locus){
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
do.call('cbind', lociDivpar)
do.call('cbind', lociDivpar)[, 1:4]
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
lociDivpar[, 1:4]
strucMat[nrow(strucMat),]
if(uniqPops %in% strucMat[nrow(strucMat),])
uniqPops %in% strucMat[nrow(strucMat),]
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
data(genomalicious_Freqs)
genomalicious_FreqsLong
freqDat <- genomalicious_FreqsLong
genomalicious_PoolPi
freqDat <- genomalicious_PoolPi
strucMat <- matrix(c(rep('metapop', 4)
freqCol='FREQ'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
# Stop if strucMat doesn't meet min rows
if(nrow(struMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
# Population check
uniqPops <- unique(snpDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Population check
uniqPops <- unique(freqDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in freqDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Rename columns
colnames(freqDat)[
which(colnames(freqDat)%in%c(popCol, locusCol, freqCol))] <- c(
'POP', 'LOCUS', 'GT')
freqDat
freqDat
freqCol <- 'PI'
# Rename columns
colnames(freqDat)[
which(colnames(freqDat)%in%c(popCol, locusCol, freqCol))] <- c(
'POP', 'LOCUS', 'FREQ')
freqDat
popCol <- 'POOL'
# Rename columns
colnames(freqDat)[
which(colnames(freqDat)%in%c(popCol, locusCol, freqCol))] <- c(
'POP', 'LOCUS', 'FREQ')
popCol
locusCol
freqCol
colnames(freqDat)
colnames(freqDat)%in%c(popCol, locusCol, freqCol))
which(colnames(freqDat)%in%c(popCol, locusCol, freqCol))
c(popCol, locusCol, freqCol)
colnames(freqDat)
popCol <- 'POP'
# Rename columns
colnames(freqDat)[
which(colnames(freqDat)%in%c(popCol, locusCol, freqCol))] <- c(
'POP', 'LOCUS', 'FREQ')
freqDat
freqDat <- genomalicious_PoolPi
# Rename columns
colnames(freqDat)[
match(c(popCol, locusCol, freqCol), colnames(freqDat))] <- c(
'POP', 'LOCUS', 'FREQ')
match(c(popCol, locusCol, freqCol), colnames(freqDat))
popCol
popCol <- 'POOL'
# Unique loci
uniqLoci <- unique(freqDat$LOCUS)
# Unique loci
uniqLoci <- unique(freqDat$LOCUS)
locus
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(freqDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
freqDat[LOCUS==locus & POP==pop]
match(c(popCol, locusCol, freqCol), colnames(freqDat))] <- c(
'POP', 'LOCUS', 'FREQ')
freqDat
# Rename columns
colnames(freqDat)[
match(c(popCol, locusCol, freqCol), colnames(freqDat))] <- c(
'POP', 'LOCUS', 'FREQ')
freqDat
freqDat[LOCUS==locus & POP==pop]
pop
locus
# Unique loci
uniqLoci <- unique(freqDat$LOCUS)
locus <- uniqLoci[1]
freqDat[LOCUS==locus & POP==pop]
freqDat[LOCUS==locus & c('POP', 'FREQ')]
freqDat[LOCUS==locus, c('POP', 'FREQ')]
spread(freqDat[LOCUS==locus, c('POP', 'FREQ')], key='POP')
?sread
?spread
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table', 'tidyr')){ require(libs, character.only=TRUE) }
spread(freqDat[LOCUS==locus, c('POP', 'FREQ')], key='POP', value='FREQ')
spread(freqDat[LOCUS==locus, c('POP', 'LOCUS', 'FREQ')], key='POP', value='FREQ')
, key='POP', value='FREQ')[, !'LOCUS']
spread(freqDat[LOCUS==locus, c('POP', 'LOCUS', 'FREQ')]
, key='POP', value='FREQ')[, !'LOCUS']
# For each locus, get Ref and Alt allele counts per population
freqs <- lapply(uniqPops, function(pop){
spread(freqDat[LOCUS==locus, c('POP', 'LOCUS', 'FREQ')]
, key='POP', value='FREQ')[, !'LOCUS']
})
freqs
sub <- freqDat[LOCUS==locus]
sub
sub[, ALT.FREQ=1-FREQ]
sub[, ALT.FREQ:=1-FREQ]
sub
spread(sub[, c('POP', 'FREQ', 'ALT.FREQ')], key='POP')
spread(sub[, c('POP', 'LOCUS', 'FREQ', 'ALT.FREQ')], key='POP')
sub[, c('POP', 'LOCUS', 'FREQ', 'ALT.FREQ')]
sub[, c('POP', 'LOCUS', 'FREQ', 'ALT.FREQ')]
t(sub[, c('POP', 'LOCUS', 'FREQ', 'ALT.FREQ')])
spread(sub[, c('POP', 'LOCUS', 'FREQ')], key='POP')
spread(sub[, c('POP', 'LOCUS', 'FREQ')], key='POP')
spread(sub[, c('POP', 'LOCUS', 'FREQ')], key='POP', value='FREQ')
sub <- spread(sub[, c('POP', 'LOCUS', 'FREQ')], key='POP', value='FREQ')
sub
, key='POP', value='FREQ')[, !'LOCUS']
sub <- freqDat[LOCUS==locus]
sub[, ALT.FREQ:=1-FREQ]
sub <- spread(sub[, c('POP', 'LOCUS', 'FREQ')]
, key='POP', value='FREQ')[, !'LOCUS']
sub
sub <- rbind(1-sub[1,])
sub
sub <- freqDat[LOCUS==locus]
sub[, ALT.FREQ:=1-FREQ]
sub <- spread(sub[, c('POP', 'LOCUS', 'FREQ')]
, key='POP', value='FREQ')[, !'LOCUS']
sub <- rbind(sub, 1-sub[1,])
sub
apply(sub, 2, sum)
as.matrix(als)
as.matrix(sub)
# Run IDIP
idip <- IDIP(abun=as.matrix(sub), struc=strucMat)
idip
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
sub <- freqDat[LOCUS==locus]
sub[, ALT.FREQ:=1-FREQ]
sub <- spread(sub[, c('POP', 'LOCUS', 'FREQ')]
, key='POP', value='FREQ')[, !'LOCUS']
sub <- rbind(sub, 1-sub[1,])
# Run IDIP
idip <- IDIP(abun=as.matrix(sub), struc=strucMat)
return(idip)
})
lociDivpar
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
lociDivpar
roxygenise('./', clean=TRUE)
library(genomalicious)
roxygenise('./', clean=TRUE)
