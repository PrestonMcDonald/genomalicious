# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
return(lociDivpar)
}
snpDat <- genomalicious_4pops[c(1:4, 70:74),]
snpDat
snpDat$LOCUS <- 'loc1'
snpDat$GT[c(2,3,4)] <- c('2/2', '2/3', '3/4')
snpDat
strucMat <- matrix(c(rep('metapop', 4)
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
strucMat <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
idip_DTgenos(snpDat=snpDat, strucMat=struMat)
idip_DTgenos(snpDat=snpDat, strucMat=strucMat)
strucMat <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
idip_DTgenos(snpDat=snpDat, strucMat=strucMat)
# Stop if strucMat doesn't meet min rows
if(nrow(strucMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
#' Calculate diversity statistics with \code{IDIP} from a data table of genotypes
#'
#' @param snpDat Data table: a long-format data table with SNP genotypes
#' coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The genotype (see param \code{genoCol}).
#' }
#'
#' @param strucMat Matrix: Hierarchy of "aggregates", minimum of 2 rows and
#' as many columns as the lowest units of the hierarchy. 1st row is the top most
#' level (e.g. ecosystem or metapopulation), with lower levels in proceding rows.
#'
#' @param popCol Character: The column name with the population information, i.e.
#' the lowest levels of the population hierarchy (last row of \code{strucMat}).
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @return A matrix with columns representing loci, rows are the statistics
#' from the \code{IDIP} analysis.
#'
#' @examples
#' data(genomalicious_4pops)
#' snpDat <- genomalicious_4pops[c(1:4, 70:74),]
#' snpDat$LOCUS <- 'loc1'
#' snpDat$GT[c(2,3,4)] <- c('2/2', '2/3', '3/4')
#' strucMat <- matrix(c(rep('metapop', 4)
#'                , paste('Group', c(1,1,2,2))
#'                , paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#'
#'
#' idip_DTgenos(snpDat=snpDat, strucMat=strucMat)
#' @export
idip_DTgenos <- function(snpDat, strucMat, popCol='POP'
, locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
# Stop if strucMat doesn't meet min rows
if(nrow(strucMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
# Population check
uniqPops <- unique(snpDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
return(lociDivpar)
}
idip_DTgenos(snpDat=snpDat, strucMat=strucMat)
popCol='POP'
genoCol='GT'
locusCol='LOCUS'
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
snpDat
snpDat <- genomalicious_4pops[c(1:4, 70:74),]
snpDat$LOCUS <- 'loc1'
snpDat$POP[5:9] <- 'Pop2'
snpDat$GT[c(2,3,4)] <- c('2/2', '2/3', '3/4')
strucMat <- matrix(c(rep('metapop', 2)
, paste('Group', c(1,2))
, paste('Pop', 1:2, sep='')), ncol=2, byrow=TRUE)
idip_DTgenos(snpDat=snpDat, strucMat=strucMat)
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
pop <- 'pop1'
locus='loc1'
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
snpDat[LOCUS==locus & POP==pop]
snpDat
pop<-'Pop1'
snpDat[LOCUS==locus & POP==pop]
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. Doesn't have to be biallelic (see param \code{biallelic}).
#' If the class is \code{'integer'}, then assumes counts of
#' Ref alleles, in which case, it does assumes biallelic.
#'
#' @param biallelic Logical: Is the data biallelic? If alleles separated
#' by '/' (character vector), expect \code{dat} to take form: '0/0', '0/1', or '1/1'.
#' If alleles coded as counts of Ref allele, expect \code{dat} to take form:
#' 0, 1, or 2. Default =\code{TRUE}.
#'
#' @return A vector of alleles counts.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c('1/1', '2/3', '1/3', '0/0', '2/2'), biallelic=FALSE)
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat, biallelic=TRUE){
# --------------------------------------------+
# Libraries and assertins
# --------------------------------------------+
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
if(length(uniqAls)==2 & sum(c('1', '0') %in% uniqAls)==1 & biallelic==FALSE){
warning('Argument biallelic==FALSE, but argument dat looks biallelic.')
}
if(class(dat)=='integer' & biallelic==FALSE){
stop('Argument dat is an integer, and argument biallelic==FALSE.
Cannot count alleles in dat if there are >2 alleles.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Sample size
n <- length(dat)*2
# If given a character vector:
if(class(dat)=='character'){
# Get the alleles
als <- unlist(strsplit(dat, split='/'))
# Get unique allelles
uniqAls <- unique(als)
# If data is biallelic
if(biallelic==TRUE){
ref <- sum(genoscore_converter(dat))
alt <- n - ref
return(c(ref=ref, alt=alt))
# Else, if >2 alleles
} else{
tab <- table(als)
vec <- as.vector(tab)
names(vec) <- names(tab)
return(vec)
}
# If given counts of bialleles
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
return(c(ref=ref, alt=alt))
}
}
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. Doesn't have to be biallelic (see param \code{biallelic}).
#' If the class is \code{'integer'}, then assumes counts of
#' Ref alleles, in which case, it does assumes biallelic.
#'
#' @param biallelic Logical: Is the data biallelic? If alleles separated
#' by '/' (character vector), expect \code{dat} to take form: '0/0', '0/1', or '1/1'.
#' If alleles coded as counts of Ref allele, expect \code{dat} to take form:
#' 0, 1, or 2. Default =\code{TRUE}.
#'
#' @return A vector of alleles counts.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c('1/1', '2/3', '1/3', '0/0', '2/2'), biallelic=FALSE)
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat, biallelic=TRUE){
# --------------------------------------------+
# Libraries and assertins
# --------------------------------------------+
# Get the alleles
als <- unlist(strsplit(dat, split='/'))
# Get unique allelles
uniqAls <- unique(als)
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
if(length(uniqAls)==2 & sum(c('1', '0') %in% uniqAls)==1 & biallelic==FALSE){
warning('Argument biallelic==FALSE, but argument dat looks biallelic.')
}
if(length(uniqAls)>2){ biallelic <- FALSE }
if(class(dat)=='integer' & biallelic==FALSE){
stop('Argument dat is an integer, and argument biallelic==FALSE.
Cannot count alleles in dat if there are >2 alleles.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Sample size
n <- length(dat)*2
# If given a character vector:
if(class(dat)=='character'){
# If data is biallelic
if(biallelic==TRUE){
ref <- sum(genoscore_converter(dat))
alt <- n - ref
return(c(ref=ref, alt=alt))
# Else, if >2 alleles
} else{
tab <- table(als)
vec <- as.vector(tab)
names(vec) <- names(tab)
return(vec)
}
# If given counts of bialleles
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
return(c(ref=ref, alt=alt))
}
}
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
als <- do.call('rbind', als)
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
als <- list(allele_counts(snpDat[LOCUS==locus & POP==pop]$GT), c('1'=6, '0'=5))
als
uniqAls <- unlist(unique(als))
uniqAls
unlist(als)
names(unlist(als))
uniqAls <- unique(names(unlist(als)))
uniqAls
lapply(als, function(pop){
pop[uniqueAls]
})
lapply(als, function(pop){
pop[uniqAls]
})
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
})
x <- pop[uniqAls]
names(x) <- uniqAls
x
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
# is.na(x) <- 0
})
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
return(x)
})
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
x
pop <- als[[2]]
pop
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
x
x
is.na(x)
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
als
als <- do.call('rbind', als)
rownames(als) <- uniqPops
data(genomalicious_4pops)
snpDat <- genomalicious_4pops
strucMat <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
# Population check
uniqPops <- unique(snpDat$POP)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
lociDivpar[,1:4]
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=strucMat
, popCol='POP', locusCol='LOCUS', genoCol='GT')
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=strucMat
, popCol='POP', locusCol='LOCUS', genoCol='GT')
metapop <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#' Calculate diversity statistics with \code{IDIP} from a data table of genotypes
#'
#' @param snpDat Data table: a long-format data table with SNP genotypes
#' coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The genotype (see param \code{genoCol}).
#' }
#'
#' @param strucMat Matrix: Hierarchy of "aggregates", minimum of 2 rows and
#' as many columns as the lowest units of the hierarchy. 1st row is the top most
#' level (e.g. ecosystem or metapopulation), with lower levels in proceding rows.
#'
#' @param popCol Character: The column name with the population information, i.e.
#' the lowest levels of the population hierarchy (last row of \code{strucMat}).
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @return A matrix with columns representing loci, rows are the statistics
#' from the \code{IDIP} analysis.
#'
#' @examples
#' data(genomalicious_4pops)
#'
#' # Create a population hierarchy
#' metapop <- matrix(c(rep('metapop', 4)
#'                , paste('Group', c(1,1,2,2))
#'                , paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#'
#' # Run IDIP
#' idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
#'              , popCol='POP', locusCol='LOCUS', genoCol='GT')
#'
#' @export
idip_DTgenos <- function(snpDat, strucMat, popCol='POP'
, locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
# Stop if strucMat doesn't meet min rows
if(nrow(strucMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
# Population check
uniqPops <- unique(snpDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
# Correction in case some alleles are not recorded
# for all populations (mostly a problem for non-biallelic data).
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
# Combine into a matrx
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
return(lociDivpar)
}
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
