ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat[, ALT.COUNT:=INDS-REF.COUNT]
dat
apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else if(p < 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p > 0 & ref.count < 1){ ref.count <- 1
} else if(p < 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat
#' Genertate dadi input from pool-seq data
#'
#' Creates an input file for the program dadi, described in Gutenkunst et al. (2009).
#'
#' @param dat Data table: Must contain columns with the following information,
#' \enumerate{
#' \item Population pool ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Reference allele freuqency
#' \item Number of individuals per population pool
#'             }
#' @param poolCol Character: Population pool ID. Default = \code{'POOL'}
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}
#' @param refCol Character: Reference allele. Default = \code{'REF'}
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}
#' @param freqCol Character: The reference allele frequency. Default = \code{'FREQ'}.
#' @param indsCol Character: The number of individuals per population pool. Default = \code{'INDS'}.
#' @param poolSub Character: The pools to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data table in the dadi input format.
#'
#' @references Gutenkunst et al. (2009) Inferring the joint demographic history of multiply populations
#' from multidimensional SNP frequency data. PLoS Genetics: 10, e1000695.
#'
#' @examples
#' data(genomalicious_PoolPi)
#' genomalicious_PoolPi
#'
#' dadi_inputs_pools(dat=genomalicious_PoolPi
#'                   , poolCol='POOL'
#'                   , locusCol='LOCUS'
#'                   , refCol='REF'
#'                   , altCol='ALT'
#'                   , freqCol='PI'
#'                   , indsCol='INDS'
#'                   , poolSub=c('Pop1', 'Pop2'))
#'
#'
#' @export
dadi_inputs_pools <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(poolCol, locusCol, refCol, altCol, freqCol, indsCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS')
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('P', 'INDS')], 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(dat[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
match(c(poolCol, locusCol, freqCol), colnames(dat))
dat <- data(genomalicious_PoolPi)
pool.info <- data(genomalicious_PoolInfo)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
freqCol
dat
dat <- genomalicious_PoolPi
pool.info <- genomalicious_PoolInfo
# --------------------------------------------+
# Code
# --------------------------------------------+
# Reassign population, locus, and frequency columns
colReass <- match(c(poolCol, locusCol, freqCol), colnames(dat))
colnames(dat)[colReass] <- c('POOL', 'LOCUS', 'P')
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','P')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
dat.spl
X <- dat.spl
X <- dat.spl[[1]]
X
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$P*genomes)
alt <- genomes - ref
ref
alt
genomaes
genomaes
genomes
X$P*genomes
integer(0.4)
integer(0.5)
ref <- X$P*genomes
ref
X$P
genomes
ref <- p * genomes
pool <- X$POOL[1]
p <- X$P
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- p * genomes
ref
ref
ref <- p * genomes
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref. <- round(ref)
}
ref <- p * genomes
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref <- round(ref)
}
ref
lapply(ref, function(ref){
if(p != 0 & ref < 1){ ref <- 1
} else if(p != 1 & ref.count < 1){ ref <- 1
} else{ ref <- round(ref)
}
return(ref)
})
X
pool <- X$POOL[1]
p <- X$P
X$INDS <- pool.info[POOL==pool]$IND
apply(X, 1, function(X){
p <- X[['P']]
inds <- X[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
apply(X, 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
X$INDS <- pool.info[POOL==pool]$IND
dat.spl
X <- dat.spl[[1]]
X
X$INDS <- pool.info[POOL==pool]$IND
apply(X, 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
apply(X[, x('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=INDS-REF.COUNT]
X
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $P,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
X$INDS <- pool.info[POOL==pool]$IND
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * inds
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X[, ALT.COUNT:=INDS-REF.COUNT]
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, INDS=X$INDS, ALLELES=2
, REF=X$REF.COUNT, ALT=X$ALT.COUNT)
return(BS.dt)
})
BS.ls
BS.ls[[1]][,c('MARKER','LOCUS')]
BS.ls[[j]][,-'LOCUS']
j <- 1
BS.ls[[j]][,-'LOCUS']
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X$REF.COUNT <- apply(X[, c('P', 'INDS')], 1, function(Y){
p <- Y[['P']]
inds <- Y[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
X
round(1.4)
round(1.5)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?adegenet_DT2genind
data(genomalicious_4pops)
genomalicious_4pops
DT2genind(genomalicious_4pops)
DT2genind(genomalicious_4pops, popCol='POP')
# Make documents
roxygenise('./', clean=TRUE)
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?genomalicious
library(genomalicious)
?genomalicious
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
genomalicious_Freqs
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?genomalicious_4pops
?genomalicious_Freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
devtools::build_vignettes()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Make documents
roxygenise('./', clean=TRUE)
devtools::build_manual()
devtools::build_vignettes()
?build_vignettes()
getwd()
clean_vignettes()
devtools::check(manual=TRUE)
devtools::build_vignettes()
library(genomalicious)
pack <- "genomalicious"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
R CMD Rd2pdf 'genomalicious'
R CMD Rd2pdf genomalicious
R CMD Rd2pdf './'
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
?fastsimcoal2_snps2dips
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(devtools)
check(cleanup = FALSE,manual = TRUE,path = getwd())
# without running the examples
check(cleanup = FALSE,args = c('--no-examples'),manual = TRUE,path = getwd())
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
source('~/GitHub/genomalicious/DEV.R', echo=TRUE)
# Make documents
roxygenise('./', clean=TRUE)
# Make documents
roxygenise('./', clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
# Load currently installed genomalicious
library(genomalicious)
library(genomalicious)
?fastsimcoal2_snps2dips
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
# Load currently installed gen
library(genomalicious)
?fastsimcoal2_snps2dips
dat <- freqs
data("genomalicious_Freqs")
dat <- genomalicious_Freqs
dat
# Turn matrix into data table, keep row names
freqDT <- data.table(dat, keep.rownames=TRUE)
library(data.table)
# Turn matrix into data table, keep row names
freqDT <- data.table(dat, keep.rownames=TRUE)
freqDT
popCol <- 'POP'
# The row names are turned into a column 'rn', replace.
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- popCol
freqDT
locusCol<- 'LOCUS'
freqCol <- 'R.FREQ'
# Rejig the data table
freqDT <- melt(freqDT, id.vars=popCol, variable=locusCol, value=freqCol)
freqDT
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
library(genomalicious)
library(genomalicious)
library(genomalicious)
is.integer()
library(genomalicious)
library(genomalicious)
library(genomalicious)
library(genomalicious)
