dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
dat <- datGt
dat
acount <- genoscore_converter(dat$GT)
paste(acount, dat$GT)
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
datGt
unique(datGt$LOCUS)[1:10]
loci10 <- unique(datGt$LOCUS)[1:10]
loci10
sample(c('G', 'A', 'T', 'C'), nrow(datGt), replace=TRUE)
sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
?sample
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
ref10
alt10
match(datGt$LOCUS, names(ref10))
ref10[match(datGt$LOCUS, names(ref10))]
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
data(genomalicious_4pops)
datGt <- copy(genomalicious_4pops)
# Subset data for example (10 loci) and create artificial Ref and Alt
# nucleotides for the purpose of illustration
loci10 <- unique(datGt$LOCUS)[1:10]
datGt <- datGt[LOCUS %in% loci10]
ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(ref10) <- loci10
alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
names(alt10) <- loci10
datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
dat <- datGt
dat
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
dat
dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
r
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
r
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
a
r
a$Pop1 + r$Pop1
a$Pop2 + r$Pop2
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
#' Genertate dadi input from individual genotype data
#'
#' Creates an input file for the program dadi, described in Gutenkunst et al. (2009).
#'
#' @param dat Data table: Contains population and genotype information. Genotypes
#' must be coded as '/' separated characters (e.g. '0/0', '0/1', or '1/1') or
#' integers of Alt allele counts (e.g. 0, 1, 2). Must contain the following columns:
#' \enumerate{
#' \item Sample ID (see argument \code{sampCol})
#' \item Population ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Genotyp
#' }
#'
#' @param sampCol Character: Sample ID. Default = \code{'SAMPLE'}.
#' @param popCol Character: Population pool ID. Default = \code{'POP'}.
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}.
#' @param refCol Character: Reference allele. Default = \code{'REF'}.
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}.
#' @param genoCol Character: The genotype. Default = \code{'GT'}.
#' @param popSub Character: The populations to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data table in the dadi input format.
#'
#' @references Gutenkunst et al. (2009) Inferring the joint demographic history of multiply populations
#' from multidimensional SNP frequency data. PLoS Genetics: 10, e1000695.
#'
#' @examples
#' data(genomalicious_4pops)
#' datGt <- copy(genomalicious_4pops)
#'
#' # Subset data for example (10 loci) and create artificial Ref and Alt
#' # nucleotides for the purpose of illustration
#' loci10 <- unique(datGt$LOCUS)[1:10]
#' datGt <- datGt[LOCUS %in% loci10]
#' ref10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(ref10) <- loci10
#'
#' alt10 <- sample(c('G', 'A', 'T', 'C'), 10, replace=TRUE)
#' names(alt10) <- loci10
#'
#' datGt$REF <- ref10[match(datGt$LOCUS, names(ref10))]
#' datGt$ALT <- alt10[match(datGt$LOCUS, names(alt10))]
#'
#'
#'
dat_input_genos <- function(dat
, sampCol='SAMPLE'
, popCol='POP'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, genoCol='GT'
, popSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
# Sub out the pools if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
return(
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
)
# .......... END
}
dat_input_genos(dat=datGt, popSub=c('Pop1', 'Pop2'))
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
library(genomalicious)
dat <- genomalicious_4pops
x <- DT2Mat_genos(dat)
x <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
x
y[, 1:3]
x[, 1:3]
y <- DT2Mat_genos(x, 'SAMPLE', 'LOCUS', 'GT', flip=TRUE)
y
yy <- copy(y)
yy[, GT:=genoscore_converter]
yy[, GT:=genoscore_converter(GT)]
yy
paste(y$GT, yy$GT)
?DT2Mat_genos
?DT2Mat_genos
View(DT2Mat_genos())
View(DT2Mat_genos)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
getwd
getwd()
?roxygenise
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?DT2Mat_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
getwd()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
View(fstWC_genos)
?fstWC_genos
library(genomalicious)
?fstWC_genos
fstWC_genos
?fstWC_genos
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
?fstWC_genos
?fstWCgenos
library(genomalicious)
?fstWCgenos
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
fst_among <- fstWC_genos(genomalicious_4pops, permTest=TRUE
, bootCI=TRUE, iters=50)
fst_pairs <- fstWC_genos(genomalicious_4pops, doPairs=TRUE
, doDist=TRUE, perLocus=TRUE)
fst_pairs
fst_among
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
source('~/GitHub/genomalicious/R/fstWC_genos.R', echo=TRUE)
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
#'                 , bootCI=TRUE, iters=50)
#'
#' # Pairwise FST, with per locus estimates
#' # and a distance matrix
#' fst_pairs <- fstWC_genos(genomalicious_4pops
#'                 , doPairs=TRUE
#'                 , doDist=TRUE
#'                 , perLocus=TRUE)
#'
#' @export
fstWC_genos <- function(dat, popCol='POP', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT'
, permTest=FALSE, bootCI=FALSE, iters=100
, doPairs=FALSE, doDist=FALSE, perLocus=FALSE){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that all columns are specified correctly
if(sum(c(popCol, sampCol, locusCol, genoCol) %in% colnames(dat)) != 4){
stop('Arguments popCol, sampCol, locusCol, and genoCol must be
columns in dat. See ?genos2freqs.')
}
# Rename columns
colnames(dat)[
match(c(sampCol, popCol, locusCol, genoCol), colnames(dat))
] <- c('SAMPLE', 'POP', 'LOCUS', 'GT')
# Get genotype class
genoClass <- class(dat$GT)
# Convert to integer
if(genoClass=='character'){
dat[, GT:=genoscore_converter(GT)]
} else if(genoClass=='numeric'){
dat[, GT:=as.integer(GT)]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Frequency matrix
freqMat <- genos2freqs(dat, popCol='POP', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', returnMat=TRUE)
# Sample size matrix
sampMat <- as.matrix(spread(dat[, length(SAMPLE), by=c('POP', 'LOCUS')]
, key=LOCUS, value=V1)
, rownames='POP')
# If pairwise FST is not desired:
if(doPairs==FALSE){
# START NORMAL
# The observed FST
fst_obs <- fstWC_freqs(freqMat=freqMat, sampMat=sampMat[, colnames(freqMat)]
, perLocus=perLocus)
if(permTest==TRUE){
fst_perm <- fstWC_permgenos(dat, popCol='POP', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', perms=iters)
# p-value for permutations
fst_obs$fst.perm.pval <- sum(fst_perm > fst_obs$fst.mean) / iters
}
if(bootCI==TRUE){
fst_boot <- fstWC_boot(freqMat, sampMat, boots=iters)
# Percentiles
fst_obs$fst.boot.ci <- quantile(fst_boot, c(0.025, 0.975))
}
return(fst_obs)
# END NORMAL
}
# If pairwise FST is desired
if(doPairs==TRUE){
# START PAIRWISE
fst_obs <- fstWC_freqs(freqMat=freqMat, sampMat=sampMat
, doPairs=TRUE, doDist=doDist, perLocus=perLocus)
# If either permutaton testing is desired:
if(permTest==TRUE){
fst_obs$fst.mean$PVAL <- 0
# Iterate through each ith population pair
for(i in 1:nrow(fst_obs$fst.mean)){
pop_pair <- unlist(fst_obs$fst.mean[i, c('POP1', 'POP2')])
perm_pair <- fstWC_permgenos(dat=dat[POP %in% pop_pair]
, popCol='POP', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', perms=iters)
fst_obs$fst.mean$PVAL[i] <- sum(perm_pair > fst_obs$fst.mean$FST[i]) / iters
rm(pop_pair, perm_pair, i)
}
}
# If bootstrap confidence intervals are desired:
if(bootCI==TRUE){
fst_obs$fst.mean$CI.025 <- 0
fst_obs$fst.mean$CI.975 <- 0
# Iterate through each ith population pair
for(i in 1:nrow(fst_obs$fst.mean)){
pop_pair <- unlist(fst_obs$fst.mean[i, c('POP1', 'POP2')])
boot_pair <- fstWC_boot(freqMat[pop_pair,], sampMat[pop_pair,], boots=iters)
# Percentiles
boot_perc <- quantile(boot_pair, c(0.025, 0.975))
fst_obs$fst.mean$CI.025[i] <- boot_perc['2.5%']
fst_obs$fst.mean$CI.975[i] <- boot_perc['97.5%']
rm(pop_pair, boot_pair, i)
}
}
return(fst_obs)
# END PAIRWISE
}
# ............ END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
library(genomalicious)
?fstWC_genos
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
?fstWC_genos
library(genomalicious)
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
fst_among <- fstWC_genos(genomalicious_4pops
, permTest=TRUE
, bootCI=TRUE, iters=50)
library(genomalicious)
fst_among
fst_pairs <- fstWC_genos(genomalicious_4pops
, doPairs=TRUE
, doDist=TRUE
, perLocus=TRUE)
fst_pairs
