# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Add the $FORMAT data into the data table
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
# Split the $FORMAT column, rotate, rename columns, and bind.
formatCols <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
formatDat <- as.data.table(t(vcfDT[, strsplit(DATA, ':')]))
colnames(formatDat) <- formatCols
vcfDT <- cbind(vcfDT, formatDat)
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Attach info as an attribute if, if specified.
if(keepInfo==TRUE){
attr(vcfDT, 'vcf_info') <- vcfInfo
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: Data table to VCF             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(flip==TRUE){
# Create a data table of variants (varDat) and samples (sampDat)
cat('(1/3) Collecting variant and sample information.')
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples, vcfValues$format), with=FALSE]
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
# Extract VCF comments
if(keepComments==TRUE){
# Comments stored in attributes
vcfComms <- attr(dat, 'vcf_comments')
# The comments to be out put
outComms <- lapply(vcfValues$format, function(f){
vcfComms[grep(pattern=paste0('##FORMAT=<ID=', f), x=vcfComms)]
})
outComms <- unlist(outComms)
if(is.null(outComms)==TRUE){
cat("NOTE: `keepComments==TRUE` but `attr(dat, 'vcf_comments')` is NULL.", sep='\n')
}
# If INFO is desired, add to comments
if(keepInfo==TRUE){
outComms <- c(vcfComms[grep(pattern='##INFO', x=vcfComms)], outComms)
}
} else{ outComms <- NULL }
# Create and organise the $FORMAT column in the sample data table
cat('(2/3) Organising into wide format matrix.')
sampDat$FORMAT <- paste(vcfValues$format, collapse=':')
sampDat$VALUES <- apply(sampDat[, vcfValues$format, with=FALSE], 1, function(i){
paste(i, collapse=':')
})
sampDat <- sampDat[, !vcfValues$format, with=FALSE]
sampDat <- spread(sampDat, 'SAMPLE', 'VALUES')
# Loci names for ordering rows
lociNames <- varDat$LOCUS
# Bind columns of variant and sample data
vcfDat <- cbind(varDat[, !'LOCUS'], sampDat[match(lociNames, sampDat$LOCUS),!'LOCUS'])
# Get thh VCF column heads
vcfCols <- colnames(vcfDat)
vcfCols[1] <- paste0('#', vcfCols[1])
vcfCols <- paste(vcfCols, collapse='\t')
# Write out: Comments and header, then data.
cat('(1/3) Writing the VCF file.')
writeLines(text=c(outComms, vcfCols), con=vcfFile)
fwrite(x=vcfDat, file=vcfFile, append=TRUE, sep='\t')
}
}
readVcf1 <- vcf2DT(vcfPath)
readVcf1
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'QUAL')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2
attr(readVcf2, 'vcf_comments')
attr(readVcf2, 'vcf_info')
readVcf2_copy <- readVcf2
attr(readVcf2_copy, 'vcf_comments')
readVcf2_copy <- readVcf2[, !'RO']
attr(readVcf2_copy, 'vcf_comments')
attr(readVcf2_copy, 'vcf_comments')
attr(readVcf2_copy, 'vcf_info')
readVcf2[, mean(RO), by=LOCUS] ->x
x
attr(x, 'vcf_comments')
col_locus <- 'LOCUS'
col_var <- c('REF', 'ALT')
col_form <- c('RO', 'AO')
col_samp <- 'SAMP'
vcfValList <- list(locusCol=col_loc
, variantCols=col_var
, formatCols=col_form
, sampCol=col_samp)
vcfValList <- list(locusCol=col_locus
, variantCols=col_var
, formatCols=col_form
, sampCol=col_samp)
vcfValList
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, dat=readVcf2
, flip=TRIE
, vcfValues=vcfValList)
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
vcfValList <- list(loci=col_locus
, variants=col_var
, format=col_form
, samples=col_samp)
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
col_locus <- 'LOCUS'
col_var <- c('REF', 'ALT')
col_form <- c('RO', 'AO')
col_samp <- 'SAMPLE'
vcfValList <- list(loci=col_locus
, variants=col_var
, format=col_form
, samples=col_samp)
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
#'
#' vcf2DT(vcfFile='dt2vcf_example.vcf'
#'     , keepComments=TRUE
#'     , keepInfo=TRUE
#'     , flip=TRUE
#'     , dat=readVcf2
#'     , vcfValues=vcfValList)
#'
#'
#' @export
vcf2DT <- function(vcfFile
, dropCols=NULL
, keepComments=FALSE
, keepInfo=FALSE
, flip=FALSE
, dat
, vcfValues=list(loci='LOCUS'
, variants=c('CHROM', 'POS', 'REF', 'ALT')
, format=c('DP', 'RO', 'AO')
, samples='SAMPLE'))
{
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: VCF to data table             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(flip==FALSE){
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- cbind(LOCUS=vcfDT[, paste(CHROM, POS, sep='_')], vcfDT)
# Get the locus info as a vector and drop from data table
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Add the $FORMAT data into the data table
cat('(4/4) Collecting and organising `FORMAT` data', sep='\n')
# Split the $FORMAT column, rotate, rename columns, and bind.
formatCols <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
formatDat <- as.data.table(t(vcfDT[, strsplit(DATA, ':')]))
colnames(formatDat) <- formatCols
vcfDT <- cbind(vcfDT, formatDat)
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Attach info as an attribute if, if specified.
if(keepInfo==TRUE){
attr(vcfDT, 'vcf_info') <- vcfInfo
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: Data table to VCF             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(flip==TRUE){
# Create a data table of variants (varDat) and samples (sampDat)
cat('(1/3) Collecting variant and sample information.', '\n')
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples, vcfValues$format), with=FALSE]
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
# Extract VCF comments
if(keepComments==TRUE){
# Comments stored in attributes
vcfComms <- attr(dat, 'vcf_comments')
# The comments to be out put
outComms <- lapply(vcfValues$format, function(f){
vcfComms[grep(pattern=paste0('##FORMAT=<ID=', f), x=vcfComms)]
})
outComms <- unlist(outComms)
if(is.null(outComms)==TRUE){
cat("NOTE: `keepComments==TRUE` but `attr(dat, 'vcf_comments')` is NULL.", sep='\n')
}
# If INFO is desired, add to comments
if(keepInfo==TRUE){
outComms <- c(vcfComms[grep(pattern='##INFO', x=vcfComms)], outComms)
}
} else{ outComms <- NULL }
# Create and organise the $FORMAT column in the sample data table
cat('(2/3) Organising into wide format matrix.', '\n')
sampDat$FORMAT <- paste(vcfValues$format, collapse=':')
sampDat$VALUES <- apply(sampDat[, vcfValues$format, with=FALSE], 1, function(i){
paste(i, collapse=':')
})
sampDat <- sampDat[, !vcfValues$format, with=FALSE]
sampDat <- spread(sampDat, 'SAMPLE', 'VALUES')
# Loci names for ordering rows
lociNames <- varDat$LOCUS
# Bind columns of variant and sample data
vcfDat <- cbind(varDat[, !'LOCUS'], sampDat[match(lociNames, sampDat$LOCUS),!'LOCUS'])
# Get thh VCF column heads
vcfCols <- colnames(vcfDat)
vcfCols[1] <- paste0('#', vcfCols[1])
vcfCols <- paste(vcfCols, collapse='\t')
# Write out: Comments and header, then data.
cat('(3/3) Writing the VCF file.', '\n')
writeLines(text=c(outComms, vcfCols), con=vcfFile)
fwrite(x=vcfDat, file=vcfFile, append=TRUE, sep='\t')
}
}
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, vcfValues=vcfValList)
, dat=readVcf2
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
readLines('dt2vcf_example.vcf')
vcfValList$format
vcfValues <- vcfValList
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples), with=FALSE]
dat <- readVcf2
dat
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples), with=FALSE]
varDat
sampDat
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples, vcfValues$format), with=FALSE]
sampDat
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
keepInfo <- TRUE; keepComments <- TRUE
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
varDat$INFO
# Extract VCF comments
if(keepComments==TRUE){
# Comments stored in attributes
vcfComms <- attr(dat, 'vcf_comments')
# The comments to be out put
outComms <- lapply(vcfValues$format, function(f){
vcfComms[grep(pattern=paste0('##FORMAT=<ID=', f), x=vcfComms)]
})
outComms <- unlist(outComms)
if(is.null(outComms)==TRUE){
cat("NOTE: `keepComments==TRUE` but `attr(dat, 'vcf_comments')` is NULL.", sep='\n')
}
# If INFO is desired, add to comments
if(keepInfo==TRUE){
outComms <- c(vcfComms[grep(pattern='##INFO', x=vcfComms)], outComms)
}
} else{ outComms <- NULL }
outComms
vcfValues
outComms
paste(vcfValues$format, collapse=':')
sampDat$FORMAT <- paste(vcfValues$format, collapse=':')
vcfValues$format
sampDat[, vcfValues$format, with=FALSE]
apply(sampDat[, vcfValues$format, with=FALSE], 1, function(i){
paste(i, collapse=':')})
sampDat$VALUES <- apply(sampDat[, vcfValues$format, with=FALSE], 1, function(i){
paste(i, collapse=':')})
sampDat[, !vcfValues$format, with=FALSE]
sampDat <- sampDat[, !vcfValues$format, with=FALSE]
sampDat
spread(sampDat, 'SAMPLE', 'VALUES')
<- sampDat[, !vcfValues$format, with=FALSE]
sampDat
sampDat <- sampDat[, !vcfValues$format, with=FALSE]
# Create a data table of variants (varDat) and samples (sampDat)
cat('(1/3) Collecting variant and sample information.', '\n')
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples, vcfValues$format), with=FALSE]
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
# Extract VCF comments
if(keepComments==TRUE){
# Comments stored in attributes
vcfComms <- attr(dat, 'vcf_comments')
# The comments to be out put
outComms <- lapply(vcfValues$format, function(f){
vcfComms[grep(pattern=paste0('##FORMAT=<ID=', f), x=vcfComms)]
})
outComms <- unlist(outComms)
if(is.null(outComms)==TRUE){
cat("NOTE: `keepComments==TRUE` but `attr(dat, 'vcf_comments')` is NULL.", sep='\n')
}
# If INFO is desired, add to comments
if(keepInfo==TRUE){
outComms <- c(vcfComms[grep(pattern='##INFO', x=vcfComms)], outComms)
}
} else{ outComms <- NULL }
# Create and organise the $FORMAT column in the sample data table
cat('(2/3) Organising into wide format matrix.', '\n')
sampDat$FORMAT <- paste(vcfValues$format, collapse=':')
sampDat$VALUES <- apply(sampDat[, vcfValues$format, with=FALSE], 1, function(i){
paste(i, collapse=':')})
sampDat <- sampDat[, !vcfValues$format, with=FALSE]
sampDat <- spread(sampDat, 'SAMPLE', 'VALUES')
sampDat
# Loci names for ordering rows
lociNames <- varDat$LOCUS
lociNames
# Bind columns of variant and sample data
vcfDat <- cbind(varDat[, !'LOCUS'], sampDat[match(lociNames, sampDat$LOCUS),!'LOCUS'])
vcfDat
colnames(vcfDat)
# Get thh VCF column heads
vcfCols <- colnames(vcfDat)
vcfCols[1] <- paste0('#', vcfCols[1])
vcfCols <- paste(vcfCols, collapse='\t')
vcfFile
vcfFile <- 'dt2vcf_example.vcf'
writeLines(text=c(outComms, vcfCols), con=vcfFile)
fwrite(x=vcfDat, file=vcfFile, append=TRUE, sep='\t')
vcfDat
vcfDat
apply(vcf2DT, 1, paste, collapse='\t')
apply(vcf2Dat, 1, paste, collapse='\t')
apply(vcfDat, 1, paste, collapse='\t')
c(outComms, vcfCols, apply(vcfDat, 1, paste, collapse='\t'))
writeLines(text=c(outComms, vcfCols, apply(vcfDat, 1, paste, collapse='\t')), con=vcfFile)
vcfFile
writeLines(text=c(outComms, vcfCols, apply(vcfDat, 1, paste, collapse='\t')), con=vcfFile)
writeLines(text=c(outComms, vcfCols), con=vcfFile)
fwrite(x=vcfDat, file=vcfFile, append=TRUE, sep='\t')
vcfDat
vcf2DT('dt2vcf_example.vcf', flip=FALSE)
col_locus <- 'LOCUS'
col_var <- c('CHROM', 'REF', 'ALT')
col_form <- c('RO', 'AO')
col_samp <- 'SAMPLE'
vcfValList <- list(loci=col_locus
, variants=col_var
, format=col_form
, samples=col_samp)
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
readLines('dt2vcf_example.vcf')
vcf2DT('dt2vcf_example.vcf', flip=FALSE)
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID', 'QUAL')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2
readVcf2 <- vcf2DT(vcfPath
, keepInfo=TRUE)
, dropCols=c('FILTER', QUAL')
, keepComments=TRUE
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2
attr(readVcf2, 'vcf_comments')
attr(readVcf2, 'vcf_info')
col_locus <- 'LOCUS'
col_var <- c('CHROM', 'POS', 'REF', 'ALT')
col_form <- c('RO', 'AO')
col_samp <- 'SAMPLE'
vcfValList <- list(loci=col_locus
, variants=col_var
, format=col_form
, samples=col_samp)
vcf2DT(vcfFile='dt2vcf_example.vcf'
, keepComments=TRUE
, keepInfo=TRUE
, flip=TRUE
, dat=readVcf2
, vcfValues=vcfValList)
readLines('dt2vcf_example.vcf')
vcf2DT('dt2vcf_example.vcf', flip=FALSE)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath)
readVcf1 <- vcf2DT(vcfPath)
readVcf1
vcf2DT('dt2vcf_example.vcf', flip=FALSE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise('./')
roxygenise()
# Make documents
roxygenise(, clean=TRUE) # Sometimes this throws an error?
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
?vcf2DT
library(genomalicious)
library(genomalicious)
?vcf2DT
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
?vcf2DT
library(genomalicious)
?vcf2DT
