#'    , keepComments=TRUE
#'    , keepInfo=TRUE)
#'
#' readVcf2
#'
#' attr(readVcf2, 'vcf_comments')
#' attr(readVcf2, 'vcf_info')
#'
#' # Convert a data table back to a VCF.
#' # Code shows how you can exlude columns from the VCF.
#' # Here, will drop the $QUAL and $DP columns.
#' col_locus <- 'LOCUS'
#' col_var <- c('CHROM', 'POS', 'REF', 'ALT')
#' col_form <- c('RO', 'AO')
#' col_samp <- 'SAMPLE'
#' vcfValList <- list(loci=col_locus
#'     , variants=col_var
#'     , format=col_form
#'     , samples=col_samp)
#'
#' vcf2DT(vcfFile='dt2vcf_example.vcf'
#'     , keepComments=TRUE
#'     , keepInfo=TRUE
#'     , flip=TRUE
#'     , dat=readVcf2
#'     , vcfValues=vcfValList)
#'
#' readLines('dt2vcf_example.vcf')
#'
#' vcf2DT('dt2vcf_example.vcf', flip=FALSE)
#'
#' @export
vcf2DT <- function(vcfFile
, dropCols=NULL
, keepComments=FALSE
, keepInfo=FALSE
, flip=FALSE
, dat
, vcfValues=list(loci='LOCUS'
, variants=c('CHROM', 'POS', 'REF', 'ALT')
, format=c('GT', 'DP', 'RO', 'AO')
, samples='SAMPLE'))
{
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: VCF to data table             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(flip==FALSE){
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- cbind(LOCUS=vcfDT[, paste(CHROM, POS, sep='_')], vcfDT)
# Get the locus info as a vector and drop from data table
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Add the $FORMAT data into the data table
cat('(4/4) Collecting and organising FORMAT data', sep='\n')
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
vcfDT <- cbind(vcfDT, as.data.table(formatDat))
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Attach info as an attribute if, if specified.
if(keepInfo==TRUE){
attr(vcfDT, 'vcf_info') <- vcfInfo
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
cat('All done! <3', '\n')
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: Data table to VCF             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(flip==TRUE){
# Check that all columns in vcfValues are in dat.
if(sum(unlist(vcfValues) %in% colnames(dat))!=length(unlist(vcfValues))){
stop('Not all columns specified in `vcfValues` match `colnames(dat)`: See ?vcf2DT.')
}
# Check that CHROM and POS are specified in vcfValues$variants,
# and put CHROM and POS first if they are not already.
if(sum(c('CHROM', 'POS') %in% vcfValues$variants)!=2){
stop("Argument `vcfValues$variants` must at minimum contain the values
'CHROM' and 'POS': See ?vcf2DT.")
} else{
chrompos <- match(c('CHROM', 'POS'), vcfValues$variants)
vcfValues$variants <- c(vcfValues$variants[chrompos]
, vcfValues$variants[-chrompos])
}
# Internal function
FUN_format_paste <- function(x){
x[is.na(x)] <- '.'
return(paste(trimws(x), collapse=':'))
}
# The unquie loci and samples
uniqLoci <- unique(dat[, c('CHROM', 'POS', 'LOCUS')])
setorder(uniqLoci, CHROM, POS)
uniqSamps <- sort(unique(dat$SAMPLE))
# Locus counter
countLoci <- round(quantile(1:nrow(uniqLoci), seq(0.05, 1, by=0.05)))
names(countLoci) <- sub('%', '', names(countLoci))
# Create a data table of variants (varDat).
cat('(1/4) Collecting the variant data.', '\n')
varDat <- unique(dat[,c(vcfValues$variants, vcfValues$loci), with=FALSE])
# Should INFO and comments be kept?
cat('(2/4) Collecting info and comments if specified.', '\n')
# Extract VCF INFO column
if(keepInfo==TRUE){
outInfo <- attr(dat, 'vcf_info')
if(is.null(outInfo)==TRUE){
cat("   NOTE: `keepInfo==TRUE` but `attr(dat, 'vcf_info')` is NULL.", sep='\n')
}
varDat$INFO <- outInfo[varDat$LOCUS]
} else{ outInfo <- NULL }
# Extract VCF comments
if(keepComments==TRUE){
# Comments stored in attributes
vcfComms <- attr(dat, 'vcf_comments')
# The comments to be out put
outComms <- lapply(vcfValues$format, function(f){
vcfComms[grep(pattern=paste0('##FORMAT=<ID=', f), x=vcfComms)]
})
outComms <- unlist(outComms)
if(is.null(outComms)==TRUE){
cat("NOTE: `keepComments==TRUE` but `attr(dat, 'vcf_comments')` is NULL.", sep='\n')
}
# If INFO is desired, add to comments
if(keepInfo==TRUE){
outComms <- c(vcfComms[grep(pattern='##INFO', x=vcfComms)], outComms)
}
} else{ outComms <- NULL }
# Create a data table of sample data (sampDat).
# Will iterate through loci and write lines on the fly.
cat('(3/4) Collecting the sample data.', '\n')
sampDat <- dat[, c(vcfValues$loci, vcfValues$samples, vcfValues$format), with=FALSE]
# Create the VCF
cat('(4/4) Writing the VCF.', '\n')
# Write info, comments, and column header.
vcfHead <- paste0('#', paste(c(vcfValues$variants, 'FORMAT', uniqSamps), collapse='\t'))
writeLines(c(outComms, vcfHead), vcfFile)
# Write the VCF lines for each ith locus.
cat('   % complete: ')
for(i in 1:length(uniqLoci)){
locus <- uniqLoci$LOCUS[i]
# Make count if at checkpoint
if(i %in% countLoci){ cat(names(countLoci[countLoci==i]), ' ') }
# Subset data based on locus: get desired format values
# and the sample names.
locDT <- sampDat[LOCUS==locus, c(vcfValues$format, vcfValues$samples), with=FALSE]
# Rotate into wide format such that samples are in columns,
loc_samp_vals <- as.data.table(t(locDT[, !vcfValues$samples, with=FALSE]))
# Iterate over all columns with .SDcols and apply
# FUN_formate_paste() to each, which combines all format
# values into a single string.
loc_samp_vals <- loc_samp_vals[, lapply(.SD, FUN_format_paste)
, .SDcols=colnames(loc_samp_vals)]
# Label columns based on samples
colnames(loc_samp_vals) <- locDT$SAMPLE
# Reorganise to keep sample name consistency
loc_samp_vals <- loc_samp_vals[, uniqSamps, with=FALSE]
# Write the new line to file.
vcfLine <- cbind(varDat[LOCUS==locus, !'LOCUS']
, FORMAT=paste(vcfValues$format, collapse=':')
, loc_samp_vals)
fwrite(x=vcfLine, file=vcfFile, append=TRUE, sep='\t')
}
cat('\n')
cat('All done! <3', '\n')
}
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
#' VCF file to data table
#'
#' Reads a VCF file and converts to a long format data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = \code{NULL}.
#' Only relevant when argument \code{flip==FALSE}.
#'
#' @param keepComments Logical: Should the VCF comments be kept?
#' Default = \code{FALSE}. See Details for parameterisation.
#'
#' @param keepInfo: Logical: Should the VCF info for each locus be kept?
#' Default = \code{FALSE}.
#'
#' @details Firstly, it should be noted that while data tables are a really
#' excellent way of handling genotype and sequence read information in R,
#' they are not necessarily the most efficient way to do so. Importing VCFs
#' as data table (or the reverse, exporting data tables as VCFs), can take
#' a considerable amount of time if the number of loci and samples are large.
#' However, a bit of patience is worth it! \cr
#'
#' @return A \code{data.table} object is returned with all the columns contained in
#' the original VCF file with some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value
#' as the $ID column. \cr\cr
#' When \code{keepInfo==TRUE} and/or \code{keepComments==TRUE}, these are returned
#' as attributes. E.g., if the returned object is \code{vcfDT}, then you can
#' access Info and Comments (respectively) with: \code{attr(vcfDT, 'vcf_info')}
#' and \code{attr(vcfDT, 'vcf_comments')}.
#'
#' @references This & Riginos (2019) genomalicious: serving up a smorgasbord of
#' R functions for population genomic analyses. BioRxiv.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data table
#' readVcf1 <- vcf2DT(vcfPath)
#' readVcf1
#'
#' # Read in VCF, but drop some columns,
#' # and keep comments and info.
#' readVcf2 <- vcf2DT(vcfPath
#'    , dropCols=c('FILTER', 'ID')
#'    , keepComments=TRUE
#'    , keepInfo=TRUE)
#'
#' readVcf2
#'
#' attr(readVcf2, 'vcf_comments')
#' attr(readVcf2, 'vcf_info')
#'
#' @export
vcf2DT <- function(vcfFile
, dropCols=NULL
, keepComments=FALSE
, keepInfo=FALSE
, flip=FALSE
, dat
, vcfValues=list(loci='LOCUS'
, variants=c('CHROM', 'POS', 'REF', 'ALT')
, format=c('GT', 'DP', 'RO', 'AO')
, samples='SAMPLE'))
{
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: VCF to data table             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- cbind(LOCUS=vcfDT[, paste(CHROM, POS, sep='_')], vcfDT)
# Get the locus info as a vector and drop from data table
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Add the $FORMAT data into the data table
cat('(4/4) Collecting and organising FORMAT data', sep='\n')
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
vcfDT <- cbind(vcfDT, as.data.table(formatDat))
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Attach info as an attribute if, if specified.
if(keepInfo==TRUE){
attr(vcfDT, 'vcf_info') <- vcfInfo
}
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
cat('All done! <3', '\n')
}
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath)
readVcf1 <- vcf2DT(vcfPath)
readVcf1
#' VCF file to data table
#'
#' Reads a VCF file and converts to a long format data table.
#'
#' @param vcfFile Character: The path to the input VCF file.
#'
#' @param dropCols Character: Vector of column names from the VCF that you
#' want to drop from the data table. Default = \code{NULL}.
#' Only relevant when argument \code{flip==FALSE}.
#'
#' @param keepComments Logical: Should the VCF comments be kept?
#' Default = \code{FALSE}. See Details for parameterisation.
#'
#' @param keepInfo: Logical: Should the VCF info for each locus be kept?
#' Default = \code{FALSE}.
#'
#' @details Firstly, it should be noted that while data tables are a really
#' excellent way of handling genotype and sequence read information in R,
#' they are not necessarily the most efficient way to do so. Importing VCFs
#' as data table (or the reverse, exporting data tables as VCFs), can take
#' a considerable amount of time if the number of loci and samples are large.
#' However, a bit of patience is worth it! \cr
#'
#' @return A \code{data.table} object is returned with all the columns contained in
#' the original VCF file with some additions:
#' \itemize{
#'     \item A column called \code{LOUCS} is generated. This is the concatenation of the
#'              \code{CHROM} and \code{POS} column to form a locus ID.
#'     \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
#'              are the columns that follow the \code{FORMAT} column in the original VCF.
#'     \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
#' } \cr
#' Note, for VCF files produced by Stacks, the $CHROM is given the same value
#' as the $ID column. \cr\cr
#' When \code{keepInfo==TRUE} and/or \code{keepComments==TRUE}, these are returned
#' as attributes. E.g., if the returned object is \code{vcfDT}, then you can
#' access Info and Comments (respectively) with: \code{attr(vcfDT, 'vcf_info')}
#' and \code{attr(vcfDT, 'vcf_comments')}.
#'
#' @references This & Riginos (2019) genomalicious: serving up a smorgasbord of
#' R functions for population genomic analyses. BioRxiv.
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # This command here shows you the VCF file that comes with genomalicious
#' list.files(genomaliciousExtData, pattern='_poolseq.vcf')
#'
#' # Use this to create a path to that file
#' vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
#'
#' # You can read the file in as lines to see what it
#' # looks like:
#' readLines(vcfPath)
#'
#' # Now read it in as a data table
#' readVcf1 <- vcf2DT(vcfPath)
#' readVcf1
#'
#' # Read in VCF, but drop some columns,
#' # and keep comments and info.
#' readVcf2 <- vcf2DT(vcfPath
#'    , dropCols=c('FILTER', 'ID')
#'    , keepComments=TRUE
#'    , keepInfo=TRUE)
#'
#' readVcf2
#'
#' attr(readVcf2, 'vcf_comments')
#' attr(readVcf2, 'vcf_info')
#'
#' @export
vcf2DT <- function(vcfFile
, dropCols=NULL
, keepComments=FALSE
, keepInfo=FALSE
, flip=FALSE
, dat
, vcfValues=list(loci='LOCUS'
, variants=c('CHROM', 'POS', 'REF', 'ALT')
, format=c('GT', 'DP', 'RO', 'AO')
, samples='SAMPLE'))
{
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Code: VCF to data table             ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- cbind(LOCUS=vcfDT[, paste(CHROM, POS, sep='_')], vcfDT)
# Get the locus info as a vector and drop from data table
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
# Make sure SAMPLE is a character
vcfDT$SAMPLE <- as.character(vcfDT$SAMPLE)
# Add the $FORMAT data into the data table
cat('(4/4) Collecting and organising FORMAT data', sep='\n')
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
vcfDT <- cbind(vcfDT, as.data.table(formatDat))
# Drop FORMAT and DATA
vcfDT <- vcfDT[, !c('FORMAT','DATA'), with=FALSE]
# Make sure DP, RO, and AO are integers
for(i in c('DP', 'RO', 'AO')){
if(i %in% colnames(vcfDT)){ vcfDT[[i]] <- as.integer(vcfDT[[i]]) }
}
# Attach header as an attribute, if specified.
if(keepComments==TRUE){
attr(vcfDT, 'vcf_comments') <- readLines(vcfFile, n=headPos-1)
}
# Attach info as an attribute if, if specified.
if(keepInfo==TRUE){
attr(vcfDT, 'vcf_info') <- vcfInfo
}
# Finish
cat('All done! <3', '\n')
# Return the data.table, drop any columns if specified.
if(is.null(dropCols)){
return(vcfDT)
} else{
return(vcfDT[, !dropCols, with=FALSE])
}
}
readVcf1 <- vcf2DT(vcfPath)
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2
attr(readVcf2, 'vcf_comments')
attr(readVcf2, 'vcf_info')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
