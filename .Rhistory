#'
#' @export
boot_poolfstat <- function(dat, pool.info, num.sims=100){
# Get the ID and number of unique loci
idLoci <- unique(dat$LOCUS)
numLoci <- length(idLoci)
# Create a vector to hold bootstrapped FST
bsFst <- numeric()
# Iterate for num.sims
for(i in 1:num.sims){
# Create the bootstrapped loci names
bsLoci <- data.table(LOCUS.BS=paste0('Locus', 1:numLoci)
, LOCUS.OG=sample(x=idLoci, replace=TRUE)
)
# Create the bootstrapped dataset
bsDat <- apply(bsLoci, 1, function(L){
data.table(LOCUS=L['LOCUS.BS']
, dat[LOCUS==L['LOCUS.OG']
, c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'DP', 'RO')]
)
})
bsDat <- do.call('rbind', bsDat)
# Calculate FST from the bootstrapped dataset
X <- poolfstat_fromDT(bsDat, pool.info)
bsFst <- c(bsFst, X$Fst$FST)
}
# Return the bootstrapped FST values
return(bsFst)
}
#' Generate \code{bayescan} input files
#'
#' Generates an input file for Bayescan from pooled allele frequencies. \cr
#' \cr
#' It assumes that these pooled allele frequencies have been estimated from Gautier et al. (2013)'s
#' \code{poolne_estim}, and have been imported into \code{R} with \code{genomalicious}.
#'
#' @param dat Data.table: The biallelic SNP data. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{POOL} = The population pool ID. \cr
#'                \item \code{LOCUS} = The locus ID. \cr
#'                \item \code{PI} = The population Ref allele frequency. \cr
#'              }
#'
#' @param pool.info Data table: The population pool metadata. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{$POOL} = The population pool ID. \cr
#'                \item \code{$INDS} = The number of diploid individuals in each pooled library.
#'              }
#'
#' @param file.bayescan Character: The name of the input file for \code{bayescan}/
#'
#' @param file.loci Character: A file that contains an information about the locus ID in
#' the \code{bayescan} input file (i.e., \code{file.bayescan}).
#'
#' @details The allele counts in the Bayescan input file generated reflect the number of haploid
#' genomes pooled. E.g. if 20 individuals were pooled, i.e. 40 genomes, and the Ref allele was
#' estimated at a frequency of, the counts would be Ref=28 and Alt=12.
#'
#' @examples
#' data(genomaliciousPi)
#' data(genomaliciousInfo)
#'
#' Bayescan_inputs(genomaliciousPi, genomaliciousInfo, 'Bayescan_input.txt', 'Bayescan_loci.txt')
#'
#' @export
bayescan_inputs <- function(dat, pool.info, file.bayescan, file.loci) {
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table')){ require(lib, character.only=TRUE) }
# Check class of dat.
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check class of pool.info.
if(!'data.table' %in% class(pool.info)){ stop("Argument pool.info isn't a data table") }
# Test for the necessary columns in dat.
if(sum(c("POOL", "LOCUS", "PI") %in% colnames(dat))!= 3){
stop("Argument dat needs the columns $POOL, $LOCUS, $PI.")
}
# Test for the necessary columns in pool.info.
if(sum(c('POOL', 'INDS') %in% colnames(pool.info))!=2){
stop("Argument pool.info needs the columns $POOL and $INDS.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','PI')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $PI,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$PI*genomes)
alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
# Write (append) lines to txt file.
# First open the file
# Next append the number of loci and number of pops
# Then iterate through each j-th population in BS.ls and write data to file
file.create(file.bayescan)
for(i in c(num.loci,'',num.pops,'')){ write(i,file=file.bayescan,append=T) }
for(j in 1:length(names(BS.ls))){
write(paste0('[pop]=',j),file=file.bayescan,append=T)
write.table(BS.ls[[j]][,-'LOCUS'],file=file.bayescan,append=T,col.names=F,row.names=F)
write('',file=file.bayescan,append=T)
}
# Create a file of marker/locus order
fwrite(x=BS.ls[[1]][,c('MARKER','LOCUS')], file=file.loci, sep='\t')
# ........... END
}
data(genomaliciousPi)
data(genomaliciousInfo)
Bayescan_inputs(genomaliciousPi, genomaliciousInfo, 'Bayescan_input.txt', 'Bayescan_loci.txt')
bayescan_inputs(genomaliciousPi, genomaliciousInfo, 'Bayescan_input.txt', 'Bayescan_loci.txt')
dat <- genomaliciousPi
popCol='POOL'
locusCol='LOCUS'
freqCol='PI'
# --------------------------------------------+
# Code
# --------------------------------------------+
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
dat$POOL
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename population, locus, and frequency columns
setnames(dat, c(popCol, locusCol, freqCol), c('POOL', 'LOCUS', 'PI'))
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','PI')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
dat.spl
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $PI,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$PI*genomes)
alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
BS.ls
#' Generate \code{bayescan} input files
#'
#' Generates an input file for Bayescan from pooled allele frequencies. \cr
#' \cr
#' It assumes that these pooled allele frequencies have been estimated from Gautier et al. (2013)'s
#' \code{poolne_estim}, and have been imported into \code{R} with \code{genomalicious}.
#'
#' @param dat Data.table: The biallelic SNP data. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{POOL} = The population pool ID. \cr
#'                \item \code{LOCUS} = The locus ID. \cr
#'                \item \code{PI} = The population Ref allele frequency. \cr
#'              }
#'
#' @param pool.info Data table: The population pool metadata. Requires all of the following columns: \cr
#'              \enumerate{
#'                \item \code{$POOL} = The population pool ID. \cr
#'                \item \code{$INDS} = The number of diploid individuals in each pooled library.
#'              }
#'
#' @param file.bayescan Character: The name of the input file for \code{bayescan}/
#'
#' @param file.loci Character: A file that contains an information about the locus ID in
#' the \code{bayescan} input file (i.e., \code{file.bayescan}).
#'
#' @details The allele counts in the Bayescan input file generated reflect the number of haploid
#' genomes pooled. E.g. if 20 individuals were pooled, i.e. 40 genomes, and the Ref allele was
#' estimated at a frequency of, the counts would be Ref=28 and Alt=12.
#'
#' @examples
#' data(genomaliciousPi)
#' data(genomaliciousInfo)
#'
#' bayescan_inputs_pool(dat=genomaliciousPi
#'                      , pool.info=genomaliciousInfo
#'                      , file.bayescan='Bayescan_input.txt'
#'                      , file.loci='Bayescan_loci.txt'
#'                      , popCol='POOL', locusCol='LOCUS', freqCol='PI')
#'
#' @export
bayescan_inputs_pool <- function(dat, pool.info, file.bayescan, file.loci, popCol, locusCol, freqCol) {
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table')){ require(lib, character.only=TRUE) }
# Check class of dat.
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check class of pool.info.
if(!'data.table' %in% class(pool.info)){ stop("Argument pool.info isn't a data table") }
# Test for the necessary columns in dat.
if(sum(c(popCol, locusCol, freqCol) %in% colnames(dat))!= 3){
stop("Argument dat needs the columns specified by the arguments: popCol, locusCol, freqCol")
}
# Test for the necessary columns in pool.info.
if(sum(c('POOL', 'INDS') %in% colnames(pool.info))!=2){
stop("Argument pool.info needs the columns $POOL and $INDS.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename population, locus, and frequency columns
setnames(dat, c(popCol, locusCol, freqCol), c('POOL', 'LOCUS', 'PI'))
# Create some character objects to insert into input file
num.loci <- paste0('[loci]=',length(unique(dat$LOCUS)))
num.pops <- paste0('[populations]=',length(unique(dat$POOL)))
# Reduce data columns then split the data on $POOL.
dat.spl <- lapply(split(dat[,c('POOL','LOCUS','PI')], dat$POOL), function(X){
setorder(X, LOCUS)
return(X)
})
# Iterate through each Xth population and make a Bayescan-friendly data table.
# The observed REF and ALT alleles counts are derived from the estimated values in $PI,
# with respect to the sampled number of genomes (2*diploid individuals).
BS.ls <- lapply(dat.spl, function(X){
pool <- X$POOL[1]
genomes <- pool.info[POOL==pool]$IND
pop <- unique(X$POOL)
ref <- as.integer(X$PI*genomes)
alt <- genomes - ref
# BS.dt is a data table for each population in the Bayescan (BS) format.
# There are 5 columns: 1=the locus number; 2=total sampled genomes (2xdiploid individuals);
# 3=the number of alleles at the locus (which is 2 because SNPs are biallelic);
# 4=Ref allele count; 5=Alt allele count.
BS.dt <-data.table(MARKER=1:nrow(X), LOCUS=X$LOCUS, GENOMES=genomes, ALLELES=2, REF=ref, ALT=alt)
return(BS.dt)
})
# Write (append) lines to txt file.
# First open the file
# Next append the number of loci and number of pops
# Then iterate through each j-th population in BS.ls and write data to file
file.create(file.bayescan)
for(i in c(num.loci,'',num.pops,'')){ write(i,file=file.bayescan,append=T) }
for(j in 1:length(names(BS.ls))){
write(paste0('[pop]=',j),file=file.bayescan,append=T)
write.table(BS.ls[[j]][,-'LOCUS'],file=file.bayescan,append=T,col.names=F,row.names=F)
write('',file=file.bayescan,append=T)
}
# Create a file of marker/locus order
fwrite(x=BS.ls[[1]][,c('MARKER','LOCUS')], file=file.loci, sep='\t')
# ........... END
}
bayescan_inputs_pool(dat=genomaliciousPi
, pool.info=genomaliciousInfo
, file.bayescan='Bayescan_input.txt'
, file.loci='Bayescan_loci.txt'
, popCol='POOL', locusCol='LOCUS', freqCol='PI')
?bayescan_inputs_pool
document()
library(genomalicious)
?bayescan_inputs
library(genomalicious)
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
getwd()
getwd()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
?document
roxygenise(clean=TRUE)
devtools::install_github("gustavdelius/roxygen")
devtools::document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygen2::roxygenise()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages("roxygen2")
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
devtools::install_github("gustavdelius/roxygen")
document()
library(genomalicious)
bayescan_inputs_pool
?bayescan_inputs_pool
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
devtools::install_github("klutometis/roxygen")
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
\
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
devtools::document()
roxygenize()
roxygenise()
document()
update_imports()
file.access()
file.access('.')
?file.access
file.access('.',2)
file.access('./',2)
file.access('../',2)
file.access('../genomalicious/',2)
file.access('../genomalicious/man/',2)
file.access('../genomalicious/',2)
file.access('../genomalicious/',4)
file.access('../genomalicious/',1)
file.access('../genomalicious/',0)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
sessionInfo()
document()
roxygenise(clean=TRUE)
roxygenise(clean=TRUE)
?file
traceback()
document()
traceback()
devtools::install_github("hadley/devtools")
devtools
devtools::install_github("hadley/devtools")
installed.packages('git2r')
install.packages('git2r')
installed.packages(devtools)
install.packages('devtools')
install.packages('roxygen2')
install.packages('testthat')
install.packages('knitr')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
?document()
file.access
file.access('R/*.R')
file.access('R/*.R', 2)
?file.access
file.access('R/*.R', 4)
file.access('R/bayescan_inputs_pool.R', 4)
file.access('R/bayescan_inputs_pool.R', 2)
file.access('R/', 2)
roxygen2::roxygenise(clean = TRUE)
remove.packages('roxygen2')
'roxygen2'
library(git2r)
library(devtools)
devtools::install_github("gustavdelius/roxygen")
<<<<<<< HEAD
lociA <- c(1, 2, 3, 4, 5)
lociB <- c(5, 6, 7, 8, 9)
intersect(selA, selB)
lociB <- c(5, 6, 7, 8, 9)
lociA <- c(1, 2, 3, 4, 5)
lociB <- c(5, 6, 7, 8, 9)
selA <- c(5, 1)
selB <- 5
intersect(selA, selB)
shareObs <- length(intersect(selA, selB))
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
randB
shareNull <- length(intersect(randA, randB))
shareNull
replicate(100, length(intersect(randA, randB)))
shareNull <- as.integer()
for(i in 1:iters){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
shareNull <- c(shareNull, length(intersect(randA, randB)))
}
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- as.integer()
for(i in 1:iters){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
shareNull <- c(shareNull, length(intersect(randA, randB)))
}
lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
hist(shareNull)
shareNull > shareObs
sum(shareNull > shareObs)
lociA <- 1:100
lociB <- 50:150
selA <- c(5, 1)
selB <- 5
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
shareNull <- unlist(shareNull)
hist(shareNull)
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
randA
randB
lociA <- 1:100
lociB <- 1:100
selA <- c(5, 1)
selB <- 5
iters <- 100000
shareObs <- length(intersect(selA, selB))
shareNull <- lapply(1:iters, function(i){
randA <- sample(x=lociA, size=length(selA), replace=FALSE)
randB <- sample(x=lociB, size=length(selB), replace=FALSE)
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
hist(shareNull)
sum(shareNull > shareObs)
sum(shareNull >= shareObs)
sum(shareNull >= shareObs)/iters
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
document()
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages("roxygen2")
devtools::install_github("hadley/devtools")
install.packages('devtools')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
install.packages('backports')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
roxygenise('./', clean = TRUE)
=======
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
session_info()
remove.packages('roxygen2')
remove.packages(lib='roxygen2')
remove.packages(pkgs='roxygen2')
library(roxygen2)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
devtools::install_github('gustavdelius/roxygen')
install.packages('digest')
install.packages("digest")
devtools::install_github('gustavdelius/roxygen')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
document()
traceback()
View(document)
roxygenize()
roxygenise()
remove.packages('roxygen2')
>>>>>>> 533ac4a23eec8afb651bf694cf85b496a8b70f93
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
doucment()
roxygenise()
roxygenise('./', clean=TRUE)
roxygenise('../genomalicious/', clean=TRUE)
