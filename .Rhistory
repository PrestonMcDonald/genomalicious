class(dat)
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & (!'data.table' %in% class(dat))){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The sampled individual ID (see param \code{sampCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The Ref allele frequency (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousGenos)
#'
#' # Convert a long data table to a wide matrix
#' genoMat <- DT2Mat_genos(genomaliciousGenos, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' genoDT <- DT2Mat_genos(genoMat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & (!'data.table' %in% class(dat))){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
#' Conduct a PCA on individual genotypes stored in a (long) data table
#'
#' Takes a long data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function. Different options for scaling the genotypes
#' pre-PCA are available.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled? Set to
#' \code{'center'} (default) to scale to mean = 0 and variance = 1. Set to
#' \code{'patterson'} to use the Patteron et al. (2006) normalisation.
#' Set to \code{'none'} if you don't want to do any scaling pre-PCA.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @return Returns a \code{prcomp} object
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' # Data
#' data(genomalicious4pops)
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTinds(dat=genomalicious4pop, scaling='patterson', popCol='POP')
#'
#'
#' @export
pca_DTinds <- function(dat, scaling='center', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', popCol=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
if(!scaling %in% c('center', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
# Scale
if(scaling=='center'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
}
if(scaling=='patterson'){
genoMat <- normalise_patterson(genoMat)
}
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- subset(unique(popMems))
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(rownames(genoMat), popMems[[sampCol]])]
}
return(pca)
# ........... END
}
pca <- pca_DTinds(dat=genomalicious4pop, scaling='patterson', popCol='POP')
data(genomalicious4pops)
pca <- pca_DTinds(dat=genomalicious4pops, scaling='patterson', popCol='POP')
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The sampled individual ID (see param \code{sampCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The Ref allele frequency (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousGenos)
#'
#' # Convert a long data table to a wide matrix
#' genoMat <- DT2Mat_genos(genomaliciousGenos, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' genoDT <- DT2Mat_genos(genoMat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
plot(pca)
plot(pca$x)
plot(pca$x, bg=pca$pops)
plot(pca$x, bg=as.factor(pca$pops))
plot(pca$x, col=as.factor(pca$pops))
class(dat)
pca
class(pca)
pca -> dat
dat
class(dat)
stop('Argument dat must be one of the following object classes:
prcomp, data.table, data.frame, or matrix')
exists(pca$L)
exists(da$L)
exists(dat$L)
exists(dat$pops)
dat$L
is.null(dat$pops)
pops
pops=NULL
pops
popCols <- c(Pop1='red', Pop2='orange', Pop3='green', Pop4='purple')
if(is.null(pops)==FALSE & !names(popCols)%in%unique(pops)){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
names(popCols)
unique(pops)
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
pops
names(popCols)%in%unique(pops)
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))>=length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
if(is.null(pops)==FALSE &
!sum(names(popCols)%in%unique(pops))==length(unique(pops))){
stop("Argument popCols misspecified: names of colours must be in argument pops.")
}
if(class(dat)=='prcomp'){ X <- dat$x
} else{ X <- dat }
if(is.null(pops)==FALSE){
X$POPS <- pops
}
X
if(class(dat)=='prcomp'){ X <- dat$x
} else{ X <- dat }
X
\
dat
dat
class(dat)
class(dat)=='prcomp'
if(class(dat)=='prcomp'){ X <- dat$x
} else{ X <- dat }
class(dat)
class(X)
if(class(dat)=='prcomp'){ X <- as.data.table(dat$x)
} else{ X <- as.data.table(dat) }
if(is.null(pops)==FALSE){
X$POPS <- pops
}
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
axisIndex <- c(1,2)
axX <- axisIndex[1]; axY <- axisIndex[2]
axX <- colnames(plot.tab)axisIndex[1]
axY <- colnames(plot.tab)axisIndex[2]
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)
}
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY))
gg + geom_point()
gg + geom_point() + theme_classic()
gg + geom_point() + theme_void()
gg + geom_point() + theme_minimal()
gg + geom_point() + theme_bw()
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
look <- 'classic'
gg + geom_point() + plot.theme()
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
gg + geom_point() + plot.theme()
gg + geom_point() + plot.theme
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
gg + geom_point() + plot.theme
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, text=element_text(colour='black'))
gg + geom_point() + plot.theme
look <- 'ggplot'
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, text=element_text(colour='black'))
}
gg + geom_point() + plot.theme
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
gg + geom_point(aes(fill=POPS))
plot.tab
gg + geom_point(aes(colour=POPS))
popCols
gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS))
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
}
gg
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top'
, legend.title=element_blank())
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top'
, legend.title=element_blank())
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS))
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
}
gg
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
gg
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
gg
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
