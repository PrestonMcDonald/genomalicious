# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVar <- do.call('rbind', lociVar)
return(lociVar)
}
#' Calculate Weir and Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param pairs Logical: Should pairwise FSTwc be calculated (TRUE) or the
#' among population FSTwc (FALSE)?
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \n
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' freqMat <- genomaliciousFreqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC(freqMat, sampMat)
#'
#' @export
fstWC <- function(freqMat, sampMat, pairs=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# --------------------------------------------+
# Code
# --------------------------------------------+
if(pairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat, sampleMat)
# Theta across loci
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Theta per locus
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
# Return
return(list(fst.mean=thetaMean, fst.locus=thetaLocus))
} else if(pairs==TRUE){
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
# Return
return(list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
))
}
}
fstWC(freqMat, sampMat, pairs=TRUE)
fstWC(freqMat, sampMat, pairs=FALSE)
#' Calculate Weir and Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param pairs Logical: Should pairwise FSTwc be calculated (TRUE) or the
#' among population FSTwc (FALSE)?
#'
#' @return A list with two indices. \code{$fst.mean} contains the mean FST. In pairwise analyses,
#' this is a data table with population pairs. \code{$fst.locus} contains the locus-specific
#' FST values. If analysis was not pairwise, this is a vector, but for pairwise analyses,
#' this is a data table with population pairs.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \n
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' freqMat <- genomaliciousFreqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC(freqMat, sampMat, pairs=FALSE)
#' fstWC(freqMat, sampMat, pairs=TRUE)
#'
#' @export
fstWC <- function(freqMat, sampMat, pairs=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# --------------------------------------------+
# Code
# --------------------------------------------+
if(pairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat, sampleMat)
# Theta across loci
thetaMean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Theta per locus
thetaLocus <- lociVar$NUMER / lociVar$DENOM
names(thetaLocus) <- lociVar$LOCUS
# Return
return(list(fst.mean=thetaMean, fst.locus=thetaLocus))
} else if(pairs==TRUE){
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
# Return
return(list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
))
}
}
fstWC(freqMat, sampMat, pairs=FALSE)
fstWC(freqMat, sampMat, pairs=TRUE)
roxygenise('./', clean=TRUE)
library(genomalicious)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.RData')
library(genomalicious)
?HierDpart
library(HierDpart)
?iDip
?iDIP
HierDpart::IDIP()
?HierDpart::IDIP()
str=Str(nreg=4,r=c(7,4,2,3),n=16)
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
IDIP(abu,str)
allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes scored as
#' alleles separated by '/' (character) or counts of Ref alleles
#' (integer).
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#'
#' @export
allele_counts <- function(dat){
}
allele_counts(c('1/1', '0/1', '0/1', '0/0'))
dat <- c('1/1', '0/1', '0/1', '0/0')
dat
length(dat)*2
sum(genoscore_converter(dat))
library(genomalicious)
length(dat)*2 - sum(genoscore_converter(dat))
genoscore_converter(dat)
#' Convert between genotype scores (separated alleles vs counts)
#'
#' Assumes biallelic genotypes and can interchange between separated
#' alleles ('0/0', '0/1', '1/1') and Ref allele counts (0, 1, 2).
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes separated alleles and converts into
#' allele counts. The opposite is true if class is \code{'integer'}, will
#' convert into separated alleles.
#'
#' @export
genoscore_converter <- function(dat){
if(!class(dat) %in% c('character', 'integer')){
stop('Class of argument dat is wrong.')
}
if(class(dat)=='character'){
gt <- lapply(strsplit(dat, split='/', fixed=TRUE)
, function(x){2-sum(as.integer(x))})
return(unlist(gt))
}
if(class(dat)=='integer'){
gt <- lapply(dat, function(x){
if(x==2){ return('0/0')
} else if(x==1){ return('0/1')
} else if(x==0){ return('1/1')
}
})
return(unlist(gt))
}
}
length(dat)*2 - sum(genoscore_converter(dat))
genoscore_converter(dat)
genoscore_converter(dat)
genoscore_converter(dat)
genoscore_converter(dat)
genoscore_converter(dat)
dat
genoscore_converter(dat)
#' Convert between genotype scores (separated alleles vs counts)
#'
#' Assumes biallelic genotypes and can interchange between separated
#' alleles ('0/0', '0/1', '1/1') or Ref allele counts (0, 1, 2).
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes separated alleles and converts into
#' allele counts. The opposite is true if class is \code{'integer'}, will
#' convert into separated alleles.
#'
#' @export
genoscore_converter <- function(dat){
if(!class(dat) %in% c('character', 'integer')){
stop('Class of argument dat is wrong.')
}
if(class(dat)=='character'){
gt <- lapply(strsplit(dat, split='/', fixed=TRUE)
, function(x){2-sum(as.integer(x))})
return(unlist(gt))
}
if(class(dat)=='integer'){
gt <- lapply(dat, function(x){
if(x==2){ return('0/0')
} else if(x==1){ return('0/1')
} else if(x==0){ return('1/1')
}
})
return(unlist(gt))
}
}
genoscore_converter(dat)
dat
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='character'){
return(length(dat)*2 - sum(genoscore_converter(dat)))
} else if(class(dat)=='integer'){
return(length(dat)*2 - sum(dat))
}
}
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='character'){
return(length(dat)*2 - sum(genoscore_converter(dat)))
} else if(class(dat)=='integer'){
return(length(dat)*2 - sum(dat))
}
}
allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#' allele_counts()
#'
#' @export
allele_counts <- function(dat){
n <- length(dat)*2
if(class(dat)=='character'){
ref <- n - sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- n - sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0'))
allele_counts(c(1,1,0,2,2,1,2))
allele_counts(c(1,1,0,2,2,1,2))
c(1,1,0,2,2,1,2)
class(c(1,1,0,2,2,1,2))
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0'))
#' allele_counts(c(1,1,0,2,2,1,2))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
n <- length(dat)*2
if(class(dat)=='character'){
ref <- n - sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- n - sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0'))
allele_counts(c(1,1,0,2,2,1,2))
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c(2, 1, 1, 0, 2))
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
n <- length(dat)*2
if(class(dat)=='character'){
ref <- n - sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c(2, 1, 1, 0, 2))
#' Convert between genotype scores (separated alleles vs counts)
#'
#' Assumes biallelic genotypes and can interchange between separated
#' alleles ('0/0', '0/1', '1/1') or Ref allele counts (0, 1, 2).
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes separated alleles and converts into
#' allele counts. The opposite is true if class is \code{'integer'}, will
#' convert into separated alleles.
#'
#' @export
genoscore_converter <- function(dat){
if(!class(dat) %in% c('character', 'integer')){
stop('Class of argument dat is wrong.')
}
if(class(dat)=='character'){
gt <- lapply(strsplit(dat, split='/', fixed=TRUE)
, function(x){2-sum(as.integer(x))})
return(unlist(gt))
}
if(class(dat)=='integer'){
gt <- lapply(dat, function(x){
if(x==2){ return('0/0')
} else if(x==1){ return('0/1')
} else if(x==0){ return('1/1')
}
})
return(unlist(gt))
}
}
allele_counts(c(2, 1, 1, 0, 2))
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
dat <- c('1/1', '0/1', '0/1', '0/0', '0/0')
genoscore_converter(dat)
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
n <- length(dat)*2
if(class(dat)=='character'){
ref <- sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c(2, 1, 1, 0, 2))
str=Str(nreg=4,r=c(7,4,2,3),n=16)
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
str
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
abu
#' Calculate diversity statistics with \code{IDIP} from a data table of genotypes
#'
#' @param snpDat Data table
#'
#' snpDat <- genomaliciousGenos
#' @export
idip_DT <- function(snpDat, strucMat
, sampCol=NA, locusCol=NA, genoCol=NA){
}
snpDat <- genomaliciousGenos
snpDat
snpDat <- genomaliciousGenos
snpDat <- genomalicious4pops
data(genomalicious4pops)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
snpDat <- genomalicious4pops
library(genomalicious)
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
