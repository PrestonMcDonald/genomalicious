#' @examples
#' #' # Load in the pool metadata and reads
#' data(genomaliciousReads)
#' data(genomaliciousInfo)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Use poolfstat_DT to compute FST for this dataset and create a pooldata object
#' poolFst <- poolfstat_DT(X, genomaliciousInfo)
#'
#' # Bootstrap FST, using pooldata object from poolFst
#' bootFst <- poolfstat_boot(poolFst$pooldat, 100)
#'
#' @export
poolfstat_boot <- function(dat, num.sims=100){
# Iterate over sims
fstBoot <- lapply(1:num.sims, function(sim){
# Make a new copy of data to bootstrap
bootDat <- dat
# Rows in data matrices to resample
bootId <- sample(1:dat@nsnp, replace=TRUE)
# Resample ref allele counts, read coverage, and SNP info matrices
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
# Compute FST
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
# Return the bootstrapped FST values
return(fstBoot)
}
<<<<<<< HEAD
roxygenise('./', clean=TRUE)
library(genomalicious)
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
library(genomalicious)
?poolfstat_DT
=======
data(genomaliciousFreqsLong)
genomaliciousFreqsLong
genomaliciousReads
genomaliciousPi
data(genomaliciousPi)
genomaliciousPi
, indsCols='INDS')
dadi_inputs_pools(genomaliciousPi
)
, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
indsCols='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCol='INDS')
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
indsCol='INDS'
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
dat <- genomaliciousPi
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dat
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
indsCol='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dat
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='P', indsCol='INDS')
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousReads <- fread('inst/extdata/genomaliciousReads.csv')
refalt <- unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
save(genomaliciousPi, file='data/genomaliciousPi.RData')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
data(genomalicious4pops)
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID;
#' and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
=======
>>>>>>> master
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
library(genomalicious)
data("genomaliciousPi")
genomaliciousPi
<<<<<<< HEAD
>>>>>>> d225b20342e6de589db4cfb5fb24c7058a360b16
=======
data(genomaliciousPi)
genomaliciousPi
, indsCols='INDS')
dadi_inputs_pools(genomaliciousPi
)
, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
indsCols='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCol='INDS')
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
indsCol='INDS'
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
dat <- genomaliciousPi
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dat
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
indsCol='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dat
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='P', indsCol='INDS')
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousReads <- fread('inst/extdata/genomaliciousReads.csv')
refalt <- unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
save(genomaliciousPi, file='data/genomaliciousPi.RData')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
data(genomalicious4pops)
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID;
#' and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
library(genomalicious)
data("genomaliciousPi")
genomaliciousPi
>>>>>>> master
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
genomaliciousFreqs <- readRDS('inst/extdata/genomaliciousFreqs.RDS')
save(genomaliciousFreqs, file='data/genomaliciousFreqs.RData')
genomaliciousFreqsLong <- as.data.table(genomaliciousFreqs)
genomaliciousFreqsLong$POP <- rownames(genomaliciousFreqs)
genomaliciousFreqsLong <- melt(genomaliciousFreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
save(genomaliciousFreqsLong, file='data/genomaliciousFreqsLong.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
roxygenise('./', clean=TRUE)
library(genomalicious)
