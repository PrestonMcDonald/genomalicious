}
X
if(class(dat)=='prcomp'){ X <- dat$x
} else{ X <- dat }
X
\
dat
dat
class(dat)
class(dat)=='prcomp'
if(class(dat)=='prcomp'){ X <- dat$x
} else{ X <- dat }
class(dat)
class(X)
if(class(dat)=='prcomp'){ X <- as.data.table(dat$x)
} else{ X <- as.data.table(dat) }
if(is.null(pops)==FALSE){
X$POPS <- pops
}
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
axisIndex <- c(1,2)
axX <- axisIndex[1]; axY <- axisIndex[2]
axX <- colnames(plot.tab)axisIndex[1]
axY <- colnames(plot.tab)axisIndex[2]
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)
}
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY))
gg + geom_point()
gg + geom_point() + theme_classic()
gg + geom_point() + theme_void()
gg + geom_point() + theme_minimal()
gg + geom_point() + theme_bw()
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
look <- 'classic'
gg + geom_point() + plot.theme()
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
gg + geom_point() + plot.theme()
gg + geom_point() + plot.theme
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
gg + geom_point() + plot.theme
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, text=element_text(colour='black'))
gg + geom_point() + plot.theme
look <- 'ggplot'
if(look=='ggplot'){
plot.theme <- theme_gray()
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, text=element_text(colour='black'))
}
gg + geom_point() + plot.theme
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
gg + geom_point(aes(fill=POPS))
plot.tab
gg + geom_point(aes(colour=POPS))
popCols
gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS))
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
}
gg
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top'
, legend.title=element_blank())
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top'
, legend.title=element_blank())
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS))
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols)
}
gg
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
gg
if(look=='ggplot'){
plot.theme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plot.theme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plot.theme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popCols)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popCols)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popCols) + labs(colour=NULL)
}
gg
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(genomalicious)
genomalicious4pops
genomaliciousInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(genomaliciousInfo, file='data/genomaliciousInfo.RData')
genomaliciousReads <- fread('inst/extdata/genomaliciousReads.csv')
save(genomaliciousReads, file='data/genomaliciousReads.RData')
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
save(genomaliciousPi, file='data/genomaliciousPi.RData')
genomaliciousGenos <- fread('inst/extdata/genomaliciousGenos.csv')
save(genomaliciousGenos, file='data/genomaliciousGenos.RData')
genomaliciousFreqs <- readRDS('inst/extdata/genomaliciousFreqs.RDS')
save(genomaliciousFreqs, file='data/genomaliciousFreqs.RData')
genomaliciousFreqsLong <- as.data.table(genomaliciousFreqs)
genomaliciousFreqsLong$POP <- rownames(genomaliciousFreqs)
genomaliciousFreqsLong <- melt(genomaliciousFreqsLong, id='POP', variable.name='LOCUS', value.name='FREQ')
save(genomaliciousFreqsLong, file='data/genomaliciousFreqsLong.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
library(genomalicious)
genomalicious4pops
genomaliciousReads
dat <- genomaliciousReads
library(data.table); library(tidyr)
# Split the data by LOCUS
dat.spl <- split(dat, as.factor(dat$LOCUS))
# Use spread() from tidyr to put SAMPLE in columns and RO/AO in cells
allele1 <- spread(dat[,c('LOCUS','SAMPLE','RO')], SAMPLE, RO)
allele2 <- spread(dat[,c('LOCUS','SAMPLE','AO')], SAMPLE, AO)
allele1
allele2
# Extract the allelic states and remove duplicates rows
states <- dat[,c('LOCUS','REF','ALT')]
states <- states[which(!duplicated(states)),]
states
# Add in some '-' into the allelic states, this is a Dadi requirement.
for(i in 1:nrow(states)){
states$REF[i] <- paste0('-',states$REF[i],'-')
states$ALT[i] <- paste0('-',states$ALT[i],'-')
}
states
# Combine all individual data tables into single object
dadi.dt <- data.table(states[,2:3], Allele1=gsub('-', '', states$REF)
, allele1[,2:ncol(allele1)], Allele2=gsub('-', '', states$ALT), allele2[,2:ncol(allele2)]
, Locus=states$LOCUS)
dadi.dt
allele1
genomaliciousPi
genomaliciousInfo
genomaliciousReads
genomaliciousPi$LOCUS
match(genomaliciousPi$LOCUS, genomaliciousReads$LOCUS)
genomaliciousReads$ALT[match(genomaliciousPi$LOCUS, genomaliciousReads$LOCUS)]
unique(genomaliciousReads)
unique(genomaliciousReads[, c('LOCUS', 'REF',  'ALT')])
unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
refalt <- unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
match(genomaliciousPi$LOCUS, refalt$LOCUS)
refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
cbind)genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')])
cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')])
cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousPi
save(genomaliciousPi, file='data/genomaliciousPi.RData')
library(genomalicious)
genomalicious
genomaliciousPi
poolCol='POOL'
locusCol='LOCUS'
refCol='REF'
altCol='ALT'
indsCol='INDS'
dat <- genomaliciousPi
poolCol='POOL'
locusCol='LOCUS'
refCol='REF'
altCol='ALT'
indsCol='INDS'
poolSub=NULL
unique(dat$LOCUS)
dat[LOCUS==locus]
locus <- "Chrom_1_8"
dat[LOCUS==locus]
X <- dat[LOCUS==locus]
X[, PI*INDS]
0.5882639*0.3
X[, round(PI*INDS)]
X <- dat[LOCUS==locus]
X
X[, X$REF.COUNT:=round(PI*INDS)]
X[, REF.COUNT:=round(PI*INDS)]
X
X[, ALT.COUNT:=INDS-REF.COUNT]
X
# Split the data by LOCUS
dat.spl <- split(dat, as.factor(dat$LOCUS))
# Use spread() from tidyr to put SAMPLE in columns and RO/AO in cells
allele1 <- spread(dat[,c('LOCUS','SAMPLE','RO')], SAMPLE, RO)
allele2 <- spread(dat[,c('LOCUS','SAMPLE','AO')], SAMPLE, AO)
# Extract the allelic states and remove duplicates rows
states <- dat[,c('LOCUS','REF','ALT')]
states <- states[which(!duplicated(states)),]
# Add in some '-' into the allelic states, this is a Dadi requirement.
for(i in 1:nrow(states)){
states$REF[i] <- paste0('-',states$REF[i],'-')
states$ALT[i] <- paste0('-',states$ALT[i],'-')
}
# Sort the order of individual datatables by LOCUS
setorder(allele1, LOCUS); setorder(allele2, LOCUS); setorder(states, LOCUS)
# Combine all individual data tables into single object
dadi.dt <- data.table(states[,2:3], Allele1=gsub('-', '', states$REF)
, allele1[,2:ncol(allele1)], Allele2=gsub('-', '', states$ALT), allele2[,2:ncol(allele2)]
, Locus=states$LOCUS)
dadi.dt
X[, paste0('-', ALT, '-') ]
X[, ALT:=paste0('-', ALT, '-') ]
X
X[, REF:=paste0('-', REF, '-') ]
X
X <- dat[LOCUS==locus]
X[, REF.COUNT:=round(PI*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X[, ALLELE1:=paste0('-', REF, '-') ]
X[, ALLELE2:=paste0('-', ALT, '-') ]
X
?setorder
spread(X, key=POOL)
X <- dat[LOCUS==locus]
X[, REF.COUNT:=round(PI*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X[, SEQ1:=paste0('-', REF, '-') ]
X[, SEQ2:=paste0('-', ALT, '-') ]
X
X <- dat[LOCUS==locus]
X[, REF.COUNT:=round(PI*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X[, REF.SEQ:=paste0('-', REF, '-') ]
X[, ALT.SEQ:=paste0('-', ALT, '-') ]
X
X <- dat[LOCUS==locus]
X[, REF.COUNT:=round(PI*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
poolCol='POOL'
locusCol='LOCUS'
refCol='REF'
altCol='ALT'
freqCol='PI'
indsCol='INDS'
poolSub=NULL
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dat
X <- dat[LOCUS==locus]
X[, REF.COUNT:=round(P*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X
spread(X[,c('POOL', 'REF.COUNT')], key=POOL)
spread(X[,c('POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
X <- dat
X[, REF.COUNT:=round(P*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
X
spread(X[,c('POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
spread(X[,c('POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=REF.COUNT)
spread(X[,c('POOL', 'REF.COUNT', 'LOCUS', 'REF')], key=POOL, value=REF.COUNT)
spread(X[,c('REF', 'POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=REF.COUNT)
spread(X[,c('ALT', 'POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=ALT.COUNT)
X[, REF.COUNT:=round(P*INDS)]
X <- dat
X[, REF.COUNT:=round(P*INDS)]
X[, ALT.COUNT:=INDS-REF.COUNT]
spread(X[,c('REF', 'POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=REF.COUNT)
spread(X[,c('ALT', 'POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=ALT.COUNT)
X
spread(X[,c('ALT', 'POOL', 'ALT.COUNT', 'LOCUS')], key=POOL, value=ALT.COUNT)
dat[, REF.COUNT:=round(P*INDS)]
dat[, ALT.COUNT:=INDS-REF.COUNT]
r <- spread(X[,c('REF', 'POOL', 'REF.COUNT', 'LOCUS')], key=POOL, value=REF.COUNT)
a <- spread(X[,c('ALT', 'POOL', 'ALT.COUNT', 'LOCUS')], key=POOL, value=ALT.COUNT)
r
a
setorder(r, 'LOCUS')
r
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS')
r
a
paste0('-', a$ALT, '-')
paste0('-', r$REF, '-')
paste0('-', a$ALT, '-')
data.table(REF:=paste0('-', r$REF, '-')
, ALT:=paste0('-', a$ALT, '-')
, r[, !'LOCUS']
)
data.table(REF=paste0('-', r$REF, '-')
, ALT=paste0('-', a$ALT, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
)
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
)
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
)
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
data_inputs_pool <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat[, REF.COUNT:=round(P*INDS)]
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
data_inputs_pool <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat[, REF.COUNT:=round(P*INDS)]
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
dadi_inputs_pool <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='PI'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat[, REF.COUNT:=round(P*INDS)]
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
dadi_inputs_pool(genomaliciousPi)
genomaliciousPi
data("genomaliciousPi")
genomaliciousPi
dadi_inputs_pool(genomaliciousPi)
roxygenise('./', clean=TRUE)
library(genomalicious)
