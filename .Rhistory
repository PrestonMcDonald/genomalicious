}))
return(fst_boot)
}
fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
require(pbapply)
# Number of loci
n <- ncol(dat)
i
i <- 1
# Get indices of the loci to boostrap resample
index <- sample(1:n, size=n, replace=TRUE)
index
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, samp_size=samp_size)
dat[, index]
#' Bootstrapped Weir & Cockerham's FST
#'
#' Generate a vector of bootstrapped Weir and Cockerham's FST from observed
#' genotype data.
#'
#' @param dat Matrix: Allele frequencies for populations, or biallelic genotypes of
#' of individuals scores as integer counts of the Alt allele (0, 1, 2).
#' Populations or individuals are in rows, loci are in columns.
#' Column names are loci IDs and must exactly match those in argument \code{samp_size}.
#' @param input_type Character: One of two possible values: 'genos', calcualte
#' variance components from genotype matrix, or 'freqs', calculate variance
#' components from an allele frequency matrix.
#'
#' @param pop_id  Charater: A vector of population IDs. Default is NULL and
#' is only required if \code{input_type=='genos'}. Must be the same length
#' as \code{nrow(dat)} and the order of values must match the order of rows in \code{dat}.
#'
#' @param samp_size Matrix: The sample size for each locus in each population.
#' Default is \code{NULL} and is required if \code{input_type=='freqs'}.
#' Allows for different sample sizes at each locus, for example, if there
#' is missing data. Populations in rows, loci in columns. Rows must be
#' in the same order as rows in \code{dat}. Column names are loci IDs
#' and must all occur in \code{dat}.
#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @return Returns a vector bootstrapped multilocus FST values.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#'
#' @export
fstWC_boot <- function(dat, input_type, pop_id=NULL, samp_size=NULL, boots=100){
require(pbapply)
# Number of loci
n <- ncol(dat)
# For each ith bootstrap...
cat('Performing FST bootstrap calculations', '\n')
fst_boot <- unlist(pblapply(1:boots, function(i){
# Get indices of the loci to boostrap resample
index <- sample(1:n, size=n, replace=TRUE)
# Get bootstrapped variance components
if(input_type=='genos'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, pop_id=pop_id)
} else if(input_type=='freqs'){
bootVarcomps <- fstWC_varcomps(dat=dat[, index], input_type=input_type, samp_size=samp_size[, index])
}
# The mean permuted FST
fst <- sum(bootVarcomps$NUMER) / sum(bootVarcomps$DENOM)
return(fst)
}))
return(fst_boot)
}
fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
boot_fst <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
fstList
# Output list
fstList <- list()
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat, input_type='freqs', samp_size=sampMat)
# Theta across loci
fstList$multilocus.mean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.boot <- fst.boot
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
fstList
fst.locus <- lociVar$NUMER / lociVar$DENOM
names(fst.locus) <- lociVar$LOCUS
fstList$perlocus <- fst.locus
fstList
boots
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
# Output for each Xth pair
Xlist <- list()
# Population pairs
pairCombos <- combn(x=rownames(freqMat), m=2)
X <- pairCombos[,1]
X
# Output for each Xth pair
Xlist <- list()
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
Xlist
# Pair ID
pair_id <- paste(X, collapse='/')
pair_id
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
fst.ci
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
Xlist
# For the Xth pair
pairList <- apply(pairCombos, 2, function(X){
# Output for each Xth pair
Xlist <- list()
# Pair ID
pair_id <- paste(X, collapse='/')
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
}
# Theta per locus
if(perLocus==TRUE){
Xlist$perlocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
}
# Return the data for Xth pair
return(Xlist)
})
pairList
do.call('rbind', lapply(pairList, function(xx){ xx$boot }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairList, function(xx){ xx$ci }))
fstList
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
fstList$multilocus.mean
# Combine multilocus estimates
fstList$multilocus.mean <- do.call('rbind', lapply(pairList, function(xx){ xx$mean }))
fstList$multilocus.mean
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Add to the output list
fstList$multilocus.dist <- as.dist(fst.dist, diag=TRUE)
fstList$multilocus.dist
fstList$perlocus <- do.call('rbind', lapply(pairList, function(xx){ xx$perlocus }))
fstList
#' Calculate Weir and Cockerham's FST from allele frequencies
#'
#' Takes a matrix of biallelic allele frequencies, and a matrix of sample sizes,
#' and calculates Weir and Cockerham's FST, i.e. theta (Weir & Cockerham, 1984).
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
#'
#' @param doPairs Logical: Should pairwise FST be calculated? Default = \code{FALSE},
#' which calculates the among population FST.
#'
#' @param bootCI Logical: Should bootstrap confidence intervals be estimated?
#' Default = \code{FALSE}.
#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @param doDist Logical: Should a a distance matrix of FST be returned?
#' Default = \code{FALSE}. Only applied when \code{doPairs==TRUE}.
#'
#' @param perLocus Logical: Should the per locus FST be returned?
#' Default = \code{FALSE}.
#'
#' @return A list with up to three different indices.
#' \enumerate{
#'    \item \code{$fst.mean}: contains the mean FST across loci. For among populations,
#'          this is a vector, whereas for pairwise analyses it is a data table
#'          with a \code{$POP1}, \code{$POP2}, and \code{$FST} column.
#'    \item \code{$fst.locus}: contains the locus-specific FST values
#'          if \code{perLocus==TRUE}. For amonong populations, this is a vector,
#'          but for pairwise analyses, this is a data table with population pairs.
#'    \item \code{$fst.dist}: will contain a distance matrix of FST values
#'          if \code{doPairs==TRUE} and \code{doDist==TRUE}.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' data(genomalicious_Freqs)
#' freqMat <- genomalicious_Freqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
#'
#' @export
fstWC_freqs <- function(freqMat, sampMat, doPairs=FALSE, bootCI=FALSE, boots=100, doDist=FALSE, perLocus=FALSE){
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
if(doDist==TRUE & doPairs==FALSE){
warning('Argument doDist set to TRUE, but doPairs set to FALSE: Will
only calcualte a distance matrix for pairwise analyses.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# Output list
fstList <- list()
# --------------------------------------------+
# Code: FST among all populations
# --------------------------------------------+
# Calculate among populations
if(doPairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat, input_type='freqs', samp_size=sampMat)
# Theta across loci
fstList$multilocus.mean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.boot <- fst.boot
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
}
# Theta per locus
if(perLocus==TRUE){
fst.locus <- lociVar$NUMER / lociVar$DENOM
names(fst.locus) <- lociVar$LOCUS
fstList$perlocus <- fst.locus
}
# Return among population analyses
return(fstList)
}
# --------------------------------------------+
# Code: FST between population pairs
# --------------------------------------------+
if(doPairs==TRUE){
# Population pairs
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairList <- apply(pairCombos, 2, function(X){
# Output for each Xth pair
Xlist <- list()
# Pair ID
pair_id <- paste(X, collapse='/')
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
}
# Theta per locus
if(perLocus==TRUE){
Xlist$perlocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
}
# Return the data for Xth pair
return(Xlist)
})
# Combine multilocus estimates
fstList$multilocus.mean <- do.call('rbind', lapply(pairList, function(xx){ xx$mean }))
# Combine bootstrap replicates
if(bootCI==TRUE){
fstList$multilocus.boot <- do.call('rbind', lapply(pairList, function(xx){ xx$boot }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairList, function(xx){ xx$ci }))
}
# If an FST distance matrix was requested:
if(doDist==TRUE){
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Add to the output list
fstList$multilocus.dist <- as.dist(fst.dist, diag=TRUE)
}
# Combine the per locus estimates
if(perLocus==TRUE){
fstList$perlocus <- do.call('rbind', lapply(pairList, function(xx){ xx$perlocus }))
}
# Return pairwise analyses
return(fstList)
}
}
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
roxygenise()
library(genomalicious)
?fstWC_genos
?fstWC_varcomps
?fstWC_boot
View(fstWC_boot)
?fstWC_perm
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
#' Parametric bootstrap of \code{poolne_estim} allele frequencies
#'
#' Takes the results of \code{poolne_estim} (Gautier et al. 2013) and
#' performs a parametric bootstrap of Ref allele frequencies based on their
#' pi (estimated Ref allele frequency) and sd (the standard deviation).
#'
#' @param dat Data table: the \code{poolne_estim} data. For example, the
#' output from \code{genomalicious::poolne_estim_output()}. Requires 4 columns: \cr
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$PI}, the estimated population frequency for the Ref allele. \cr
#'    \item \code{$SD}, the standard deviation for PI.
#' }
#'
#' @param num.sims Numeric, the number of simulations to generate. Default = \code{100}.
#'
#' @return A data table, with the following columns:
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$BOOT.NUM}, the simulation number. \cr
#'    \item \code{$BOOT.PI}, the simulated pi (Ref allele frequency).
#' }
#'
#' @details The values of \code{PI} and \code{SD} in \code{dat} are used to generate
#' the alpha and beta paramters of a beta distribution, where: \cr
#' \cr
#' \code{alpha = ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2} \cr
#' \code{beta = alpha * (1 / Mu - 1)} \cr
#' \cr
#' Here, values of \code{dat$PI} take on the values of \code{Mu} (the mean) and
#' \code{(dat$SD)^2} take on the values of \code{Var} (the variance). \cr
#' \cr
#' From the resulting beta distribution, \code{num.sims} values are drawn to create
#' a distribution of possible allele frequencies (for each locus) that might exist in the sampled
#' populations (given the associated mean and error estimated by \code{poolne_estim}).
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # Get the poolne estimat pi estimates
#' pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
#'
#' # Simulate potential distributions
#' pi.sims <- poolne_estim_boot_pi(pi.data, 100)
#' pi.sims
#'
#' @export
poolne_estim_boot_pi <- function(dat, num.sims=100){
# BEGIN ...................
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'pbapply')){ require(lib, character.only=TRUE)}
# Check the class of dat.
if(!'data.table' %in% class(dat)){
stop("Argument dat needs to be class 'data.table'.")
}
# Check that the correct columns are in dat.
if(length(which((c('POOL', 'LOCUS', 'PI', 'SD') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POOL, $LOCUS, $PI, and $SD.")
}
# --------------------------------------------+
# Internal function
# --------------------------------------------+
beta_est <- function(Mu, Var) {
# Estimates beta distribution shape params from the mean and variance of
# a sample.
#
# INPUTS:
#   Mu    (numeric)   The sample mean
#   Var   (numeric)   The sample variance
#
# OUTPUTS:
#   A list: $alpha = alpha param, $beta = beta param
# BEGIN ............
alpha <- ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2
beta <- alpha * (1 / Mu - 1)
return(params = list(alpha = alpha, beta = beta))
# ............ END
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get index for PI and SD
index.pi <- which(names(dat)=='PI'); index.sd <- which(names(dat)=='SD')
# Split the dataset on LOCUS
dat.spl <- split(dat, dat$LOCUS)
# This function works on each LOCUS
cat('Conducting parametric bootstrap on observed frequencies', sep='\n')
freq.sims <- pblapply(dat.spl, function(W){
# This function work on each POOL (i.e. the rows). Subset W so it only contains
# PI (columns = 1) and SD (column = 2)
Y <- apply(W[,c('POOL','LOCUS','PI','SD')], 1, function(X){
# Calculate the beta shape params (alpha and beta) from PI and SD (square SD to
# make it into variance).
beta.params <- beta_est(as.numeric(X['PI']), as.numeric(X['SD'])^2)
# Generate a vector of length num.sims of pi values from a beta distribution
# using the calculated shape params
pi.sims <- rbeta(num.sims, beta.params$alpha, beta.params$beta)
# Return the vector of simulated pi values.
return(data.table(POOL=X['POOL'], LOCUS=X['LOCUS']
, BOOT.NUM=1:num.sims, BOOT.PI=pi.sims))
})
# Return locus simulations
return(do.call('rbind', Y))
})
# Return final dataset
return(do.call('rbind', freq.sims))
# ................... END
}
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
pi.sims <- poolne_estim_boot_pi(pi.data, 100)
pi.sims
