colnames(dat)[col.index] <- c('POP','LOCUS','FREQ','INDS')
}
# --------------------------------------------+
# Internal functions
# --------------------------------------------+
# Variance components for FST from frequencies
FUN_varcomps_freqs <- function(pi, ni, r){
# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Output as data.table
data.table(NUMER=msp-msg, DENOM=msp+(nc-1)*msg)
}
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
# Variance components for FST from genotypes
FUN_fst_genos <- function(Dx){
left_join(
Dx[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
Dx[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')],
by=c('POP','LOCUS')
) %>%
left_join(
., Dx[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')], by=c('POP','LOCUS')
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
}
# Permute FST
FUN_fst_perm <- function(Dx, fst.genome, type, num.iters){
# Dx is a data table with $POP, $SAMPLE, $LOCUS, $GT.
# fst.genome is the genome-wide FST to test.
# num.iters is the number of iterations to perform.
perm.list <- list()
# Create a table to reshuffle populations
pop.perm.tab <- Dx[, c('POP','SAMPLE')] %>% unique
perm.results <- list()
# Iterate through i iterations
for(i in 1:num.iters){
# Reshuffle the populations in reference tbale
pop.perm.tab$POP <- sample(pop.perm.tab$POP, nrow(pop.perm.tab), replace=FALSE)
# Permute
perm.results[[i]] <- Dx %>%
# Subset the samples and their genotypes
.[, c('SAMPLE','LOCUS','GT')] %>%
# Add in the reshuffled populations
left_join(., pop.perm.tab, by='SAMPLE') %>%
# Calculate FST
FUN_fst_genos(.) %>%
.[, sum(NUMER)/sum(DENOM)]
rm(i)
}
# Results
perm.list$fst <- unlist(perm.results)
perm.list$pval <- sum(perm.list$fst>fst.genome)/num.iters
return(perm.list)
}
# --------------------------------------------+
# Code for genotypes
# --------------------------------------------+
if(type=='genos'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on genotype data, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- FUN_fst_genos(dat)
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# For genotype permutations
if(permute == TRUE){
cat('Performing permutations', '\n')
fstOutput$permute <- FUN_fst_perm(
Dx=dat, fst.genome=fstOutput$genome, type='genos', num.iters=num.iters)
} else{
fstOutput$permute <- NULL
}
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on genotype data, pairwise estimates', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
fstOutput$permute <- list(fst=list(), pval=list())
# START: Iterate over i pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
FUN_fst_genos(.) %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# If permuting
if(permute==TRUE){
cat('Performing permutation:', i, '/', num.pairs, '\n')
pair.perm <- FUN_fst_perm(
Dx=dat[POP %in% c(pop1, pop2)],
fst.genome=fstOutput$genome[[i]]$FST,
type='genos',
num.iters=num.iters
)
fstOutput$permute$fst[[i]] <- pair.perm$fst %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
fstOutput$permute$pval[[i]] <- data.table(
POP1=pop1, POP2=pop2, PVAL=pair.perm$pval
)
} else{
fstOutput$permute[[i]] <- NULL
}
rm(i)
# END: Iterate over i pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
if(!is.null(fstOutput$permute$fst)){
fstOutput$permute$fst <- do.call('rbind', fstOutput$permute$fst)
}
if(!is.null(fstOutput$permute$pval)){
fstOutput$permute$pval <- do.call('rbind', fstOutput$permute$pval)
}
# END: FST between population pairs
}
}
# --------------------------------------------+
# Code for frequencies
# --------------------------------------------+
if(type=='freqs'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on frequencydata, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- dat %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# No pemutations
fstOutput$permute <- NULL
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on frequencydata, global estimate', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
# START: Iterate over i population pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM] %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# END: Iteration over i population pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
fstOutput$permute <- NULL
# END: FST between pairwise populations
}
}
# --------------------------------------------+
# Output results
# --------------------------------------------+
return(fstOutput)
}
fst_calc <- function(
dat, type, popCol='POP', sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT',
freqCol='FREQ', indsCol='INDS', global=TRUE, pairwise=FALSE,
permute=FALSE, num.iters=100){
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
require(data.table); require(tidyverse)
# Make sure dat is a data.table
dat <- as.data.table(dat)
# Has type been specified correctly?
if(!type %in% c('genos','freqs')){
stop('Argument `type` must be one of "genos" or "freqs".')
}
# Check that global and pairwise are logicals
if(class(global)!='logical'){
stop('Argument `global` must be a logical value. See ?fst_calc.')
}
if(class(pairwise)!='logical'){
stop('Argument `pairwise` must be a logical value. See ?fst_calc.')
}
# Cannot specify bpth global and pairwise
if(global==TRUE & pairwise==TRUE){
stop('Arguments `global` and `pairwise` cannot both be TRUE. See ?fst_calc.')
}
# Must specify one of global or pairwise
if(global==FALSE & pairwise==FALSE){
stop('One of arguments `global` and `pairwise` must be TRUE. See ?fst_calc.')
}
# Check that permute is logical
if(class(permute)!='logical'){
stop('Argument `permute` must be a logical value. See ?fst_calc.')
}
# If permute is specified, then check num.iters is >0 and is an integer
if(permute==TRUE){
if(num.iters<1){
stop('Argument `num.iters` must be an integer >0. See ?fst_calc.')
}
num.iters <- as.integer(num.iters)
}
# Check all necessary columns are present and reassign values.
# If genotypes are character, convert to integers.
if(type=='genos'){
column.orig <- c(popCol,sampCol,locusCol,genoCol)
if(sum(column.orig %in% colnames(dat))!=4){
stop(
'Arguments `popCol`, `sampCol`, `locusCol`, and `genoCol` must all be
column names in `dat`. See ?fst_calc.')
}
col.index <- match(column.orig,colnames(dat))
colnames(dat)[col.index] <- c('POP','SAMPLE','LOCUS','GT')
if(class(dat$GT)=='character'){
dat$GT <- genoscore_converter(dat$GT)
}
}
if(type=='freqs'){
column.orig <- c(popCol,locusCol,freqCol,indsCol)
if(sum(column.orig %in% colnames(dat))!=4){
stop(
'Arguments `popCol`, `locusCol`, `freqCol`, and `indsCol`
must all be column names in `dat`. See ?fst_calc.')
}
col.index <- match(column.orig,colnames(dat))
colnames(dat)[col.index] <- c('POP','LOCUS','FREQ','INDS')
}
# --------------------------------------------+
# Internal functions
# --------------------------------------------+
# Variance components for FST from frequencies
FUN_varcomps_freqs <- function(pi, ni, r){
# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Output as data.table
data.table(NUMER=msp-msg, DENOM=msp+(nc-1)*msg)
}
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
# Variance components for FST from genotypes
FUN_fst_genos <- function(Dx){
left_join(
Dx[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
Dx[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')],
by=c('POP','LOCUS')
) %>%
left_join(
., Dx[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')], by=c('POP','LOCUS')
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
}
# Permute FST
FUN_fst_perm <- function(Dx, fst.genome, type, num.iters){
# Dx is a data table with $POP, $SAMPLE, $LOCUS, $GT.
# fst.genome is the genome-wide FST to test.
# num.iters is the number of iterations to perform.
perm.list <- list()
# Create a table to reshuffle populations
pop.perm.tab <- Dx[, c('POP','SAMPLE')] %>% unique
perm.results <- list()
# Iterate through i iterations
for(i in 1:num.iters){
# Reshuffle the populations in reference tbale
pop.perm.tab$POP <- sample(pop.perm.tab$POP, nrow(pop.perm.tab), replace=FALSE)
# Permute
perm.results[[i]] <- Dx %>%
# Subset the samples and their genotypes
.[, c('SAMPLE','LOCUS','GT')] %>%
# Add in the reshuffled populations
left_join(., pop.perm.tab, by='SAMPLE') %>%
# Calculate FST
FUN_fst_genos(.) %>%
.[, sum(NUMER)/sum(DENOM)]
rm(i)
}
# Results
perm.list$fst <- unlist(perm.results)
perm.list$pval <- sum(perm.list$fst>fst.genome)/num.iters
return(perm.list)
}
# --------------------------------------------+
# Code for genotypes
# --------------------------------------------+
if(type=='genos'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on genotype data, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- FUN_fst_genos(dat)
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# For genotype permutations
if(permute == TRUE){
cat('Performing permutations', '\n')
fstOutput$permute <- FUN_fst_perm(
Dx=dat, fst.genome=fstOutput$genome, type='genos', num.iters=num.iters)
} else{
fstOutput$permute <- NULL
}
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on genotype data, pairwise estimates', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
fstOutput$permute <- list(fst=list(), pval=list())
# START: Iterate over i pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
FUN_fst_genos(.) %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# If permuting
if(permute==TRUE){
cat('Performing permutation:', i, '/', num.pairs, '\n')
pair.perm <- FUN_fst_perm(
Dx=dat[POP %in% c(pop1, pop2)],
fst.genome=fstOutput$genome[[i]]$FST,
type='genos',
num.iters=num.iters
)
fstOutput$permute$fst[[i]] <- pair.perm$fst %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
fstOutput$permute$pval[[i]] <- data.table(
POP1=pop1, POP2=pop2, PVAL=pair.perm$pval
)
} else{
fstOutput$permute[[i]] <- NULL
}
rm(i)
# END: Iterate over i pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
if(!is.null(fstOutput$permute$fst)){
fstOutput$permute$fst <- do.call('rbind', fstOutput$permute$fst)
}
if(!is.null(fstOutput$permute$pval)){
fstOutput$permute$pval <- do.call('rbind', fstOutput$permute$pval)
}
# END: FST between population pairs
}
}
# --------------------------------------------+
# Code for frequencies
# --------------------------------------------+
if(type=='freqs'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on frequencydata, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- dat %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# No pemutations
fstOutput$permute <- NULL
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on frequencydata, global estimate', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
# START: Iterate over i population pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM] %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# END: Iteration over i population pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
fstOutput$permute <- NULL
# END: FST between pairwise populations
}
}
# --------------------------------------------+
# Output results
# --------------------------------------------+
return(fstOutput)
}
colnames(data_PoolFreqs)
fst_calc(
#'    data_PoolFreqs,
#'    type='freqs',
#'    global=FALSE,
#'    pairwise=TRUE,
#'    popCol='POOL'
#' )
#' freqPairs <- fst_calc(
#'    data_PoolFreqs,
#'    type='freqs',
#'    global=FALSE,
#'    pairwise=TRUE,
#'    popCol='POOL'
#' )
freqPairs
data_PoolFreqs
?fst_calc
fst_calc(
data_PoolFreqs,
type='freqs',
global=FALSE,
pairwise=TRUE,
popCol='POOL'
)
fst_calc(
data_PoolFreqs,
type='freqs',
global=FALSE,
pairwise=TRUE,
popCol='POOL'
)
library(genomalicious)
library(genomalicious)
# DAPC fit on all samples
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
library(genomalicious)
data("data_Genos")
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
# DAPC using training and testing partitions
DAPC.tt <- dapc_fit(data_Genos, pcPreds=3, method='train_test')
DAPC.fit
DAPC.fit %>% list
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?dapc_plot
