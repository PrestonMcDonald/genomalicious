START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
# Return
return(f.out)
}) %>% do.call('rbind', .)
featuresRepos
featuresDT
featuresRepos
featuresRepos[NAME=='COX1']
1:nrow(featuresDT)
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left. I.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
# Return
return(f.out)
featuresRepos <- lapply(1:nrow(featuresDT), function(f){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left. I.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
# Return
return(f.out)
}) %>% do.call('rbind', .)
featuresRepos <- list()
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left. I.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
# Add to list
featuresRepos[[f]] <- f.out
}
featuresRepos
featuresDT
featuresRepos[c(18,19)]
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
print(featuresDT$NAME[f])
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left. I.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
# Add to list
featuresRepos[[f]] <- f.out
}
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
print(featuresDT$NAME[f])
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left. I.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right. I.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
}
print(f.out)
# Add to list
featuresRepos[[f]] <- f.out
}
f=18
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
print(featuresDT$NAME[f])
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
f.is.split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.start.new.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
f.start.new.R
f.end.new.R
f.end.new.R
new_start_pos
f.is.split==TRUE
f.start > new_start_pos
f.end < new_start_pos
f.start
new_start_pos
f.start
size.init.R
size.init.L
f.start - size.init.L + 1
f.start - size.init.L
f.start - size.init.L
f.end - size.init.L
featuresDT[f, !c('START', 'END')]
featuresDT[f, END-START]
featuresDT[f]
f.start - size.init.L
f.end - size.init.L
featuresRepos <- list()
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
print(featuresDT$NAME[f])
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left, i.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right, i.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
} else if(f.start == new_start_pos){
# If the features starts at the new start position, i.e. original feature
# start == new seq start feature.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
}
print(f.out)
# Add to list
featuresRepos[[f]] <- f.out
}
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left, i.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right, i.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
} else if(f.start == new_start_pos){
# If the features starts at the new start position, i.e. original feature
# start == new seq start feature.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
}
f.out$NAME == featuresDT$NAME[f]
# Add to list
featuresRepos[[f]] <- f.out
}
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left, i.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right, i.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
} else if(f.start == new_start_pos){
# If the features starts at the new start position, i.e. original feature
# start == new seq start feature.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
}
print(f.out$NAME == featuresDT$NAME[f])
# Add to list
featuresRepos[[f]] <- f.out
}
# Iterate through each row of the original features data table
for(f in 1:nrow(featuresDT)){
# Get the original positions
f.start <- featuresDT$START[f]
f.end <- featuresDT$END[f]
# Will the feature need to be split? I.e. is the original feature start <
# new seq start, and is the original feature end > new seq start?
f.is.split <- new_start_pos > f.start & new_start_pos < f.end
# Code for handling different scenarios
if(f.is.split==TRUE){
# If the feature needs to be split
# New left region
f.start.new.L <- new_start_pos - size.init.L
f.end.new.L <- f.end - size.init.L
# New right region
f.start.new.R <- f.start + size.init.R
f.end.new.R <- (new_start_pos - 1) + size.init.R
# Output
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=c(f.start.new.L, f.start.new.R),
END=c(f.end.new.L, f.end.new.R),
REPOS=c('Split, left region', 'Split, right region')
)
} else if(f.start > new_start_pos){
# If the feature is shifted left, i.e. Original feature start > new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
} else if(f.end < new_start_pos){
# If the feature is shifted right, i.e. Original feature end < new seq start.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start + size.init.R,
END=f.end + size.init.R,
REPOS='Repositioned right'
)
} else if(f.start == new_start_pos){
# If the features starts at the new start position, i.e. original feature
# start == new seq start feature.
f.out <- data.table(
featuresDT[f, !c('START', 'END')],
START=f.start - size.init.L,
END=f.end - size.init.L,
REPOS='Repositioned left'
)
}
# Add to list
featuresRepos[[f]] <- f.out
}
featuresRepos <- do.call('rbind', featuresRepos)
featuresRepos
featuresDT[, END-START]
featuresDT[, END-START]==featuresRepos[, END-START]
gbk.read[NAME=='COX1']
mean(c(7048, 5495))
reposMidCOX1 <- mitogenome_feat_repos(
featuresDT=gbk.read,
new_start_pos=6272,
feat_base_zero=FALSE,
genome_len=16692
)
reposMidCOX1
reposMidCOX1[NAME=='COX1']
(777-1) + (16692-15916)
roxygenise()
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?mitogenome_feat_repos
