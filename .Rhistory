return(vcfRow)
}))
vcf4pops
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath) %>%  head
readLines(vcfPath) %>%  tail
readVcf1 <- vcf2DT(vcfFile=vcfPath)
readVcf1
readVcf1
readVcf1
vcfFile<- vcfPath
dropCols=NULL
keepComments=FALSE
keepInfo=FALSE
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table); require(tidyverse)
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT
fread(vcfFile, skip=headPos-1, header=TRUE)
tail(readLines(vcfPath))
vcfPath
'C:\Users/thiaj/Dropbox/AGPIP/2. Projects/Project 5. Molecular Markers/RLEM/OP_Resistance/2022_Pool_WGS_Popgenom_JEB/Analyses/99b_Merged_Variant_Calls/RLEM_merge_snps_dp20_miss0.recode.vcf'
'C:/Users/thiaj/Dropbox/AGPIP/2. Projects/Project 5. Molecular Markers/RLEM/OP_Resistance/2022_Pool_WGS_Popgenom_JEB/Analyses/99b_Merged_Variant_Calls/RLEM_merge_snps_dp20_miss0.recode.vcf'
'C:/Users/thiaj/Dropbox/AGPIP/2. Projects/Project 5. Molecular Markers/RLEM/OP_Resistance/2022_Pool_WGS_Popgenom_JEB/Analyses/99b_Merged_Variant_Calls/RLEM_merge_snps_dp20_miss0.recode.vcf' %>%
readLines(.) %>%
tail()
DD <- vcf2DT('C:/Users/thiaj/Dropbox/AGPIP/2. Projects/Project 5. Molecular Markers/RLEM/OP_Resistance/2022_Pool_WGS_Popgenom_JEB/Analyses/99b_Merged_Variant_Calls/RLEM_merge_snps_dp20_miss0.recode.vcf')
DD
DD
vcf4pops <- do.call('rbind', lapply(unique(data_4pops$LOCUS), function(locus){
X <- data_4pops[LOCUS==locus]
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
vcfPools <- vcf4pops <- do.call('rbind', lapply(unique(data_PoolFreqs$LOCUS), function(locus){
X <- data_PoolFreqs[LOCUS==locus] %>%
copy %>%
.[, GT:='0/1']
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','POOL')] %>%
dcast(., LOCUS ~ POOL, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcfPools, 'inst/extdata/data_poolseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_poolseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_poolseq.vcf')
vcf4pops <- do.call('rbind', lapply(unique(data_4pops$LOCUS), function(locus){
X <- data_4pops[LOCUS==locus]
X[, GT:=genoscore_converter(GT)]
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
vcfPools <- vcf4pops <- do.call('rbind', lapply(unique(data_PoolFreqs$LOCUS), function(locus){
X <- data_PoolFreqs[LOCUS==locus] %>%
copy %>%
.[, GT:='0/1']
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','POOL')] %>%
dcast(., LOCUS ~ POOL, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcfPools, 'inst/extdata/data_poolseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_poolseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_poolseq.vcf')
vcfPath
readLines(vcfPath) %>% tail
X <- data_4pops[LOCUS==locus]
X[, GT:=genoscore_converter(GT)]
X
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
vcfRow
# Make a VCF from 4 pop genotypes
vcf4pops <- do.call('rbind', lapply(unique(data_4pops$LOCUS), function(locus){
X <- data_4pops[LOCUS==locus]
X[, GT:=genoscore_converter(GT)]
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
vcf4pops
vcf4pops
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
readLines(vcfPath) %>%  head
readLines(vcfPath) %>%  tail
readVcf1 <- vcf2DT(vcfFile=vcfPath)
readVcf1
readVcf1
readVcf1
readVcf1 %>% print()
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
fread(vcf4pops)
fread(vcf4pops, sep='\t')
fread(vcfPath, sep='\t')
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
fread('inst/extdata/data_indseq.vcf')
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
vcf2DT('inst/extdata/data_indseq.vcf')
vcf2DT('inst/extdata/data_indseq.vcf') -> DD
DD
DD %>% print
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
# Load currently installed genomalicious
library(genomalicious)
# Make the 4 pop genotype dataset
fsc_genos <- fread('inst/extdata/fsc2_radseq_sim_1_1.gen', skip=1)
fsc_head <- colnames(fread('inst/extdata/fsc2_radseq_sim_1_1.gen', nrow=0))
fsc_tab <- fsc_genos[, 1:(ncol(fsc_genos)-1)] %>%
setnames(., new=fsc_head) %>%
setnames(
.,
old=c('Chrom','Pos','Anc_all','Der_all'),
new=c('CHROM','POS','REF','ALT')
) %>%
melt(
.,
id.vars=c('CHROM','POS','REF','ALT'),
variable.name='SAMPLE',
value.name='GT'
) %>%
.[, SAMPLE:=as.character(SAMPLE)] %>%
.[, SAMPLE:=sub('A_', 'Ind', SAMPLE)] %>%
.[, POP:=sub('Ind', 'Pop', sub('\\_.*', '', SAMPLE))] %>%
.[, CHROM:=paste0('Contig', CHROM)] %>%
.[, LOCUS:=paste(CHROM, POS, sep='_')] %>%
.[, c('CHROM','POS','LOCUS','POP','SAMPLE','GT')] %>%
print
fsc_tab[, length(unique(LOCUS)), by=CHROM]$V1 %>%  table
keep.loci <- fsc_tab[LOCUS %in% filter_maf(fsc_tab, type='genos', maf=0.05)]$LOCUS %>%
unique() %>% .[1:200]
fsc_tab[LOCUS %in% keep.loci, length(unique(LOCUS)), by=CHROM]$V1 %>%  table
fsc_tab[GT=='1/0', GT:='0/1']
data_4pops <- fsc_tab[LOCUS %in% keep.loci] %>%
.[, DP:=rnbinom(n=1, size=15, prob=0.3), by=c('CHROM','SAMPLE')] %>%
.[, AO:=rbinom(n=1, size=DP, prob=0.5), by=c('CHROM','SAMPLE')] %>%
.[, RO:=DP-AO]
locs_4pops <- data_4pops[, c('LOCUS')] %>% unique()
locs_4pops <- cbind(
locs_4pops,
sapply(1:nrow(locs_4pops), function(i){
sample(c('T','A','C','G'), 2, replace=FALSE)
}) %>%
t() %>%
as.data.table() %>%
setnames(., new=c('ALT','REF'))
)
data_4pops <- left_join(data_4pops, locs_4pops)
data_4pops %>%  pca_genos(., popCol='POP') %>%  pca_plot
save(data_4pops, file='data/data_4pops.RData')
# Make pool data
data_PoolFreqs <- data_4pops %>%
.[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('CHROM','POS','LOCUS','ALT','REF','POP')] %>%
.[, DP:=rnbinom(1, 20, prob=0.2), by=c('POP','CHROM','LOCUS')] %>%
.[, AO:=rbinom(n=1, size=DP, prob=FREQ)] %>%
.[, RO:=DP-AO] %>%
setnames(., old='POP', new='POOL') %>%
.[, INDS:=30]
save(data_PoolFreqs, file='data/data_PoolFreqs.RData')
# Make pool info data
data_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(data_PoolInfo, file='data/data_PoolInfo.RData')
# Make a frequency matrix
data_FreqsMat <- data_PoolFreqs %>%
dcast(., POOL~LOCUS, value.var='FREQ') %>%
as.data.frame() %>%
column_to_rownames(., 'POOL') %>%
as.matrix()
save(data_FreqsMat,file='data/data_FreqsMat.RData')
# Make VCFs
vcf_head <- "##This is a toy dataset for the R package genomalicious - it emulates a VCF file
##INFO=<ID=DP,Number=1,Type=Integer,Description='The total depth across samples'>
##FORMAT=<ID=GT,Number=1,Type=String,Description='Genotype'>
##FORMAT=<ID=DP,Number=1,Type=Integer,Description='The total depth in a sample'>
##FORMAT=<ID=RO,Number=1,Type=Integer,Description='The reference allele counts in a sample'>
##FORMAT=<ID=AO,Number=1,Type=Integer,Description='The alternate allele counts in a sample'>"
# Make a VCF from 4 pop genotypes
vcf4pops <- do.call('rbind', lapply(unique(data_4pops$LOCUS), function(locus){
X <- data_4pops[LOCUS==locus]
X[, GT:=genoscore_converter(GT)]
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','SAMPLE')] %>%
dcast(., LOCUS ~ SAMPLE, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_indseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_indseq.vcf')
vcfPools <- vcf4pops <- do.call('rbind', lapply(unique(data_PoolFreqs$LOCUS), function(locus){
X <- data_PoolFreqs[LOCUS==locus] %>%
copy %>%
.[, GT:='0/1']
vcfRow <- data.table(
CHROM=X$CHROM[1],
POS=X$POS[1],
REF=X$REF[1],
ALT=X$ALT[1],
INFO=paste0('DP=', sum(X$DP)),
QUAL=30,
FORMAT='GT:DP:RO:AO',
X[, paste(GT,DP,RO,AO,sep=":"), by=c('LOCUS','POOL')] %>%
dcast(., LOCUS ~ POOL, value.var='V1') %>%
.[, !'LOCUS']
)
setnames(vcfRow, 'CHROM', '#CHROM')
return(vcfRow)
}))
fwrite(vcfPools, 'inst/extdata/data_poolseq.vcf', sep='\t', quote=FALSE)
readLines('inst/extdata/data_poolseq.vcf') %>%
c(vcf_head, .) %>%
writeLines(., 'inst/extdata/data_poolseq.vcf')
roxygenise()
library(genomalicious)
# Create a link to raw external datasets in genomalicious
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath) %>%  head
readLines(vcfPath) %>%  tail
readVcf1 <- vcf2DT(vcfFile=vcfPath)
readVcf1 %>% print()
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('FILTER', 'ID')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2 <- vcf2DT(vcfPath
, dropCols=c('QUAL')
, keepComments=TRUE
, keepInfo=TRUE)
readVcf2 %>% print
attr(readVcf2, 'vcf_comments')
attr(readVcf2, 'vcf_info')
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
library(genomalicious)
data("data_4pops")
data_4pops
X <- data_4pops %>%
copy %>%
.[, c('SAMPLE','POP')] %>%
unique()
X
Xdat <- data_4pops %>%
copy %>%
.[, c('SAMPLE','POP')] %>%
unique()
Ydat
Xdat <- data_4pops %>%
copy %>%
.[, c('SAMPLE','POP')] %>%
unique()
Ydat <- data_4pops
sampCol <- 'SAMPLE'
Ydat
genoCol <- 'GT'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Check that scaling is specified
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument `scaling`` is invalid. See: ?pca_genos')
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Get the class of the genotypes
gtClass <- class(Ydat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele. See: ?pca_genos")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
Ydat[[genoCol]] <- genoscore_converter(Ydat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
if(type=='genos'){
Ymat <- DT2Mat_genos(Ydat, sampCol=sampCol, genoCol=genoCol, locusCol=locusCol)
}
Ymat <- DT2Mat_genos(Ydat, sampCol=sampCol, genoCol=genoCol, locusCol=locusCol)
sampCol <- 'SAMPLE'
locusCol <- 'LOCUS'
genoCol <- 'GT'
type='genos'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
Ymat <- DT2Mat_genos(Ydat, sampCol=sampCol, genoCol=genoCol, locusCol=locusCol)
Ymat
rownames(Ymat)
samp.vec <- rownames(Ymat)
match(samp.vec, Xdat[[sampCol]])
samp.vec
match(samp.vec, Xdat[[sampCol]])
sampCol[match(samp.vec, Xdat[[sampCol]]),]
match(samp.vec, Xdat[[sampCol]])
Xdat[match(samp.vec, Xdat[[sampCol]]),]
Xdat <- Xdat[match(samp.vec, Xdat[[sampCol]]),]
Xdat
predFormula <- 'POP'
predFormula
rdaFormula <- paste0('Ymat ~ ', predFormula)
rdaFormula
eval(parse(text=rdaFormula))
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat)')
rdaFormula
eval(parse(text=rdaFormula))
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr', 'vegan')){ require(lib, character.only = TRUE)}
eval(parse(text=rdaFormula))
RDA <- eval(parse(text=rdaFormula))
RDA
RDAobj <- eval(parse(text=rdaFormula))
RDAobj
RDAobj %>%  plot
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, center=FALSE, scale=FALSE)')
RDAobj <- eval(parse(text=rdaFormula))
RDAobj %>%  plot
RDAobj
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat)')
RDAobj <- eval(parse(text=rdaFormula))
RDAobj
?rda
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, scale=FALSE)')
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, scale=TRUE)')
RDAobj <- eval(parse(text=rdaFormula))
RDAobj %>%  plot
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, scale=FALSE)')
RDAobj <- eval(parse(text=rdaFormula))
RDAobj %>%  plot
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
?dadi_inputs_pools
?dadi_inputs_pools
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
?dadi_inputs_freqs()
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?dadi_inputs_freqs
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
