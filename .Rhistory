, mat_patchy=genomalicious_PatchyGTs
, sampCol='SAMPLE'
, locusCol='LOCUS'
, genoCol='GT'
)
# Take a look at the output.
# Histograms are ordered with samples in the first
# row and loci in the second row. The first column
# is the observed clean data, the second column
# is the simulated missing data, and the thir column
# is the missing data in the patchy guide matrix.
par(mfrow=c(2,3))
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Obs clean: Samples', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Sim patchy: Samples', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 1
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Samples', xlab='% missing')
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Obs clean: Loci', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Sim patchy: Loci', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 2
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Loci', xlab='% missing')
par(mfrow=c(1,1))
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
#' Simulate missing data with a specified strcuture
#'
#' Takes a long format data table of genotypes that
#' has no missing data (clean) and simulates a missing data
#' analogous to a pathcy matrix used as a guide.
#'
#' @param dat_clean Data table: Must be in long format and contains
#' no missing data (i.e. it is "clean"). Genotypes can be coded as
#' '/' separated characters or a integers. Must contain the following
#' columns:
#' \enumerate{
#'    \item The sampled individual ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The genotype (see param \code{genoCol}).
#' }
#'
#' @param mat_patchy Matrix: Samples in rows, loci in columns.
#' This is meant to simulate a genotype matrix with missing data
#' (i.e. it is "patchy"), but the the actual contents of the matrix
#' can be anything, as long as missing values are coded by \code{NA}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @details The number of samples and loci in the guide matrix, \code{mat_patchy}
#' does not have to be equal \code{dat_clean}. In the simulations, the rows and
#' columns of \code{mat_patchy} are randomly sampled (with replacement) to create
#' a bootstrap simulated  missing data structure of the same dimensions as the
#' observed clean data. This simulated missing data structure is then used to
#' modify the observed clean data. \cr
#' \cr
#' NOTE: This method is blind to population, so will simulate
#' missing data across individuals. Therefore, if missing data exhibits
#' population structuring, it would be necessary to subset the clean dataset
#' by population and run specific simulations per population, then combine
#' all the simulated subsets.
#'
#' @values A data table with the same dimensions as \code{dat_clean}, but
#' genotypes will be knocked out to reproduce a data structure anologous to
#' that specified in \code{mat_patchy}. If genotypes were initially coded
#' as characters, the missing genotypes will be coded as './.'; if they were
#' initially coded as integers, they will be coded as \code{NA}.
#'
#' @examples
#' library(data.table)
#' data(genomalicious_PatchyGTs)
#' data(genomalicious_4pops)
#'
#' # Take a look at the patchy dataset
#' genomalicious_PatchyGTs
#'
#' # Simulate missing data structure
#' patchy4pops <- miss_sim_structure(
#'     dat_clean=genomalicious_4pops
#'     , mat_patchy=genomalicious_PatchyGTs
#'     , sampCol='SAMPLE'
#'     , locusCol='LOCUS'
#'     , genoCol='GT'
#' )
#'
#' # Take a look at the output.
#' # Histograms are ordered with samples in the first
#' # row and loci in the second row. The first column
#' # is the observed clean data, the second column
#' # is the simulated missing data, and the thir column
#' # is the missing data in the patchy guide matrix.
#' par(mfrow=c(2,3))
#' hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
#'     , 100, xlim=c(0,1), main='Obs clean: Samples', xlab='% missing')
#'
#' hist(patchy4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
#'     , 100, xlim=c(0,1), main='Sim patchy: Samples', xlab='% missing')
#'
#' hist(
#'     unlist(
#'         apply(genomalicious_PatchyGTs
#'            , 1
#'            , function(i){sum(is.na(i))/length(i)}))
#'     , 100, xlim=c(0,1), main='Guide patchy: Samples', xlab='% missing')
#'
#' hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
#'     , 100, xlim=c(0,1), main='Obs clean: Loci', xlab='% missing')
#'
#' hist(patchy4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
#'     , 100, xlim=c(0,1), main='Sim patchy: Loci', xlab='% missing')
#'
#' hist(
#'     unlist(
#'         apply(genomalicious_PatchyGTs
#'            , 2
#'            , function(i){sum(is.na(i))/length(i)}))
#'     , 100, xlim=c(0,1), main='Guide patchy: Loci', xlab='% missing')
#' par(mfrow=c(1,1))
#'
#'
#' @export
#'
miss_sim_structure <- function(dat_clean, mat_patchy
, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'tidyr', 'plyr')){ require(lib, character.only=TRUE)}
# Genotype column class
gt_class <- class(dat_clean[[genoCol]])
if(gt_class=='numeric'){
dat_clean[[genoCol]] <- as.integer(dat_clean[[genoCol]])
}
if(gt_class!='character'){
dat_clean[[genoCol]] <- genoscore_converter(dat_clean[[genoCol]])
}
# Check the column arguments are specified
if(sum(length(c(sampCol, locusCol, genoCol) %in% colnames(dat_clean)))!=3){
stop('Required columns not in `dat_clean`: see ?miss_sim_structure')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Sampling parameters
nloci <- length(unique(dat_clean[[locusCol]]))
nsamps <- length(unique(dat_clean[[sampCol]]))
# Make a bootstrap missing dataset to have the
# same number of loci and samples as in observed dataset, `dat_clean`
mat_boot <- mat_patchy[
sample(x=1:nrow(mat_patchy), size=nsamps, replace=TRUE)
, sample(x=1:ncol(mat_patchy), size=nloci, replace=TRUE)
]
# The simulated missing dataset:
# Start with the original, convert to a wide format matrix, then
# add in missing values that match positions in `mat_boot`
mat_sim <- DT2Mat_genos(
dat_clean
, sampCol='SAMPLE'
, locusCol='LOCUS'
, genoCol='GT')
mat_sim[which(is.na(mat_boot))] <- './.'
# Convert the simulated dataset back into a long format data table.
# Then subset to only include sample/loci combinations with missing data.
ko_genos <- DT2Mat_genos(
mat_sim
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, flip=TRUE)[GT=='./.']
# Make a copy of the clean dataset
dat_sim <- copy(dat_clean)
# Unique identifiers for each sample/locus combination in the
# simulated and observed datasets
ko_genos$SAMPLE.LOCUS <- paste(ko_genos$SAMPLE, ko_genos$LOCUS, sep='/')
dat_sim$SAMPLE.LOCUS <- paste(dat_sim[[sampCol]], dat_sim[[locusCol]], sep='/')
# Get the index of the missing sample/loci combinations in the
# observed dataset, then knock 'em out.
ko_indx <- match(ko_genos$SAMPLE.LOCUS, dat_sim$SAMPLE.LOCUS)
dat_sim[ko_indx, genoCol] <- './.'
# Convert genotypes back to integer if that was the original specification
if(gt_class %in% c('numeric', 'integer')){
dat_clean[[genoCol]] <- genoscore_converter(dat_clean[[genoCol]])
}
# Return
return(dat_sim)
}
#' @examples
#' library(data.table)
#' data(genomalicious_PatchyGTs)
#' data(genomalicious_4pops)
#'
#' # Take a look at the patchy dataset
#' genomalicious_PatchyGTs
#'
#' # Simulate missing data structure
#' patchy4pops <- miss_sim_structure(
#'     dat_clean=genomalicious_4pops
#'     , mat_patchy=genomalicious_PatchyGTs
#'     , sampCol='SAMPLE'
#'     , locusCol='LOCUS'
#'     , genoCol='GT'
#' )
#'
#' # Take a look at the output.
#' # Histograms are ordered with samples in the first
#' # row and loci in the second row. The first column
#' # is the observed clean data, the second column
#' # is the simulated missing data, and the thir column
#' # is the missing data in the patchy guide matrix.
#' par(mfrow=c(2,3))
#' hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
#'     , 100, xlim=c(0,1), main='Obs clean: Samples', xlab='% missing')
#'
#' hist(patchy4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
#'     , 100, xlim=c(0,1), main='Sim patchy: Samples', xlab='% missing')
#'
#' hist(
#'     unlist(
#'         apply(genomalicious_PatchyGTs
#'            , 1
#'            , function(i){sum(is.na(i))/length(i)}))
#'     , 100, xlim=c(0,1), main='Guide patchy: Samples', xlab='% missing')
#'
#' hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
#'     , 100, xlim=c(0,1), main='Obs clean: Loci', xlab='% missing')
#'
#' hist(patchy4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
#'     , 100, xlim=c(0,1), main='Sim patchy: Loci', xlab='% missing')
#'
#' hist(
#'     unlist(
#'         apply(genomalicious_PatchyGTs
#'            , 2
#'            , function(i){sum(is.na(i))/length(i)}))
#'     , 100, xlim=c(0,1), main='Guide patchy: Loci', xlab='% missing')
#' par(mfrow=c(1,1))
library(data.table)
data(genomalicious_PatchyGTs)
data(genomalicious_4pops)
# Take a look at the patchy dataset
genomalicious_PatchyGTs
# Simulate missing data structure
patchy4pops <- miss_sim_structure(
dat_clean=genomalicious_4pops
, mat_patchy=genomalicious_PatchyGTs
, sampCol='SAMPLE'
, locusCol='LOCUS'
, genoCol='GT'
)
# Take a look at the output.
# Histograms are ordered with samples in the first
# row and loci in the second row. The first column
# is the observed clean data, the second column
# is the simulated missing data, and the thir column
# is the missing data in the patchy guide matrix.
par(mfrow=c(2,3))
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Obs clean: Samples', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Sim patchy: Samples', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 1
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Samples', xlab='% missing')
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Obs clean: Loci', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Sim patchy: Loci', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 2
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Loci', xlab='% missing')
par(mfrow=c(1,1))
library(data.table)
data(genomalicious_PatchyGTs)
data(genomalicious_4pops)
# Take a look at the patchy dataset
genomalicious_PatchyGTs
# Simulate missing data structure
patchy4pops <- miss_sim_structure(
dat_clean=genomalicious_4pops
, mat_patchy=genomalicious_PatchyGTs
, sampCol='SAMPLE'
, locusCol='LOCUS'
, genoCol='GT'
)
library(genomalicious)
patchy4pops <- miss_sim_structure(
dat_clean=genomalicious_4pops
, mat_patchy=genomalicious_PatchyGTs
, sampCol='SAMPLE'
, locusCol='LOCUS'
, genoCol='GT'
)
par(mfrow=c(2,3))
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Obs clean: Samples', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=SAMPLE]$V1
, 100, xlim=c(0,1), main='Sim patchy: Samples', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 1
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Samples', xlab='% missing')
hist(genomalicious_4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Obs clean: Loci', xlab='% missing')
hist(patchy4pops[, sum(GT=='./.')/length(GT), by=LOCUS]$V1
, 100, xlim=c(0,1), main='Sim patchy: Loci', xlab='% missing')
hist(
unlist(
apply(genomalicious_PatchyGTs
, 2
, function(i){sum(is.na(i))/length(i)}))
, 100, xlim=c(0,1), main='Guide patchy: Loci', xlab='% missing')
par(mfrow=c(1,1))
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
library(genomalicious)
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
X
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
dat <- X
pool.info <- genomalicious_PoolInfo
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'LOCUS', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $LOCUS, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
aoMat <- spread(data=dat[, c('LOCUS', 'POOL', 'AO')], key=POOL, value=AO)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
aoMat
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X
dat
dat$DP <- dat$AO + dat$RO
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
dpMat
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X@readcoverage <- as.matrix(dpMat[, !'LOCUS'], rownames=dpMat$LOCUS)
X@snp.info <- as.matrix(loci)
X@poolsizes <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$INDS * 2
X@poolnames <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$POOL
Fst=computeFST(X, method=method, snp.index=snp.index)
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$AO} The number of reads supporting the alternate allele.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @param method Character: Either 'Anova' (default) or 'Identity'. Passed to \code{method} argument
#' in \code{poolfstat::computeFST}.
#'
#' @param snp.index List: A list of SNPs to consider. Default = \code{NA}.
#' Passed to \code{snp.index} argument in \code{poolfstat::computeFST}.
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(genomalicious_PoolInfo)
#' data(genomalicious_PoolReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' Y <- poolfstat_DT(X, genomalicious_PoolInfo)
#'
#' # Output is a list
#' class(Y)
#'
#' # Outout from poolfstat::computeFST
#' Y$Fst
#'
#' # The pooldata class object, generated from data table of pooled reads
#' class(Y$pooldat)
#' Y$pooldat
#'
#'@export
poolfstat_DT <- function(dat, pool.info, method='Anova', snp.index=NA){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'LOCUS', 'POOL', 'AO', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $LOCUS, $POOL, $AO, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
dat$DP <- dat$AO + dat$RO
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X@readcoverage <- as.matrix(dpMat[, !'LOCUS'], rownames=dpMat$LOCUS)
X@snp.info <- as.matrix(loci)
X@poolsizes <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$INDS * 2
X@poolnames <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$POOL
return(list(Fst=computeFST(X, method=method, snp.index=snp.index), pooldat=X))
rm(X)
}
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
X
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
# Subset to keep only Rep1 reads.
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
# Need to add pool ID.
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
Y
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
