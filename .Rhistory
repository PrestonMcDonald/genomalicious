#' Conduct a PCA on individual genotypes stored in a (long) data table
#'
#' Takes a long data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function. Different options for scaling the genotypes
#' pre-PCA are available.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled?
#' Set to \code{'covar'} to scale to mean = 0, but variance is not
#' adjusted, i.e. PCA on a covariance matrix. Set to \code{'corr'}
#' to scale to mean = 0 and variance = 1, i.e. PCA on a
#' correlation matrix. Set to \code{'patterson'} to use the
#' Patteron et al. (2006) normalisation. Set to \code{'none'} to
#' if you do not want to do any scaling before PCA.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @return Returns a \code{prcomp} object. If argumet \code{popCols} was specified,
#' and additional index of \code{$pops} is also also present.
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' # Data
#' data(genomalicious_4pops)
#' datGt <- genomalicious_4pops
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot(pca)
#'
#' @export
pca_DTgenos <- function(dat, scaling='covar', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', popCol=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# Get individuals in rows
sampRows <- rownames(genoMat)
# The PCA
if(scaling=='covar'){
pca <- prcomp(genoMat, center=TRUE, scale=FALSE)
} else if(scaling=='corr'){
pca <- prcomp(genoMat, center=TRUE, scale=TRUE)
} else if(scaling=='patterson'){
pca <- prcomp(normalise_patterson(genoMat), center=FALSE, scale=FALSE)
pca$scale <- 'Patterson et al. (2006)'
}
rownames(genoMat) <- sampRows
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- unique(popMems)
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(sampRows, popMems[[sampCol]])]
}
return(pca)
# ........... END
}
data(genomalicious_4pops)
datGt <- genomalicious_4pops
pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
pca$pops
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1'), or counts
#' of the Ref alleles e.g. (0, 1, 2).
#' Three columns are required:
#' \enumerate{
#'    \item The sampled individual ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The genotype (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @param genoScore Character: Should the returned genotypes by represented as
#' \code{'counts'} of the Ref allele (integer from 0 -> 2), or separated alleles,
#' \code{'sep'} (character, '0/0', '0/1', or '1/1')? Default = \code{'sep'}.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and genotypes in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a genotype matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{GT},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomalicious_4pops)
#' datGt <- genomalicious_4pops[LOCUS %in% unique(genomalicious_4pops$LOCUS)[1:8]]
#'
#' # Convert a long data table to a wide matrix
#' genoMatSep <- DT2Mat_genos(datGt
#'               , sampCol='SAMPLE'
#'               , locusCol='LOCUS'
#'               , genoCol='GT'
#'               , flip=FALSE)
#'
#' genoMatCounts <- DT2Mat_genos(datGt
#'               , sampCol='SAMPLE'
#'               , locusCol='LOCUS'
#'               , genoCol='GT'
#'               , genoScore='counts'
#'               , flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' genoDTSep <- DT2Mat_genos(genoMatSep
#'               , sampCol='SAMPLE'
#'               , locusCol='LOCUS'
#'               , genoCol='GT'
#'               , genoScore='sep'
#'               , flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='sep', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must take the values of either 'counts' or 'sep'.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# Evaluate the genotype data type.
# genoInitClass stores the initial genotype score information.
if(flip==FALSE){
genoInitClass <- class(dat[[genoCol]])
} else if(flip==TRUE){
genoInitClass <- class(dat[, 1])
}
if(!genoInitClass %in% c('character', 'integer', 'numeric')){
stop('Genotypes must be either a character or integer class.')
}
# If genotypes counts are numerics, convert to integers.
if(genoInitClass=='numeric'){
if(class(dat)[1]=='data.table'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
} else if(class(dat=='matirx')){
dat <- apply(dat, 2, as.integer)
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep' & genoInitClass=='character'){
return(genoMat)
} else if(genoScore=='counts' & genoInitClass=='integer'){
return(genoMat)
} else if(genoScore=='counts' & genoInitClass=='character'){
genoMat <- apply(genoMat, 2, genoscore_converter)
row.names(genoMat) <- sampVals
return(genoMat)
} else if(genoScore=='sep' & genoInitClass=='integer'){
genoMat <- apply(genoMat, 2, genoscore_converter)
row.names(genoMat) <- sampVals
return(genoMat)
}
}
if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
# Adjust genotype score?
if(genoScore=='sep' & genoInitClass=='character'){
return(genoDT)
} else if(genoScore=='counts' & genoInitClass=='integer'){
return(genoDT)
} else if(genoScore=='counts' & genoInitClass=='character'){
genoDT$GT <- genoscore_converter(genoDT$GT)
return(genoDT)
} else if(genoScore=='sep' & genoInitClass=='integer'){
genoDT$GT <- genoscore_converter(genoDT$GT)
return(genoDT)
}
}
}
#' Conduct a PCA on individual genotypes stored in a (long) data table
#'
#' Takes a long data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function. Different options for scaling the genotypes
#' pre-PCA are available.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled?
#' Set to \code{'covar'} to scale to mean = 0, but variance is not
#' adjusted, i.e. PCA on a covariance matrix. Set to \code{'corr'}
#' to scale to mean = 0 and variance = 1, i.e. PCA on a
#' correlation matrix. Set to \code{'patterson'} to use the
#' Patteron et al. (2006) normalisation. Set to \code{'none'} to
#' if you do not want to do any scaling before PCA.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @return Returns a \code{prcomp} object. If argumet \code{popCols} was specified,
#' and additional index of \code{$pops} is also also present.
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' # Data
#' data(genomalicious_4pops)
#' datGt <- genomalicious_4pops
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot(pca)
#'
#' @export
pca_DTgenos <- function(dat, scaling='covar', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', popCol=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# Get individuals in rows
sampRows <- rownames(genoMat)
# The PCA
if(scaling=='covar'){
pca <- prcomp(genoMat, center=TRUE, scale=FALSE)
} else if(scaling=='corr'){
pca <- prcomp(genoMat, center=TRUE, scale=TRUE)
} else if(scaling=='patterson'){
pca <- prcomp(normalise_patterson(genoMat), center=FALSE, scale=FALSE)
pca$scale <- 'Patterson et al. (2006)'
}
rownames(genoMat) <- sampRows
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- unique(popMems)
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(sampRows, popMems[[sampCol]])]
}
return(pca)
# ........... END
}
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
grps <- list(A=c(1:101), B=c(20:100, 101:120), C=c(1:50, 70:120))
sig <- list(A=c(1,8,88), B=c(88, 101), C=c(88, 102, 118, 120))
lociList=grps
lociSig=sig
perms=1000
# Number of gorups
numGrps <- length(lociSig)
# Group names
grpNames <- names(lociSig)
# Counts of significant loci
sigCount <- table(unlist(lociSig))
# The observed number of loci shared among all groups
obsShares <- length(sigCount[sigCount==numGrps])
# Number of significant loci per group
numSigs <- lapply(lociSig, length)
sigCount
obsShares
numSigs
i <- 1
grpNames
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm
sharePerm <- table(sharePerm)
sharePerm
# Permutations
permDat <- lapply(1:perms, function(i){
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm <- table(sharePerm)
return(sum(sharePerm==numGrps))
})
permDat
permDat <- unlist(permDat)
permDat
# p-value: Numbers of perms with shares >= observed, divided by number of perms
p <- sum(permDat > obsShares)/perms
p
#' Proability of random null overlap among groups for outlier loci
#'
#' This functions calculates the null probability of observing
#' overlap in outlier loci between 2+ groups with respect to a scenario
#' whereby loci are drawn at random from a set of loci.
#'
#' This is non-parametric sytle test is not a strict population genetic statistical
#' method per se, but provides an informal way to compare parameters of an
#' outlier analysis (number of groups, number of analysed loci,
#' and the number of observed outlier loci) to random chance.
#'
#' @param lociList List: A list of loci analysed for each group. Each index is a group,
#' containing a vector loci names.
#'
#' @param lociSig List: A list of significant loci for each group. Each index is a group,
#' containing a vector of loci names.
#'
#' @param perms Integer: The number of permutations to run for significance testing. Default = 1000
#'
#' @details
#' It is very important that the order of indices in \code{lociList} and \code{lociSig}
#' are in the same, because each index is expected to correpond to a group.
#'
#' The hypothesis being tested is that the number of observed loci overlapping
#' among groups is greater than that observed due to random chance.
#'
#' It is assumed that the amount of overlap is across all groups. E.g. if only 2 groups
#' are provided, then a locus must be significant in both groups. If 3 groups are provided,
#' then a locus must be significant in all 3 groups.
#'
#' Permutations are run where loci are randomly drawn from each group's set of loci at a size equivalent
#' to that deemed statistically significant in empircal tests. In other words, if a test
#' determined 2 loci out of 100 were significant, a null draw would randomly sample 2 loci from the set of 100.
#'
#' @return The value returned is the proportion of null permutations that were greater
#' to the observed value (i.e. the empirical number of significant loci shared between groups).
#'
#' @examples
#' grps <- list(A=c(1:101), B=c(20:100, 101:120), C=c(1:50, 70:120))
#'
#' sig <- list(A=c(1,8,88), B=c(88, 101), C=c(88, 102, 118, 120))
#'
#' locus_overlap(lociList=grps, lociSig=sig, perms=1000)
#'
#' @export
locus_overlap <- function(lociList, lociSig, perms=1000){
# Name groups is not named
if(is.null(names(lociList))){ names(lociList) <- paste0('group', length(lociList)) }
if(is.null(names(lociSig))){ names(lociSig) <- paste0('group', length(lociSig)) }
# Number of gorups
numGrps <- length(lociSig)
# Group names
grpNames <- names(lociSig)
# Counts of significant loci
sigCount <- table(unlist(lociSig))
# The observed number of loci shared among all groups
obsShares <- length(sigCount[sigCount==numGrps])
# Number of significant loci per group
numSigs <- lapply(lociSig, length)
# Permutations
permDat <- lapply(1:perms, function(i){
sharePerm <- unlist(lapply(grpNames, function(n){
sample(x=lociList[[n]], size=numSigs[[n]], replace=FALSE)
}))
sharePerm <- table(sharePerm)
return(sum(sharePerm==numGrps))
})
permDat <- unlist(permDat)
# p-value: Numbers of perms with shares >= observed, divided by number of perms
p <- sum(permDat > obsShares)/perms
return(p)
}
# Make documents
roxygenise('./', clean=TRUE)
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
install.packages('Rtools')
library(genomalicious)
# Make documents
roxygenise('./', clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
# Make documents
roxygenise('./', clean=TRUE)
getwd()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise('./', clean=TRUE)
# Make documents
# roxygenise('./', clean=TRUE)
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
# roxygenise('./', clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
