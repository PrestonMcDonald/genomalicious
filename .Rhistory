#' @export
allele_counts <- function(dat){
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
n <- length(dat)*2
if(class(dat)=='character'){
ref <- n - sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c(2, 1, 1, 0, 2))
#' Convert between genotype scores (separated alleles vs counts)
#'
#' Assumes biallelic genotypes and can interchange between separated
#' alleles ('0/0', '0/1', '1/1') or Ref allele counts (0, 1, 2).
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes separated alleles and converts into
#' allele counts. The opposite is true if class is \code{'integer'}, will
#' convert into separated alleles.
#'
#' @export
genoscore_converter <- function(dat){
if(!class(dat) %in% c('character', 'integer')){
stop('Class of argument dat is wrong.')
}
if(class(dat)=='character'){
gt <- lapply(strsplit(dat, split='/', fixed=TRUE)
, function(x){2-sum(as.integer(x))})
return(unlist(gt))
}
if(class(dat)=='integer'){
gt <- lapply(dat, function(x){
if(x==2){ return('0/0')
} else if(x==1){ return('0/1')
} else if(x==0){ return('1/1')
}
})
return(unlist(gt))
}
}
allele_counts(c(2, 1, 1, 0, 2))
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
dat <- c('1/1', '0/1', '0/1', '0/0', '0/0')
genoscore_converter(dat)
#' Calculate allele counts
#'
#' @param dat Character/Integer: A vector of genotypes. If the class
#' is \code{'character'}, then assumes alleles are separated
#' with a '/'. If theclass is \code{'integer'}, then assumes counts of
#' Ref alleles.
#'
#' @return A vector of alleles counts for Ref ('0') and Alt ('1') alleles.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat){
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
n <- length(dat)*2
if(class(dat)=='character'){
ref <- sum(genoscore_converter(dat))
alt <- n - ref
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
}
return(c(ref=ref, alt=alt))
}
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
allele_counts(c(2, 1, 1, 0, 2))
str=Str(nreg=4,r=c(7,4,2,3),n=16)
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
str
abu=matrix(data=runif(16*3,min=0,max=1),nrow = 20,ncol = 16)
abu
#' Calculate diversity statistics with \code{IDIP} from a data table of genotypes
#'
#' @param snpDat Data table
#'
#' snpDat <- genomaliciousGenos
#' @export
idip_DT <- function(snpDat, strucMat
, sampCol=NA, locusCol=NA, genoCol=NA){
}
snpDat <- genomaliciousGenos
snpDat
snpDat <- genomaliciousGenos
snpDat <- genomalicious4pops
data(genomalicious4pops)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
snpDat <- genomalicious4pops
library(genomalicious)
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(genomalicious)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(data.table)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID;
#' and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.RData')
roxygenise('./', clean=TRUE)
library(genomalicious)
data("genomalicious4pops")
genomalicious4pops
dat=genomalicious4pops
genoMat
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
dat
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
genoMat[, 1:4]
normalise_patterson(genoMat)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
genoMat
genoMat[, 1:4]
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
genoMat[, 1:4]
normalise_patterson(genoMat)
normalise_patterson(genoMat)[, 1:5]
dat
dat
genoMat
j <- genoMat[,2]
j
sum(j)/length(j)
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
p
j
dat
genos2freqs(genomalicious4pops)
dat <- genos2freqs(genomalicious4pops)
dat
dat[, 1:4]
genomaliciousFreqsLong
genomaliciousFreqsLong
dat <- genomaliciousFreqsLong
dat <- genomaliciousFreqsLong
dat <- genomaliciousFreqsLongdat
dat
freqCol='FREQ'
locusCol='LOCUS'
popCol='POP'
freqMat <- DT2Mat_freqs(dat, popCol=popCol, locusCol=locusCol, freqCol=freqCol)
freqMat
freqMat <- apply(freqMat, 2, scale, center=TRUE, scale=TRUE)
freqMat
prcomp(freqMat, center=TRUE, scale=TRUE)
pca$pops <- rownames(freqMat)
freqMat <- DT2Mat_freqs(dat, popCol=popCol, locusCol=locusCol, freqCol=freqCol)
pca <- prcomp(freqMat, center=TRUE, scale=TRUE)
pca$pops <- rownames(freqMat)
pca
pca$pops
pca$x
pca$rotation
plot(pca)
plot(pca$x)
pca_DTfreqs(genomaliciousFreqsLong)
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' data(genomaliciousFreqsLong)
#'
#' pca_DTfreqs(genomaliciousFreqsLong)
#'
#' @export
pca_DTfreqs <- function(dat, popCol='POP', locusCol='LOCUS', freqCol='FREQ'){
freqMat <- DT2Mat_freqs(dat, popCol=popCol, locusCol=locusCol, freqCol=freqCol)
pca <- prcomp(freqMat, center=TRUE, scale=TRUE)
pca$pops <- rownames(freqMat)
return(pca)
}
pca_DTfreqs(genomaliciousFreqsLong)
#' Genertate DADI input from pool-seq data
#'
#' @param dat Data table: Must contain columns with the following information,
#' \enumerate{
#' \item Population pool ID
#' \item Locus ID
#' \item Reference allele
#' \item Alternate alelle
#' \item Reference allele freuqency
#' \item Number of individuals per population pool
#'             }
#' @param poolCol Character: Population pool ID. Default = \code{'POOL'}
#' @param locusCol Character: Locus ID. Default = \code{'LOCUS'}
#' @param refCol Character: Reference allele. Default = \code{'REF'}
#' @param altCol Character: Alternate allele. Default = \code{'ALT'}
#' @param freqCol Character: The reference allele frequency. Default = \code{'P'}.
#' @param indsCol Character: The number of individuals per population pool. Default = \code{'INDS'}.
#' @param poolSub Character: The pools to subset out of \code{poolCol}. Default = \code{NULL}.
#'
#' @return Returns a data tablein the DADI input format.
#'
#' @export
dadi_inputs_pools <- function(dat
, poolCol='POOL'
, locusCol='LOCUS'
, refCol='REF'
, altCol='ALT'
, freqCol='P'
, indsCol='INDS'
, poolSub=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
# Sub out the pools if specified
if(is.null(poolSub)==FALSE){
dat <- dat[POOL %in% poolSub]
}
# Are there more than 3 populations in the POOL column?
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert frequency into estimated counts of individuals with each allele
dat[, REF.COUNT:=round(P*INDS)]
dat[, ALT.COUNT:=INDS-REF.COUNT]
# Some manipulations
r <- spread(X[,c('LOCUS', 'REF', 'POOL', 'REF.COUNT')], key=POOL, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(X[,c('LOCUS', 'ALT', 'POOL', 'ALT.COUNT')], key=POOL, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
# Mash it all together
return(data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
))
# ........... END
}
data(genomaliciousFreqsLong)
genomaliciousFreqsLong
genomaliciousReads
genomaliciousPi
data(genomaliciousPi)
genomaliciousPi
, indsCols='INDS')
dadi_inputs_pools(genomaliciousPi
)
, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
indsCols='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCol='INDS')
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
indsCol='INDS'
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
dat <- genomaliciousPi
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dat
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
indsCol='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dat
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='P', indsCol='INDS')
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousReads <- fread('inst/extdata/genomaliciousReads.csv')
refalt <- unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
save(genomaliciousPi, file='data/genomaliciousPi.RData')
