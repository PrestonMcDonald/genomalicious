<<<<<<< HEAD
#' @param num.sims Integer: The number of bootstrap simulations to run. Default = 100.
#'
#' @return Returns a vector of FST values produced by bootstrapping loci in the
#' original read count dataset, \code{dat}.
#'
#' @examples
#' #' # Load in the pool metadata and reads
#' data(genomaliciousInfo)
#' data(genomaliciousReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Bootstrap FST
#' bootFST <- poolfstat_boot(X, genomaliciousInfo, 100)
#'
#' @export
poolfstat_boot <- function(dat, pool.info, num.sims=100){
# Get the ID and number of unique loci
idLoci <- unique(dat$LOCUS)
numLoci <- length(idLoci)
# Create a vector to hold bootstrapped FST
bsFst <- numeric()
# Iterate for num.sims
for(i in 1:num.sims){
# Create the bootstrapped loci names
bsLoci <- data.table(LOCUS.BS=paste0('Locus', 1:numLoci)
, LOCUS.OG=sample(x=idLoci, replace=TRUE)
)
# Create the bootstrapped dataset
bsDat <- apply(bsLoci, 1, function(L){
data.table(LOCUS=L['LOCUS.BS']
, dat[LOCUS==L['LOCUS.OG']
, c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'DP', 'RO')]
)
})
bsDat <- do.call('rbind', bsDat)
# Calculate FST from the bootstrapped dataset
X <- poolfstat_DT(bsDat, pool.info)
bsFst <- c(bsFst, X$Fst$FST)
}
# Return the bootstrapped FST values
return(bsFst)
}
poolfstat_boot(X, genomaliciousInfo, 100)
dat <- poolfstat_DT(X, genomaliciousInfo)$pooldata
dat
dat <- poolfstat_DT(X, genomaliciousInfo)$pooldat
dat
bootDat <- dat
sample(1:dat@nsnp, replace=TRUE)
bootId <- sample(1:dat@nsnp, replace=TRUE)
dat
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat <- dat
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
bootDat
computeFST(bootDat)
for(sim in 1:num.sims){
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
}
lapply(1:num.sims, function(sim){
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- lapply(1:num.sims, function(sim){
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- lapply(1:num.sims, function(sim){
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- do.call('rbind', fstBoot)
fstBoot
hist(fstBoot)
fstBoot <- lapply(1:num.sims, function(sim){
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
hist(fstBoot)
fstBoot <- lapply(1:num.sims, function(sim){
bootDat <- dat
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
fstBoot
hist(fstBoot)
dat
class(pooldat)
class(dat)
data(genomaliciousReads)
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Bootstrap FST
#' bootFST <- poolfstat_boot(X, genomaliciousInfo, 100)
#'
#' @export
poolfstat_boot <- function(dat, num.sims=100){
poolfstat_boot <- function(dat, num.sims=100){
fstBoot <- lapply(1:num.sims, function(sim){
bootDat <- dat
bootId <- sample(1:dat@nsnp, replace=TRUE)
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
# Return the bootstrapped FST values
return(fstBoot)
}
poolfstat_boot(X, genomaliciousInfo, 100)
poolfstat_boot(X, 100)
dat
data(genomaliciousReads)
data(genomaliciousInfo)
poolFst <- poolfstat_DT(X, genomaliciousReads)
data(genomaliciousReads)
data(genomaliciousInfo)
# Subset to keep only Rep1 reads.
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
# Need to add pool ID.
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
poolFst <- poolfstat_DT(X, genomaliciousInfo)
bootFST <- poolfstat_boot(poolFst$pooldat, 100)
bootFst
bootFst <- poolfstat_boot(poolFst$pooldat, 100)
bootFst
#' Bootstrap FST values from \code{poolfstat}
#'
#' Takes a data table of read counts and bootstraps the estimate of FST
#' calcualted from the function \code{poolfstat::computeFST}. Also requires
#' pool size information.
#'
#' @param dat Pooldata: The main data class object for \code{poolfstat}. Can be created
#' from a data table of read counts using \code{poolfstat_DT}.
#'
#' @param num.sims Integer: The number of bootstrap simulations to run. Default = 100.
#'
#' @return Returns a vector of FST values produced by bootstrapping loci in the
#' original read count dataset, \code{dat}.
#'
#' @examples
#' #' # Load in the pool metadata and reads
#' data(genomaliciousReads)
#' data(genomaliciousInfo)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Use poolfstat_DT to compute FST for this dataset and create a pooldata object
#' poolFst <- poolfstat_DT(X, genomaliciousInfo)
#'
#' # Bootstrap FST, using pooldata object from poolFst
#' bootFst <- poolfstat_boot(poolFst$pooldat, 100)
#'
#' @export
poolfstat_boot <- function(dat, num.sims=100){
# Iterate over sims
fstBoot <- lapply(1:num.sims, function(sim){
# Make a new copy of data to bootstrap
bootDat <- dat
# Rows in data matrices to resample
bootId <- sample(1:dat@nsnp, replace=TRUE)
# Resample ref allele counts, read coverage, and SNP info matrices
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
# Compute FST
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
# Return the bootstrapped FST values
return(fstBoot)
}
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$DP} The total depth of reads supporting the variant.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(genomaliciousInfo)
#' data(genomaliciousReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
=======
>>>>>>> d225b20342e6de589db4cfb5fb24c7058a360b16
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' poolfstat_DT(X, genomaliciousInfo)
#'
#'
#'@export
poolfstat_DT <- function(dat, pool.info){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'LOCUS', 'POOL', 'DP', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $LOCUS, $POOL, $DP, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X@readcoverage <- as.matrix(dpMat[, !'LOCUS'], rownames=dpMat$LOCUS)
X@snp.info <- as.matrix(loci)
X@poolsizes <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$INDS * 2
X@poolnames <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$POOL
return(list(Fst=computeFST(X), pooldat=X))
rm(X)
}
library(genomalicious)
roxygenise('./', clean=TRUE)
library(genomalicious)
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$DP} The total depth of reads supporting the variant.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(genomaliciousInfo)
#' data(genomaliciousReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' poolfstat_DT(X, genomaliciousInfo)
#'
#'
#'@export
poolfstat_DT <- function(dat, pool.info, method='Anova', snp.index=NA){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'LOCUS', 'POOL', 'DP', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $LOCUS, $POOL, $DP, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X@readcoverage <- as.matrix(dpMat[, !'LOCUS'], rownames=dpMat$LOCUS)
X@snp.info <- as.matrix(loci)
X@poolsizes <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$INDS * 2
X@poolnames <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$POOL
return(list(Fst=computeFST(X, method=method, snp.index=snp.index), pooldat=X))
rm(X)
}
#' Calculate FST with \code{poolfstat} from a data table of read counts
#'
#' Takes a data table of read counts and creates an object of class
#' \code{poolfstat}. The FST for the pools in the data table is calculated using
#' the function \code{poolfstat::computeFST}. Also requires pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \enumerate{
#'    \item \code{$CHROM} The chromosome (contig) ID.
#'    \item \code{$POS} The variant position on the chromosome.
#'    \item \code{$REF} The reference allele.
#'    \item \code{$ALT} The alternate allele.
#'    \item \code{$LOCUS} The locus ID.
#'    \item \code{$POOL} The pool ID.
#'    \item \code{$DP} The total depth of reads supporting the variant.
#'    \item \code{$RO} The number of reads supporting the reference allele.
#' }
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns:
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @param method Character: Either 'Anova' (default) or 'Identity'. Passed to \{method} argument
#' in \code{poolfstat::computeFST()}.
#'
#' #' @param snp.index List: A list of SNPs to consider. Default = \code{NA}.
#'  Passed to \{snp.index} argument in \code{poolfstat::computeFST()}.
#'
#' @return Returns a list with two indices: \code{$Fst} is the calculated FST among the
#' pools using a function call of \code{poolfstat::computeFST}, whereas \code{$pooldat} is the
#' \code{poolfstat} object used to generate said FST values.
#'
#' @examples
#' # Load in the pool metadata and reads
#' data(genomaliciousInfo)
#' data(genomaliciousReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Calculate FST using poolfstat
#' poolfstat_DT(X, genomaliciousInfo)
#'
#'
#'@export
poolfstat_DT <- function(dat, pool.info, method='Anova', snp.index=NA){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(i in c('tidyr', 'data.table', 'poolfstat')){ require(i, character.only=TRUE); rm(i)}
if(sum(c('CHROM', 'POS', 'REF', 'ALT', 'LOCUS', 'POOL', 'DP', 'RO') %in% colnames(dat)) != 8){
stop('Argument dat needs the columns $CHROM, $POS, $REF, $ALT, $LOCUS, $POOL, $DP, and $RO.')
}
if(sum(c('POOL', 'INDS') %in% colnames(pool.info)) != 2){
stop('Argument pool.info needs the columns $POOL and $INDS.')
}
if(sum(unique(dat$POOL) %in% pool.info$POOL) != length(unique(dat$POOL))){
stop('The pools in argument dat are not all present in argument pool.info.')
}
setorderv(dat, cols=c('LOCUS', 'POOL'))
setorder(pool.info, POOL)
dpMat <- spread(data=dat[, c('LOCUS', 'POOL', 'DP')], key=POOL, value=DP)
roMat <- spread(data=dat[, c('LOCUS', 'POOL', 'RO')], key=POOL, value=RO)
loci <- dat[, c('CHROM', 'POS', 'REF', 'ALT')]; loci <- loci[!duplicated(loci),]
X <- new("pooldata")
X@npools <- length(unique(dat$POOL))
X@nsnp <- nrow(loci)
X@refallele.readcount <- as.matrix(roMat[, !'LOCUS'], rownames=roMat$LOCUS)
X@readcoverage <- as.matrix(dpMat[, !'LOCUS'], rownames=dpMat$LOCUS)
X@snp.info <- as.matrix(loci)
X@poolsizes <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$INDS * 2
X@poolnames <- pool.info[which(pool.info$POOL %in% colnames(dpMat[, !'LOCUS']))]$POOL
return(list(Fst=computeFST(X, method=method, snp.index=snp.index), pooldat=X))
rm(X)
}
#' Bootstrap FST values from \code{poolfstat}
#'
#' Takes a data table of read counts and bootstraps the estimate of FST
#' calcualted from the function \code{poolfstat::computeFST}. Also requires
#' pool size information.
#'
#' @param dat Pooldata: The main data class object for \code{poolfstat}. Can be created
#' from a data table of read counts using \code{poolfstat_DT}.
#'
#' @param num.sims Integer: The number of bootstrap simulations to run. Default = 100.
#'
#' @param method Character: Either 'Anova' (default) or 'Identity'. Passed to \{method} argument
#' in \code{poolfstat::computeFST()}.
#'
#' @param snp.index List: A list of SNPs to consider. Default = \code{NA}.
#' Passed to \{snp.index} argument in \code{poolfstat::computeFST()}.
#' @return Returns a vector of FST values produced by bootstrapping loci in the
#' original read count dataset, \code{dat}.
#'
#' @examples
#' #' # Load in the pool metadata and reads
#' data(genomaliciousReads)
#' data(genomaliciousInfo)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Use poolfstat_DT to compute FST for this dataset and create a pooldata object
#' poolFst <- poolfstat_DT(X, genomaliciousInfo)
#'
#' # Bootstrap FST, using pooldata object from poolFst
#' bootFst <- poolfstat_boot(poolFst$pooldat, 100)
#'
#' @export
poolfstat_boot <- function(dat, num.sims=100){
# Iterate over sims
fstBoot <- lapply(1:num.sims, function(sim){
# Make a new copy of data to bootstrap
bootDat <- dat
# Rows in data matrices to resample
bootId <- sample(1:dat@nsnp, replace=TRUE)
# Resample ref allele counts, read coverage, and SNP info matrices
bootDat@refallele.readcount <- bootDat@refallele.readcount[bootId, ]
bootDat@readcoverage <- bootDat@readcoverage[bootId, ]
bootDat@snp.info <- bootDat@snp.info[bootId, ]
# Compute FST
return(computeFST(bootDat)$FST)
})
fstBoot <- unlist(fstBoot)
# Return the bootstrapped FST values
return(fstBoot)
}
<<<<<<< HEAD
roxygenise('./', clean=TRUE)
library(genomalicious)
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
library(genomalicious)
?poolfstat_DT
=======
data(genomaliciousFreqsLong)
genomaliciousFreqsLong
genomaliciousReads
genomaliciousPi
data(genomaliciousPi)
genomaliciousPi
, indsCols='INDS')
dadi_inputs_pools(genomaliciousPi
)
, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
indsCols='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCols='INDS')
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='PI', indsCol='INDS')
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
indsCol='INDS'
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
dat <- genomaliciousPi
# Reassign names
setnames(dat, c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
, c('POOL', 'LOCUS', 'REF', 'ALT', 'P', 'INDS'))
dat
c(poolCol, locusCol, refCol, altCol, freqCol, indsCol)
indsCol='INDS'
freqCol='PI'
altCol='ALT'
refCol='REF'
locusCol='LOCUS'
poolCol='POOL'
dat
dadi_inputs_pools(genomaliciousPi, poolCol='POOL', locusCol='LOCUS', refCol='REF', altCol='ALT', freqCol='P', indsCol='INDS')
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
genomaliciousReads <- fread('inst/extdata/genomaliciousReads.csv')
refalt <- unique(genomaliciousReads[, c('LOCUS', 'REF', 'ALT')])
genomaliciousPi <- fread('inst/extdata/genomaliciousPi.csv')
genomaliciousPi <- cbind(genomaliciousPi, refalt[match(genomaliciousPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=genomaliciousInfo$INDS[match(genomaliciousPi$POOL, genomaliciousInfo$POOL)]
)
save(genomaliciousPi, file='data/genomaliciousPi.RData')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
data(genomalicious4pops)
#' Generate a matrix of allele frequencies from genotypes
#'
#' Parses a data table of genotypes and returns a matrix of allele frequencies.
#'
#' @param dat Data table: It is expected that there are only two alleles, and therefore, only three possible genotypes:
#' 0/0, 0/1 (or 1/0), and 1/1, where the Ref allele is '0'. This data.table needs the following columns:
#' \code{POP}, the population ID; \code{SAMPLE}, the individual ID; \code{LOCUS}, the locus ID;
#' and \code{GT}, the genotype.
#'
#' @return Returns a matrix of allele frequencies for the Ref allele (coded as '0' in the genotype)
#'
#' @examples
#' # Import genotype data
#' data(genomaliciousGenos)
#' genomaliciousGenos
#'
#' # Convert to frequency matrix
#' genos2freqs(genomaliciousGenos)
#'
#' @export
genos2freqs <- function(dat){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
# Check the class of dat
if(!'data.table' %in% class(dat)){ stop("Argument dat isn't a data table.")}
# Check that demes has the right columns.
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Split the data based on LOCUS, then iterate through each LOCUS.
popFreqs <- lapply(split(dat, dat$LOCUS), function(L){
# An empty matrix that will store the population frequencies
# for the Ref allele at the Lth LOCUS.
locusFreqs <- matrix(NA, 0, 1)
colnames(locusFreqs) <- L$LOCUS[1]
# Iterate through each Pth population
for(P in unique(L$POP)){
# Subset the data by POP, obtain all alleles
pop.als <- unlist(strsplit(L[POP==P]$GT, '/'))
# What frequency are the Ref allele?
pop.ref.freq <- length(which(pop.als=='0')) / length(pop.als)
# Adjust the object's structure
pop.ref.freq <- as.matrix(pop.ref.freq)
colnames(pop.ref.freq) <- L$LOCUS[1]
rownames(pop.ref.freq) <- P
# Row bind the population data to the LOCUS matrix.
locusFreqs <- rbind(locusFreqs, pop.ref.freq)
}
return(locusFreqs)
})
# Column bind the loci.
return(do.call('cbind', popFreqs))
# ............ END
}
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
library(genomalicious)
data("genomaliciousPi")
genomaliciousPi
>>>>>>> d225b20342e6de589db4cfb5fb24c7058a360b16
