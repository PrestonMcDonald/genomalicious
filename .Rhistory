#' If colours are not specified, one colour is automatically assigned to each
#' unique "gene".
#'
#' The value of \code{extra_ypos} specifies that distance of the extra features
#' from the gene features. Set larger if things are looking squashed.
#' Additionally, \code{plot_ymax} sets the maximal plotting area, so set this
#' value larger if things are not fitting well.
#'
#' @return Returns a gg object.
#'
#' @examples
#' library(genomalicious)
#'
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # Read in a GENBANK file of the Bathygobius cocosensis mitogenome
#' gbk.read <- mitoGbk2DT(paste(genomaliciousExtData, 'data_Bcocosensis.gbk', sep='/'))
#' head(gbk.read)
#'
#' # Subset out the "CDS" types and plot genes, rRNA, tRNA, and D-loop.
#' # Rename rRNAs for nicer plotting.
#' gbk.read[TYPE!='CDS'] %>%
#' .[NAME=='12S ribosomal RNA', NAME:='12S rRNA'] %>%
#' .[NAME=='16S ribosomal RNA', NAME:='16S rRNA'] %>%
#' mitogenome_plot(mitoDT=., genome_len=16692, extra_txt_size=3)
#'
#' # Plot just the COX genes and the D-loop as "gene features" with
#' # custom colours and a border.
#' gene.col.vec <- c(
#' 'COX1'='royalblue',
#' 'COX2'='firebrick3',
#' 'COX3'='mediumpurple2',
#' 'CYTB'='plum2',
#' 'D-loop'='grey80')
#'
#' gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
#'   mitogenome_plot(
#'     mitoDT=., genome_len=16692,
#'     gene_type=c('gene', 'D-loop'),
#'     extra_type=NULL)
#'
#' @export
mitogenome_plot <- function(
mitoDT, genome_len=NULL, gene_colour=NULL,
gene_type=c('gene', 'rRNA'), extra_type=c('tRNA', 'D-loop'),
plot_xmax=genome_len, extra_ypos=3, plot_ymax=5,
gene_txt_size=4, extra_txt_size=4, font='Arial', gene_border=NA
){
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
####   ENVIRONMENT AND CHECKS   ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table); require(tidyverse); require(ggrepel)
# Check position variables
if(length(extra_ypos)!=1){
stop('Argument extra_ypos must be length 1. See ?mitogenome_plot.')
}
if(length(plot_ymax)!=1){
stop('Argument plot_ymax must be length 1. See ?mitogenome_plot.')
}
# Internal function
FUN_gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# Subset just the required columns
mitoDT <- mitoDT %>%
as.data.table %>%
.[,c('START', 'END', 'TYPE','NAME', 'STRAND')]
# Get the plotted genes data
genesDT <- mitoDT[TYPE %in% gene_type] %>%
.[, Y.MAX:=if_else(STRAND==1, 1, 0)] %>%
.[, Y.MIN:=if_else(STRAND==1, 0, -1)] %>%
.[, X.MID:=(START+END)/2]
# Get the extra plotted items
extraDT <- mitoDT[TYPE %in% extra_type] %>%
.[, Y.MAX:=if_else(STRAND==1, 1, 0)] %>%
.[, Y.MIN:=if_else(STRAND==1, 0, -1)] %>%
.[, X.MID:=(START+END)/2]
# Set gene colours if not specified
if(is.null(gene_colour)){
uniq_genes <- genesDT$NAME %>% unique() %>% sort()
gene_colour <- FUN_gg_color_hue(length(uniq_genes))
names(gene_colour) <- uniq_genes
} else{
if(FALSE %in% c(genesDT$NAME %in% names(gene_colour))){
stop('Argument gene_colour has been manually specified, but all the genes
to be plot are not accessible in names(gene_colour). See ?mitogenome_plot.')
}
}
# Set genome length if not specified
if(is.null(genome_len)){
genome_len <- mitoDT$END %>% max()
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
####    PLOT GENE FEATURES   ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Base plot
ggMito <- (
ggplot()
# Theme
+ theme(
axis.line.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
axis.title.y=element_blank(),
axis.ticks.length.x=unit(2, 'mm'),
axis.title.x=element_blank(),
legend.position='none',
panel.grid.minor.y=element_blank(),
panel.grid.major.y=element_blank(),
text=element_text(family=font)
)
# Gene features
+ geom_rect(
data=genesDT,
mapping=aes(xmin=START, xmax=END, ymin=Y.MIN, ymax=Y.MAX, fill=NAME),
colour=gene_border
)
# The central genome line
+ geom_rect(
data=data.table(START=0, END=genome_len, Y.MIN=-0.1, Y.MAX=0.1),
mapping=aes(xmin=START, xmax=END, ymin=Y.MIN, ymax=Y.MAX),
)
# Colours
+ scale_colour_manual(values=gene_colour)
+ scale_fill_manual(values=gene_colour)
# Axis limits
+ xlim(0, plot_xmax)
+ ylim(-plot_ymax,plot_ymax)
)
# Text for genes features on positive and negative strands
if(nrow(genesDT[STRAND==1]) > 0){
ggMito <- (
ggMito
+ geom_text(
data=genesDT[STRAND==1],
mapping=aes(x=X.MID, y=1.2, label=NAME, colour=NAME),
angle=45, hjust='left', size=gene_txt_size, family=font
)
)
}
if(nrow(genesDT[STRAND==-1]) > 0){
ggMito <- (
ggMito
+ geom_text(
data=genesDT[STRAND==-1],
mapping=aes(x=X.MID, y=-1.2, label=NAME, colour=NAME),
angle=45, hjust='right', size=gene_txt_size, family=font
)
)
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
####   PLOT EXTRA FEATURES   ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(nrow(extraDT)>0){
if(nrow(extraDT[STRAND==1]) > 0){
ggMito <- (
ggMito
+ geom_rect(
data=extraDT[STRAND==1],
mapping=aes(xmin=START, xmax=END, ymin=extra_ypos, ymax=extra_ypos+0.2)
)
+ geom_rect(
data=extraDT[STRAND==-1],
mapping=aes(xmin=START, xmax=END, ymin=-extra_ypos, ymax=-extra_ypos-0.2)
)
)
}
if(nrow(extraDT[STRAND==-1] > 0)){
ggMito <- (
ggMito
+ geom_text_repel(
data=extraDT[STRAND==1],
mapping=aes(x=START, y=extra_ypos+0.2, label=NAME),
angle=45, min.segment.length = unit(0, 'lines'),
ylim=c(extra_ypos+0.5,plot_ymax), nudge_y=extra_ypos+0.5,
size=extra_txt_size, family=font
)
+ geom_text_repel(
data=extraDT[STRAND==-1],
mapping=aes(x=START, y=-extra_ypos-0.2, label=NAME),
angle=45, min.segment.length = unit(0, 'lines'),
ylim=c(-plot_ymax,-extra_ypos-0.5), nudge_y=-extra_ypos-0.5,
size=extra_txt_size, family=font
)
)
}
}
# >>>>>>>>>>>>>>>>>>
####   OUTPUT   ####
# >>>>>>>>>>>>>>>>>>
return(ggMito)
}
gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
mitogenome_plot(
mitoDT=., genome_len=16692,
gene_type=c('gene', 'D-loop'),
extra_type=NULL)
gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
mitogenome_plot(
mitoDT=., genome_len=16692,
gene_type=c('gene', 'D-loop'), gene_colour=gene.col.vec,
extra_type=NULL, gene_border=TRUE)
gene.col.vec <- c(
'COX1'='royalblue',
'COX2'='firebrick3',
'COX3'='mediumpurple2',
'CYTB'='plum2',
'D-loop'='grey69')
gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
mitogenome_plot(
mitoDT=., genome_len=16692,
gene_type=c('gene', 'D-loop'), gene_colour=gene.col.vec,
extra_type=NULL, gene_border=TRUE)
gene.col.vec <- c(
'COX1'='royalblue',
'COX2'='firebrick3',
'COX3'='mediumpurple2',
'CYTB'='plum3',
'D-loop'='grey69')
gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
mitogenome_plot(
mitoDT=., genome_len=16692,
gene_type=c('gene', 'D-loop'), gene_colour=gene.col.vec,
extra_type=NULL, gene_border=TRUE)
gene.col.vec <- c(
'COX1'='royalblue',
'COX2'='firebrick3',
'COX3'='mediumpurple2',
'CYTB'='plum3',
'D-loop'='grey40')
gbk.read[NAME %in% c('COX1','COX2','COX3','CYTB','D-loop')] %>%
mitogenome_plot(
mitoDT=., genome_len=16692,
gene_type=c('gene', 'D-loop'), gene_colour=gene.col.vec,
extra_type=NULL, gene_border=TRUE)
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?mitogenome_plot
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
#' Convert a data table of allele frequencies into a matrix (or vice versa)
#'
#' Takes a data table of allele frequencies in long format and converts it into
#' a matrix in wide format (loci in columns and populations in rows). The reverse
#' can also be done. See also \code{DT2Mat_genos} for converting matrix of genotypes.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' of allele frequencies, then three columns are required:
#' \enumerate{
#'    \item The population ID (see param \code{popCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The Ref allele frequency (see param \code{freqCol}).
#' }
#' The population pool column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a frequency matrix to a data table, see argument \code{flip}.
#'
#' @param popCol Character: The column name with the population information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param freqCol Character: The column name with the Ref allele frequency.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{locusCol}, and \code{freqCol} become void.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(data_PoolPi)
#' datFreq <- data_PoolPi
#' datFreq
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(dat=datFreq, popCol='POOL', locusCol='LOCUS', freqCol='PI', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, popCol='POP', locusCol='LOCUS', freqCol='FREQ', flip=TRUE)
#'
#' @export
DT2Mat_freqs <- function(dat, popCol=NA, locusCol=NA, freqCol=NA, flip=FALSE){
# BEGIN ............
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table'%in%class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table': see ?DT2Mat_freqs")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix'%in%class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix': see ?DT2Mat_freqs")
}
# If providing a matrix, check that their are row names.
if('matrix'%in%class(dat) & is.null(rownames(dat))==TRUE){
stop("Argument dat is frequency matrix, but has no population IDs in the row names: see ?DT2Mat_freqs")
}
# If providing a data table, check that popCol, locusCol, and freqCol are in dat.
if('data.table'%in%class(dat)){
if(length(which((c(popCol, locusCol, freqCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, locusCol, or freqCol: see ?DT2Mat_freqs")
}
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified: see ?DT2Mat_freqs")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified: see ?DT2Mat_freqs")
}
if(is.na(freqCol)){
stop("Argument freqCol unspecified: see ?DT2Mat_freqs")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
# Spread out the data table
freqDT <- spread(dat[, c(popCol, freqCol, locusCol), with=FALSE], key=locusCol, value=freqCol)
# Get the population column values
popVals <- freqDT[[popCol]]
# Turn the data table into a matrix
freqMat <- as.matrix(freqDT[, !popCol, with=FALSE])
# Add population values as rows
rownames(freqMat) <- popVals
return(freqMat)
} else if(flip==TRUE){
# Turn matrix into data table, keep row names
freqDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- popCol
# Rejig the data table
freqDT <- melt(freqDT, id.vars=popCol, variable.name=locusCol, value=freqCol)
return(freqDT)
}
}
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' of genotypes coded as per VCF specifications ('0/0', '0/1', '1/1'), or counts
#' of the Alt alleles (0, 1, 2, repsectively).
#' Three columns are required:
#' \enumerate{
#'    \item The sampled individual ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The genotype (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and genotypes in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a genotype matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{$GT},
#' the Ref allele frequency.
#'
#' @examples
#' data(data_4pops)
#' datGt <- data_4pops[LOCUS %in% unique(data_4pops$LOCUS)[1:8]]
#'
#' # Convert a long data table to a wide matrix
#' genoMat <- DT2Mat_genos(datGt
#'               , sampCol='SAMPLE'
#'               , locusCol='LOCUS'
#'               , genoCol='GT'
#'               , flip=FALSE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table'%in%class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table': see ?DT2Mat_genos")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix'%in%class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix': see ?DT2Mat_genos")
}
# If providing a matrix, check that there are row names.
if('matrix'%in%class(dat) & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names: see ?DT2Mat_genos")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if('data.table'%in%class(dat)){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol: see ?DT2Mat_genos")
}
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified: see ?DT2Mat_genos")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified: see ?DT2Mat_genos")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified: see ?DT2Mat_genos")
}
}
# Evaluate the genotype data type.
# genoInitClass stores the initial genotype score information.
if(flip==FALSE){
genoInitClass <- class(dat[[genoCol]])
} else if(flip==TRUE){
genoInitClass <- class(dat[, 1])
}
if(!genoInitClass %in% c('character', 'integer', 'numeric')){
stop('Genotypes must be either a character or integer class: see ?DT2Mat_genos')
}
# If genotypes counts are numerics, convert to integers.
if(genoInitClass=='numeric'){
if(class(dat)[1]=='data.table'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
} else if(class(dat=='matirx')){
dat <- apply(dat, 2, as.integer)
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
return(genoMat)
}
if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
library(genomalicious)
library(genomalicious)
library(genomalicious)
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
?mrbayes_input
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
?mrbayes_input
