st > query_len
cat(st, ' ', en, '\n')
# Query length
query_len <- nchar(query_seq)
# Start and end of the first word
st <- search_start
en <- st + word_size - 1
# Track the steps
step_track <- 0
num_steps <- 1
# START WHILE LOOP
# Continue stepping through words
while(step_track==0){
cat(st, ' ', en, '\n')
hits <- NULL
if(st < query_len & en < query_len){
# If both the start and end of the word are less then query length
word.i <- substr(query_seq, st, en)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else if(st > query_len){
# Kill if start is greater than query length
step_track <- 1
} else if(en > query_len){
# If the end if greater than query length, remove wiggle room and see
# if it helps.
en_wig <- en - wiggle
if(st < query_len & en_wig < query_len){
word.i <- substr(query_seq, st, en_wig)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else{
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. ',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
hits <- matrix(NA, nrow=1, ncol=2)
step_track <- 1
}
}
# Were there multiple hits?
if(nrow(hits)==1){
st <- st + step_size
en <- en + step_size
num_steps <- num_steps + 1
} else{
step_track <- 1
}
# END WHILE LOOP
}
length(x)
nchar(x)
cat(st, ' ', en, '\n')
hits <- NULL
st < query_len & en < query_len
st > query_len
en > query_len
st < query_len & en <= query_len
# Start and end of the first word
st <- search_start
en <- st + word_size - 1
# Track the steps
step_track <- 0
num_steps <- 1
# START WHILE LOOP
# Continue stepping through words
while(step_track==0){
cat(st, ' ', en, '\n')
hits <- NULL
if(st < query_len & en <= query_len){
# If both the start and end of the word are less then query length
word.i <- substr(query_seq, st, en)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else if(st > query_len){
# Kill if start is greater than query length
step_track <- 1
} else if(en > query_len){
# If the end if greater than query length, remove wiggle room and see
# if it helps.
en_wig <- en - wiggle
if(st < query_len & en_wig < query_len){
word.i <- substr(query_seq, st, en_wig)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else{
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. ',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
hits <- matrix(NA, nrow=1, ncol=2)
step_track <- 1
}
}
# Were there multiple hits?
if(nrow(hits)==1){
st <- st + step_size
en <- en + step_size
num_steps <- num_steps + 1
} else{
step_track <- 1
}
# END WHILE LOOP
}
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. ',
'You might also consider changing the word size. ',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n',
'You might also consider changing the word size. \n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n'
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. '
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, '\n\n',
word.i
)
)
nchar(ATGACGCGCAAAATTGGC )
nchar('ATGACGCGCAAAATTGGC')
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, ', Size =', nchar(word.i), '\n\n',
word.i
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, ', Size = ', nchar(word.i), '\n\n',
word.i
)
)
nchar(x)
library(genomalicious)
num_steps=5
# Start and end of the first word
st <- search_start
en <- st + word_size - 1
# Track the steps
step_track <- 0
num_steps <- 1
# START WHILE LOOP
# Continue stepping through words
while(step_track==0){
cat(st, ' ', en, '\n')
hits <- NULL
if(st < query_len & en <= query_len){
# If both the start and end of the word are less then query length
word.i <- substr(query_seq, st, en)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else if(st > query_len){
# Kill if start is greater than query length
step_track <- 1
} else if(en > query_len){
# If the end if greater than query length, remove wiggle room and see
# if it helps.
en_wig <- en - wiggle
if(st < query_len & en_wig < query_len){
word.i <- substr(query_seq, st, en_wig)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else{
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, ', Size = ', nchar(word.i), '\n\n',
word.i
)
)
hits <- matrix(NA, nrow=1, ncol=2)
step_track <- 1
}
}
# Were there multiple hits?
if(nrow(hits)==1){
st <- st + step_size
en <- en + step_size
num_steps <- num_steps + 1
} else{
step_track <- 1
}
# END WHILE LOOP
}
step_size
word_size
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n'
)
)
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size.'
)
)
# Query length
query_len <- nchar(query_seq)
# Start and end of the first word
st <- search_start
en <- st + word_size - 1
# Track the steps
step_track <- 0
num_steps <- 1
# START WHILE LOOP
# Continue stepping through words
while(step_track==0){
cat(st, ' ', en, '\n')
hits <- NULL
if(st < query_len & en <= query_len){
# If both the start and end of the word are less then query length
word.i <- substr(query_seq, st, en)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else if(st > query_len){
# Kill if start is greater than query length
step_track <- 1
} else if(en > query_len){
# If the end if greater than query length, remove wiggle room and see
# if it helps.
en_wig <- en - wiggle
if(st < query_len & en_wig < query_len){
word.i <- substr(query_seq, st, en_wig)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else{
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, ', Size = ', nchar(word.i), '\n\n',
word.i
)
)
hits <- matrix(NA, nrow=1, ncol=2)
step_track <- 1
}
}
# Were there multiple hits?
if(nrow(hits)==1){
st <- st + step_size
en <- en + step_size
num_steps <- num_steps + 1
} else if(is.null(hits)){
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size.'
)
)
step_track <- 1
}else{
step_track <- 1
}
# END WHILE LOOP
}
hits
# START WHILE LOOP
# Continue stepping through words
while(step_track==0){
cat(st, ' ', en, '\n')
hits <- NULL
if(st < query_len & en <= query_len){
# If both the start and end of the word are less then query length
word.i <- substr(query_seq, st, en)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else if(st > query_len){
# Kill if start is greater than query length
step_track <- 1
} else if(en > query_len){
# If the end if greater than query length, remove wiggle room and see
# if it helps.
en_wig <- en - wiggle
if(st < query_len & en_wig < query_len){
word.i <- substr(query_seq, st, en_wig)
hits <- str_locate_all(query_seq, word.i)[[1]]
} else{
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size. \n\n',
'The last word was too truncated to test: \n\n',
'Start = ', st, ', End = ', en, ', Size = ', nchar(word.i), '\n\n',
word.i
)
)
hits <- matrix(NA, nrow=1, ncol=2)
step_track <- 1
}
}
# Were there multiple hits?
if(nrow(hits)==1){
st <- st + step_size
en <- en + step_size
num_steps <- num_steps + 1
} else if(is.null(hits)){
warning(
paste0(
'\n',
'Got to end of query with no circularity detected. \n\n',
'You might also consider changing the word size.'
)
)
step_track <- 1
}else{
step_track <- 1
return(hits)
}
# END WHILE LOOP
}
library(genomalicious)
circularity_test(x)
circularity_test(x, word_size = 5)
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
circularity_test(x, word_size = 5)
x <- 'GCGCAAAATTGGCCACTATCTGCTAGCTAGCATAGCATCGATCAGCATGACGCGCAAAATTGGCC'
circularity_test(x, word_size = 5)
motif_hits <- circularity_test(x, word_size = 5)
motif_hits
motif_hits <- circularity_test(x, word_size = 5)
substr(x, motif_hits[1,1], motif_hits[1,2])
motif_hits <- circularity_test(x, word_size = 10)
motif_hits
substr(x, motif_hits[1,1], motif_hits[1,2])
x <- 'AATTGGCCACTATCTGCTAGCTAGCATAGCATCGATCAGCATGACGCGCAAAATTGGCC'
motif_hits <- circularity_test(x, word_size = 10)
motif_hits <- circularity_test(x, word_size = 6)
substr(x, motif_hits[1,1], motif_hits[1,2])
motif_hits <- circularity_test(x, word_size = 8)
substr(x, motif_hits[1,1], motif_hits[1,2])
motif_seq <- substr(x, motif_hits[1,1], motif_hits[1,2])
motif_seq
circle_cutter(query_seq = x, motif=motif_seq)
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
library(genomalicious)
data(data_4pops)
# Test 1 to 10 with 3, 10, 20, and 40 PC axes, plotting just the first 10
# eigenvalues from the PCA, with a ggplot flavour.
inferK <- dapc_infer(
data_4pops,
kTest=1:10L,
pTest=c(3,10,20,40),
screeMax=10L,
look='ggplot',
showPlot=TRUE
)
inferK$tab
inferK$fit$`k=3,p=3`
inferK$plot
data("data_4pops")
# DAPC fit on all samples
DAPC.fit <- dapc_fit(data_4pops, pcPreds=3, method='fit')
DAPC.tt <- dapc_fit(data_4pops, pcPreds=3, method='train_test')
dapc_plot(DAPC.fit, type='scatter', axisIndex=c(1,2))
dapc_plot(DAPC.fit, type='scatter', axisIndex=c(2,3), scatterLook='classic',
plotColours=c(Pop1='#08c7e0', Pop2='#4169e1', Pop3='#e46adf', Pop4='#ce0073')
)
dapc_plot(DAPC.fit, type='probs')
dapc_plot(DAPC.fit, type='probs', popBarScale=5,
plotColours=c(Pop1='#08c7e0', Pop2='#4169e1', Pop3='#e46adf', Pop4='#ce0073'),
sampleShow=FALSE, legendPos='none'
)
dapc_plot(DAPC.tt, type='assign')
dapc_plot(DAPC.tt, type='assign', plotColours=c('white', 'grey50', 'grey20'),
legendPos='top')
library(genomalicious)
data(data_4pops)
### Fit the DAPC with the first 3 PC axes as predictors
DAPC.fit <- dapc_fit(dat=data_4pops, pcPreds=3, method='fit')
# Table of LD and PC axis scores
DAPC.fit$da.tab
DAPC.fit$pca.tab
DAPC.fit$da.fit
DAPC.fit$pca.fit
DAPC.fit$snp.contrib
DAPC.fit$da.prob
DAPC.loo <- dapc_fit(data_4pops, method='loo_cv', pcPreds=3, numCores=2)
DAPC.loo
DAPC.loo$tab
DAPC.loo$global
DAPC.loo$pairs.long
DAPC.loo$pairs.long[POP==POP.PRED]
DAPC.loo$pairs.wide
DAPC.tt <- dapc_fit(data_4pops, method='train_test', pcPreds=3, trainProp=0.8)
DAPC.tt$pairs.wide
library(genomalicious)
data("data_4pops")
Xdat <- data_4pops %>%
copy %>%
.[, c('SAMPLE','POP')] %>%
unique()
Ydat <- data_4pops
predFormula <- 'POP'
sampCol <- 'SAMPLE'
locusCol <- 'LOCUS'
genoCol <- 'GT'
type='genos'
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr', 'vegan')){ require(lib, character.only = TRUE)}
# Check that scaling is specified
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument `scaling`` is invalid. See: ?pca_genos')
}
stop('Argument `scaling` is invalid. See: ?pca_genos')
# Get the class of the genotypes
gtClass <- class(Ydat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele. See: ?pca_genos")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
Ydat[[genoCol]] <- genoscore_converter(Ydat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
if(type=='genos'){
Ymat <- DT2Mat_genos(Ydat, sampCol=sampCol, genoCol=genoCol, locusCol=locusCol)
}
Ymat
samp.vec <- rownames(Ymat)
Xdat <- Xdat[match(samp.vec, Xdat[[sampCol]]),]
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, scale=FALSE)')
rdaFormula
RDAobj <- eval(parse(text=rdaFormula))
RDAobj
anova(RDAobj)
rdaFormula <- paste0('rda(Ymat ~ ', predFormula, ', data=Xdat, scale=TRUE)')
RDAobj <- eval(parse(text=rdaFormula))
RDAobj
anova(RDAobj)
plot(RDAobj)
