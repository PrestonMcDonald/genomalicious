plot.tab <- pcoaObj$vectors %>%
as.data.frame() %>%
rownames_to_column(., 'POP') %>%
as.data.table()
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- paste0('Axis.', axisIndex[1])
axY <- paste0('Axis.', axisIndex[2])
# Percent explained variance
eigvals <- pcoaObj$values$Eigenvalues
varX <- round(eigvals[axisIndex[1]]/sum(eigvals) * 100, 2)
varY <- round(eigvals[axisIndex[2]]/sum(eigvals) * 100, 2)
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) +
plotTheme +
labs(
x=paste0('Axis ', axisIndex[1], ' (', varX, '%)')
, y=paste0('Axis ', axisIndex[2], ' (', varY, '%)')
)
# Add points and population colours if specified
if(is.null(plotColours)==TRUE){
gg <- gg + geom_point(aes(colour=POP)) + labs(colour=NULL)
} else if(is.null(plotColours)==FALSE){
gg <- gg + geom_point(aes(colour=POP)) + scale_colour_manual(values=plotColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'cumvar')){
# Vector of number PCs for X axis
S <- pcoaObj$values$Eigenvalues
X <- 1:length(S)
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='cumvar'){
Y <- unlist(lapply(1:length(S), function(i){
sum(S[1:i])/sum(S) * 100
}))
axY <- 'Cumulative variance (%)'
} else if(type=='scree'){
Y <- S/sum(S) * 100
axY <- 'Explained variance (%)'
}
# The plot
gg <- (data.frame(X=X[axisIndex], Y=Y[axisIndex]) %>%
ggplot(., aes(x=X, y=Y))
+ plotTheme
+ geom_col(fill=plotColours)
+ scale_x_continuous(breaks = ~round(unique(pretty(.))))
+ labs(x='PCo axes', y=axY)
)
}
# Plot and return
return(gg)
}
pcoa_plot(PCOA, type='scree')
pcoa_plot(PCOA, type='cumvar', plotColours='royalblue')
data(data_Genos)
PCA <- pca_genos(dat=data_Genos, scaling='patterson', popCol='POP')
pca_plot(PCA)
library(genomalicious)
data(data_Genos)
# population specified
PCA <- pca_genos(dat=data_Genos, scaling='patterson', popCol='POP')
# Plot the PCA
pca_plot(PCA)
#' Plot PCA results
#'
#' Plots results of a PCA, e.g., scatterplot, screeplot, and cumulative
#' explained variance plots. Takes \code{prcomp} object as the main input.
#'
#' @param pcaObj Prcomp object: A PCA of genotype data fitted using the
#' \code{prcomp} function. Either manually fitted, or using \code{genomalicious::pca_genos}.
#'
#' @param type Character: What type of plot to make: a scatterplot (\code{'scatter'}),
#' a screeplot of explained variances (\code{'scree'}), or the cumulative explained
#' variance (\code{'cumvar'}).
#'
#' @param axisIndex Integer: The PC axes to plot. If \code{type=='scatter'},
#' then must be exactly 2 values, the two PC axes to plot as a scatterplot.
#' If either \code{type=='scree'} or \code{type=='cumvar'}, then can be of
#' length from 1 to p, where p is the number of PC axes, and values again
#' represent the desired PC axes to plot.
#'
#' @param pops Character: A vector of population IDs, should match the
#' rows in \code{pcaObj$x}, but is an optional argument. Default = \code{NULL}.
#' The function will search for \code{pcaObj$pops} to assign to this argument
#' if not specified. Only valid when \code{type=='scatter'}.
#'
#' @param plotColours Character: A vector of colours to use for plotting,
#' but is an optional argument. Default = \code{NULL}.
#' When \code{type=='scatter'}, this must be a named list with one colour
#' per population. When \code{type=='scree'} or \code{type=='cumvar'}, only
#' a single colour is required, which is the colour of bars in the screeplot
#' or cumulative variance plot, respectively, and will default to 'grey20'
#' if unspecified.
#'
#' @param look Character: The look of the plot. Default = \code{'ggplot'}, the
#' typical gray background with gridlines produced by \code{ggplot2}. Alternatively,
#' when set to \code{'classic'}, produces a base R style plot.
#'
#' @param legendPos Character: Where should the legend be positioned? Default is
#' \code{'top'}, but could also be one of, \code{'right'}, \code{'bottom'},
#' \code{'left'}, or \code{'none'}.
#'
#' @return Returns a ggplot object.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' PCA <- pca_genos(dat=data_Genos, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot(PCA)
#'
#' # Plot axies 2 and 3, custom colours, and a classic look.
#' pca_plot(
#'    PCA,
#'    axisIndex=c(2,3),
#'    pops=pca$pops,
#'    plotColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2'),
#'    look='classic'
#'    )
#'
#' # Explained variance
#' pca_plot(PCA, type='scree')
#'
#' # Cumulative variance with custom colour
#' pca_plot(PCA, type='cumvar', plotColours='royalblue')
#'
#' @export
pca_plot <- function(
pcaObj, type='scatter', axisIndex=NULL, pops=NULL,
plotColours=NULL, look='ggplot', legendPos='top'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the pcaObj is the correct data class
if(!'prcomp' %in% class(pcaObj)){
stop("Argument `pcaObj` must be a prcomp class object.")
}
# Check that type is specified correctly
if(!type %in% c('scatter', 'scree', 'cumvar')){
stop("Argument `type` must be either: 'scatter', 'scree', or 'cumvar'.")
}
# Check that axisIndex is only length == 2
if(type=='scatter' & length(axisIndex)>2){
stop("Argument `axisIndex` should only contain two integer values for type=='scatter'.")
}
if(type%in%c('scree','cumvar') & sum(!axisIndex %in% 1:length(pcaObj$sdev))){
stop("Argument `axisIndex` should only contain values for indexes present in
pcaObj$sdev for type=='scree' or type=='cumvar'.")
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument `look` is not one of: 'ggplot' or 'classic'.")
}
# Check if there is a $pops index in pcaObj and assign populations if the
# argument pops is NULL
if(is.null(pops)){
if(is.null(pcaObj$pops)==FALSE){ pops <- pcaObj$pops}
}
# Check that specified populations in plotColours are all in pops.
if(type=='scatter' & is.null(pops)==FALSE & is.null(plotColours)==FALSE &
!sum(names(plotColours)%in%unique(pops))==length(unique(pops))){
stop("Argument plotColours misspecified: names of colours must be in argument pops.")
}
# Specify axes if unassigned
if(type=='scatter' & is.null(axisIndex)){
axisIndex <- c(1,2)
}
if(type%in%c('scree','cumvar') & is.null(axisIndex)){
axisIndex <- 1:length(pcaObj$sdev)
}
# Assign colour if unspecified for scree and cumulative variance plots.
if(type%in%c('scree','cumvar') & is.null(plotColours)){
plotColours <- 'grey20'
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position=legendPos, axis.ticks.length = unit(0.2, 'cm'))
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(
panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position=legendPos
, axis.ticks.length=unit(0.2, 'cm'))
}
# Make pcaObj a data table of PC scores
if(class(pcaObj)=='prcomp'){ plot.tab <- as.data.table(pcaObj$x) }
# If pops has been assigned, add this as a column to new pcaObj
if(is.null(pops)==FALSE){
plot.tab$POP <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- paste0('PC', axisIndex[1])
axY <- paste0('PC', axisIndex[2])
# Percent explained variance
eigvals <- pcaObj$sdev^2
varX <- round(eigvals[axisIndex[1]]/sum(eigvals) * 100, 2)
varY <- round(eigvals[axisIndex[2]]/sum(eigvals) * 100, 2)
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) +
plotTheme +
labs(
x=paste0('PC', axisIndex[1], ' (', varX, '%)')
, y=paste0('PC', axisIndex[2], ' (', varY, '%)')
)
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(plotColours)==TRUE){
gg <- gg + geom_point(aes(colour=POP)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(plotColours)==FALSE){
gg <- gg + geom_point(aes(colour=POP)) + scale_colour_manual(values=plotColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'cumvar')){
# Vector of number PCs for X axis
S <- pcaObj$sdev^2
X <- 1:length(S)
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='cumvar'){
Y <- unlist(lapply(1:length(S), function(i){
sum(S[1:i])/sum(S) * 100
}))
axY <- 'Cumulative variance (%)'
} else if(type=='scree'){
Y <- S/sum(S) * 100
axY <- 'Explained variance (%)'
}
# The plot
gg <- (data.frame(X=X[axisIndex], Y=Y[axisIndex]) %>%
ggplot(., aes(x=X, y=Y))
+ plotTheme
+ geom_col(fill=plotColours)
+ scale_x_continuous(breaks = ~round(unique(pretty(.))))
+ labs(x='PC axes', y=axY)
)
}
# Plot and return
return(gg)
}
PCA <- pca_genos(dat=data_Genos, scaling='patterson', popCol='POP')
pca_plot(PCA)
pca_plot(
PCA,
axisIndex=c(2,3),
pops=pca$pops,
plotColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2'),
look='classic'
)
pca_plot(
PCA,
axisIndex=c(2,3),
plotColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2'),
look='classic'
)
pca_plot(PCA, type='scree')
pca_plot(PCA, type='cumvar', axisIndex=10, plotColours='royalblue')
pca_plot(PCA, type='cumvar', axisIndex=1:10, plotColours='royalblue')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
?pcoa_freqs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
library(genomalicious)
data(data_Genos)
dat=data_Genos
pcPreds=3
method='fit'
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
popCol='POP'
scaling='covar'
numCores=1
trainProp=0.7
require(data.table)
require(tidyverse)
require(MASS)
if(sum(c(popCol, sampCol, locusCol, genoCol) %in% colnames(dat)) != 4){
stop('Argument `popCol`, `sampCol`, `locusCol` and `genoCol` must all be
column names in argument `dat`. See ?dapc_fit.')
}
# Check that scaling is specified
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument `scaling`` is invalid. See: ?pca_genos')
}
# Get the class of the genotypes
gtClass <- class(dat[[genoCol]])
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele. See: ?pca_genos")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat[[genoCol]] <- as.integer(dat[[genoCol]])
}
# Check method is specified correctly
if(!method %in% c('fit', 'loo_cv', 'train_test')){
stop('Argument `method` must be one of "fit", "loo_cv", or "train_test".
See ?dapc_fit.')
}
# Check that the training proportion is a proportion
if(sum(c(trainProp<0,trainProp>1))>0){
stop('Argument `trainProp` must be a proportion. See ?dapc_fit.')
}
FUN_snp_da_contrib <- function(x){
temp <- sum(x*x)
if(temp < 1e-12) return(rep(0, length(x)))
return(x*x / temp)
}
# Rename columns
colnames(dat)[match(c(sampCol, locusCol, popCol, genoCol),colnames(dat))] <- c(
'SAMPLE','LOCUS','POP','GT'
)
### The number of fitted populations
k <- length(unique(dat$POP))
### Fit DAPC to all data
if(method=='fit'){
# Population reference table
popRefs <- dat[, c('POP','SAMPLE')] %>% unique()
# Fit the PCA
PCA <- pca_genos(dat, scaling=scaling, popCol=popCol)
# Populations as vector in PCA
pops <- PCA$pops %>%  as.factor()
# PC axes as predictors
X <- PCA$x[, 1:pcPreds] %>% as.data.frame()
# Fit the DA
DA <- lda(X, pops, prior=rep(1,k)/k, tol=1e-30)
# Add in the explained variance
DA$exp.var <- round((DA$svd^2)/sum(DA$svd^2)*100, digits=2)
# SNP loadings on LD axes
snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
as.data.frame() %>%
rownames_to_column(., 'LOCUS') %>%
as.data.table
# Tables of DA and PCA scores
DA.tab <- data.table(
POP=pops,
SAMPLE=rownames(X),
as.data.table(predict(DA)$x))
PCA.tab <- PCA$x[, c(1:pcPreds)] %>%
as.data.frame %>%
rownames_to_column(., 'SAMPLE') %>%
left_join(., popRefs) %>%
as.data.table %>%
.[, c('POP','SAMPLE',paste0('PC',1:pcPreds)), with=FALSE]
# Posterior probabilities
DA.prob <- predict(DA)$posterior %>%
as.data.frame %>%
rownames_to_column(., 'SAMPLE') %>%
as.data.table %>%
left_join(., popRefs) %>%
melt(., id.vars=c('POP','SAMPLE'), variable.name='POP.PRED', value.name='PROB')
# Output
output <- list(
da.fit=DA, da.tab=DA.tab, da.prob=DA.prob,
pca.fit=PCA, pca.tab=PCA.tab,
snp.contrib=snp.da.contr
)
}
DA
# Add in the explained variance
DA$exp.var <- round((DA$svd^2)/sum(DA$svd^2)*100, digits=2)
DA
# Add in the among population variance
manova(X ~ pops)
X
# Add in the among population variance
manova(pops ~ X)
# Add in the among population variance
manova(as.matrix(X) ~ pops)
# Add in the among population variance
mov.summ <- manova(as.matrix(X) ~ pops) %>%
summary()
mov.summ
# Add in the among population variance
mov <- manova(as.matrix(X) ~ pops)
mov
mov$summary <- summary(mov)
mov
mov$summary
mov$summary$SS
mov$summary$SS$pops
sum(mov$summary$SS$pops)
SS.resid <- sum(mov$summary$SS$Residuals)
SS.pops <- sum(mov$summary$SS$pops)
SS.resid <- sum(mov$summary$SS$Residuals)
SS.pops
DA$among.var <- round(SS.pops/sum(SS.pops,SS.resid), digits=2)
DA$among.var
DA$among.var <- round(SS.pops/sum(SS.pops,SS.resid)*100, digits=2)
DA$among.var
SS.pops/sum(SS.pops,SS.resid)
SS.pops/sum(SS.pops,SS.resid)*100
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
library(LEA)
?LEA::ancestrymap2geno()
?LEA::geno2lfmm()
library(genomalicious)
data(data_PoolFreqs)
data(data_PoolInfo)
dat=data_PoolFreqs
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
head(newFreqData)
dat=newFreqData
popCol='POP'
locusCol='LOCUS'
freqCol='FREQ'
indsCol='INDS'
dat <- as.data.table(dat)
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
PCOA <- pcoa(pair.mat)
dat <- as.data.table(dat)
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
pair.mat
eigen(pair.mat)
PCOA <- eigen(pair.mat)
PCOA
eig.geno <- eigen(pair.mat)
eig.geno$vectors
eig.geno$vectors %>% plot
pait.mat %*% eig.geno$vectors %>% plot
pait.mat %*% eig.geno$vectors
pair.mat %*% eig.geno$vectors %>% plot
eig.geno$vectors %*% pair.mat %>% plot
pair.mat %*% eig.geno$vectors %>% plot
ape::pcoa(pair.mat)
ape::pcoa(pair.mat)$vectors %>% plot
pair.mat %*% eig.geno$vectors %>% plot
ape::pcoa(pair.mat)$vectors %>% plot
?pcoa
pair.mat %*% eig.geno$vectors %>% plot
eig.geno$vectors %>% plot
ape::pcoa(pair.mat)$vectors %>% class
ape::pcoa(pair.mat) %>% class
eig.geno$vectors %>% plot
eig.geno
ape::pcoa(pair.mat)
View(pcoa)
View(ape::pcoa)
dat
View(pair.fst)
