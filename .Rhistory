for(L in libs){require(L, character.only=T)}
install.packages('backports')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
roxygenise('./', clean = TRUE)
=======
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
library(data.table)
document()
session_info()
remove.packages('roxygen2')
remove.packages(lib='roxygen2')
remove.packages(pkgs='roxygen2')
library(roxygen2)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
devtools::install_github('gustavdelius/roxygen')
install.packages('digest')
install.packages("digest")
devtools::install_github('gustavdelius/roxygen')
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
document()
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
document()
traceback()
View(document)
roxygenize()
roxygenise()
remove.packages('roxygen2')
>>>>>>> 533ac4a23eec8afb651bf694cf85b496a8b70f93
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
doucment()
roxygenise()
roxygenise('./', clean=TRUE)
roxygenise('../genomalicious/', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
#' Convert a data table of allele frequencies into a matrix (or vice versa)
#'
#' Takes a data table of allele frequencies in long format and converts it into
#' a matrix in wide format (loci in columns and populations in rows). The reverse
#' can also be done.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of allele frequencies, then three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{lociCol}).
#'    \item (3) The Ref allele frequency (see param \code{freqCol}).
#' }
#' The population pool column serves as the pivot point to convert the long data table into a wide matrix.
#' If convertin from a frequency matrix to a data table, see argument \code{flip}.
#'
#' @param popCol Character: The column name with the population information.
#'
#' @param lociCol Character: The column name with the locus information.
#'
#' @param freqCol Character: The column name with the Ref allele frequency.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{lociCol}, and \code{freqCol} become void.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', lociCol='LOCUS', freqCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, flip=TRUE)
#'
#' @export
DT2Mat_freqs <- function(dat, popCol=NA, lociCol=NA, freqCol=NA, flip=FALSE){
# BEGIN ............
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is frequency matrix, but has no population IDs in the row names.")
}
# If providing a data table, check that popCol, lociCol, and freqCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(popCol, lociCol, freqCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, lociCol, or freqCol.")
}
}
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(freqCol)){
stop("Argument freqCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
freqDT <- spread(dat[, c(popCol, freqCol, lociCol), with=FALSE], key=lociCol, value=freqCol)
freqMat <- as.matrix(freqDT[, !popCol, with=FALSE])
rownames(freqMat) <- freqDT[[popCol]]
return(freqMat)
} else if(flip==TRUE){
freqDT <- data.table(dat, keep.rownames=TRUE)
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- 'POP'
locusNames <- colnames(freqDT)[which(colnames(freqDT)!='POP')]
freqDT <- melt(freqDT, id.vars='POP', variable='LOCUS', value='FREQ')
return(freqDT)
}
}
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
libraru(genomalicious)
library(genomalicious)
genomaliciousGenos
sampCol <- SAMPLE
sampCol <- 'SAMPLE'
lociCol <- 'LOCUS'
genoCol <- 'GT'
genoScore <- 'counts'
dat <- genomaliciousGenos
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
dat[, c(sampCol, lociCol, genoCol)]
dat[, c(sampCol, lociCol, genoCol), with=FALSE]
spread(dat[, c(sampCol, lociCol, genoCol), with=FALSE], key=lociCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- spread(dat[, c(sampCol, lociCol, genoCol), with=FALSE], key=lociCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
samoVals
sampVals
genoMat <- as.matrix(genoMat[, !sampCols])
genoMat <- as.matrix(genoMat[, !sampCol])
genoMat <- as.matrix(genoMat[, !(sampCol)])
sampCol
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
genoMat
as.matrix
?as.matrix
rownamesa(genoMat) <- sampVals
row.names(genoMat) <- sampVals
genoMat
apply(genoMat, 2, function(X){
strsplit(x=X, split='/', fixed=TRUE)
})
strsplit(x=X, split='/', fixed=TRUE)[[1]]
apply(genoMat, 2, function(X){
strsplit(x=X, split='/', fixed=TRUE)[[1]]
})
X <- genoMat[,1]
strsplit(x=X, split='/', fixed=TRUE)[[1]]
X
strsplit(x=X, split='/', fixed=TRUE)
lapply(strsplit(x=X, split='/', fixed=TRUE), sum)
lapply(strsplit(x=X, split='/', fixed=TRUE), sum, as.intger)
lapply(strsplit(x=X, split='/', fixed=TRUE), sum, as.inetger)
lapply(strsplit(x=X, split='/', fixed=TRUE), function(Y){ sum(as.integer(Y))})
apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE), function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
genoMat
dat <- genoMat
genoMat <- data.table(dat, keep.rownames=TRUE)
genoMat
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCols)
locusCol <- lociCol
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCols)
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
sampCol
genoMat
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
genoMat <- data.table(dat, keep.rownames=TRUE)
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
# The row names are turned into a column 'rn', replace.
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- popCol
# The row names are turned into a column 'rn', replace.
colnames(freqDT)[which(colnames(freqDT)=='rn')] <- sampCol
# Convert the matrix into a data table, keeping row names
genoMat <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
sampCol
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
genoDT
melt(genoMat, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
?melt
sampCol
melt(genoMat, id.vars='SAMPLE', variable.name=locusCol, value.name=genoCol)
melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
genomalicious
genomalicious::genomaliciousGenos
getwd()
sim2n <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
sim2n
genomaliciousGenos
library(genomalicious)
genomaliciousGenos
rm(sim2n)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
genomalicious4pops
save(genomalicious4pops, file='data/genomalicious4pops.Rdata')
DT2Mat_genos
library(genomalicious)
DT2Mat_genos(genomalicious4pops)
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The sampled individual ID (see param \code{sampCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The Ref allele frequency (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param gneoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' population IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{popCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$POP},
#' the population ID (as for pool-seq data); (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', locusCol='LOCUS', genoCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that popCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(popCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments popCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(popCol)){
stop("Argument popCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
DT2Mat_genos(genomalicious4pops, 'POP', 'LOCUS', 'GT')
genomalicious4pops
DT2Mat_genos(genomalicious4pops, popCol='POP', locusCol='LOCUS', genoCol='GT')
DT2Mat_genos(genomalicious4pops, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT')
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The sampled individual ID (see param \code{sampCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The Ref allele frequency (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param gneoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, sampCol='SAMPLE', locusCol='LOCUS', genoCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
DT2Mat_genos(genomalicious4pops, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT')
X<- DT2Mat_genos(genomalicious4pops, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT')
X
X[, 1:5]
X[1:5, 1:5]
pcaX <- prcomp(X, scale=TRUE, center=TRUE)
filter_maf(genomalicious4pops, 0.000001, 'genos')
length(filter_maf(genomalicious4pops, 0.000001, 'genos'))
length(filter_maf(genomalicious4pops, 0.01, 'genos'))
badloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
?filter_maf
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
rm(bad)
rm(badloci)
genomalicious4pops[, LOCUS %in% goodloci]
genomalicious4pops
goodloci
genomalicious4pops
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops[LOCUS %in% goodloci]
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.Rdata')
roxygenise('./', clean=TRUE)
library(genomalicious)
