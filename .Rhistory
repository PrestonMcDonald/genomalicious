col.index <- match(column.orig,colnames(dat))
colnames(dat)[col.index] <- c('POP','LOCUS','FREQ','INDS')
}
# --------------------------------------------+
# Internal functions
# --------------------------------------------+
# Variance components for FST from frequencies
FUN_varcomps_freqs <- function(pi, ni, r){
# Mean weighted allele frequency
p.mean <- sum(ni * pi)/sum(ni)
# Mean squares variance components
msp <- (1/(r-1)) * sum(ni * (pi - p.mean)^2)
msg <- (1/sum(ni-1)) * sum(ni * pi * (1-pi))
# Sample size correction factor
nc <- (1/(r-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Output as data.table
data.table(NUMER=msp-msg, DENOM=msp+(nc-1)*msg)
}
FUN_varcomps_genos <- function(ni, pi, hi, r){
# The mean sample size
n.mean <- sum(ni/r)
# The sample size scaling parameter
nc <- (r*n.mean - sum((ni^2)/(r*n.mean))) / (r-1)
# The average sample allele frequency
p.mean <- sum((ni*pi)/(r*n.mean))
# The variance in allele frequencies
s2 <- sum( (ni*(pi-p.mean)^2)/((r-1)*n.mean) )
# The average heterozygosity
h.mean <- sum( (ni*hi)/(r*n.mean) )
# The a, b, and c components
a <- (nc/n.mean) * (s2 - (1/(n.mean-1))*((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (0.25*h.mean)))
b <- (n.mean/(n.mean-1)) * ((p.mean*(1-p.mean)) - (s2*(r-1)/r) - (h.mean*((2*n.mean-1)/(4*n.mean))))
c <- 0.5 * h.mean
# Return as numerator and denominator
return(data.table(NUMER=a, DENOM=a+b+c))
}
# Variance components for FST from genotypes
FUN_fst_genos <- function(Dx){
left_join(
Dx[, .(FREQ=sum(GT)/(length(GT)*2)), by=c('POP','LOCUS')],
Dx[, .(HO=sum(GT==1)/length(GT)), by=c('POP','LOCUS')],
by=c('POP','LOCUS')
) %>%
left_join(
., Dx[, .(N=length(unique(SAMPLE))), by=c('POP','LOCUS')], by=c('POP','LOCUS')
) %>%
.[, FUN_varcomps_genos(ni=N, pi=FREQ, hi=HO, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
}
# Permute FST
FUN_fst_perm <- function(Dx, fst.genome, type, num.iters){
# Dx is a data table with $POP, $SAMPLE, $LOCUS, $GT.
# fst.genome is the genome-wide FST to test.
# num.iters is the number of iterations to perform.
perm.list <- list()
# Create a table to reshuffle populations
pop.perm.tab <- Dx[, c('POP','SAMPLE')] %>% unique
perm.results <- list()
# Iterate through i iterations
for(i in 1:num.iters){
# Reshuffle the populations in reference tbale
pop.perm.tab$POP <- sample(pop.perm.tab$POP, nrow(pop.perm.tab), replace=FALSE)
# Permute
perm.results[[i]] <- Dx %>%
# Subset the samples and their genotypes
.[, c('SAMPLE','LOCUS','GT')] %>%
# Add in the reshuffled populations
left_join(., pop.perm.tab, by='SAMPLE') %>%
# Calculate FST
FUN_fst_genos(.) %>%
.[, sum(NUMER)/sum(DENOM)]
rm(i)
}
# Results
perm.list$fst <- unlist(perm.results)
perm.list$pval <- sum(perm.list$fst>fst.genome)/num.iters
return(perm.list)
}
# --------------------------------------------+
# Code for genotypes
# --------------------------------------------+
if(type=='genos'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on genotype data, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- FUN_fst_genos(dat)
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# For genotype permutations
if(permute == TRUE){
cat('Performing permutations', '\n')
fstOutput$permute <- FUN_fst_perm(
Dx=dat, fst.genome=fstOutput$genome, type='genos', num.iters=num.iters)
} else{
fstOutput$permute <- NULL
}
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on genotype data, pairwise estimates', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
fstOutput$permute <- list(fst=list(), pval=list())
# START: Iterate over i pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
FUN_fst_genos(.) %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# If permuting
if(permute==TRUE){
cat('Performing permutation:', i, '/', num.pairs, '\n')
pair.perm <- FUN_fst_perm(
Dx=dat[POP %in% c(pop1, pop2)],
fst.genome=fstOutput$genome[[i]]$FST,
type='genos',
num.iters=num.iters
)
fstOutput$permute$fst[[i]] <- pair.perm$fst %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
fstOutput$permute$pval[[i]] <- data.table(
POP1=pop1, POP2=pop2, PVAL=pair.perm$pval
)
} else{
fstOutput$permute[[i]] <- NULL
}
rm(i)
# END: Iterate over i pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
if(!is.null(fstOutput$permute$fst)){
fstOutput$permute$fst <- do.call('rbind', fstOutput$permute$fst)
}
if(!is.null(fstOutput$permute$pval)){
fstOutput$permute$pval <- do.call('rbind', fstOutput$permute$pval)
}
# END: FST between population pairs
}
}
# --------------------------------------------+
# Code for frequencies
# --------------------------------------------+
if(type=='freqs'){
# START: FST among all populations
if(global==TRUE){
cat('FST calculation on frequencydata, global estimate', '\n')
fstOutput <- list()
# Per locus and genome-wide
fstOutput$locus <- dat %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM]
fstOutput$genome <- fstOutput$locus[, sum(NUMER)/sum(DENOM)]
# No pemutations
fstOutput$permute <- NULL
# END: FST among all populations
} else if(pairwise==TRUE){
# START: FST between pairwise populations
cat('FST calculation on frequencydata, global estimate', '\n')
pair.comp <- CJ(POP1=unique(dat$POP), POP2=unique(dat$POP)) %>%
.[POP1!=POP2]
num.pairs <- nrow(pair.comp)
fstOutput <- list()
fstOutput$locus <- list()
fstOutput$genome <- list()
# START: Iterate over i population pairs
for(i in 1:nrow(pair.comp)){
pop1 <- pair.comp$POP1[i]
pop2 <- pair.comp$POP2[i]
fstOutput$locus[[i]] <- dat[POP %in% c(pop1, pop2)] %>%
.[, FUN_varcomps_freqs(pi=FREQ, ni=INDS, r=length(unique(POP))), by=LOCUS] %>%
.[, FST:=NUMER/DENOM] %>%
data.table(POP1=pop1, POP2=pop2, .)
fstOutput$genome[[i]] <- fstOutput$locus[[i]] %>%
.[, sum(NUMER)/sum(DENOM)] %>%
data.table(POP1=pop1, POP2=pop2, FST=.)
# END: Iteration over i population pairs
}
# Combine results
fstOutput$locus <- do.call('rbind', fstOutput$locus)
fstOutput$genome <- do.call('rbind', fstOutput$genome)
fstOutput$permute <- NULL
# END: FST between pairwise populations
}
}
# --------------------------------------------+
# Output results
# --------------------------------------------+
return(fstOutput)
}
colnames(data_PoolFreqs)
fst_calc(
#'    data_PoolFreqs,
#'    type='freqs',
#'    global=FALSE,
#'    pairwise=TRUE,
#'    popCol='POOL'
#' )
#' freqPairs <- fst_calc(
#'    data_PoolFreqs,
#'    type='freqs',
#'    global=FALSE,
#'    pairwise=TRUE,
#'    popCol='POOL'
#' )
freqPairs
data_PoolFreqs
?fst_calc
fst_calc(
data_PoolFreqs,
type='freqs',
global=FALSE,
pairwise=TRUE,
popCol='POOL'
)
fst_calc(
data_PoolFreqs,
type='freqs',
global=FALSE,
pairwise=TRUE,
popCol='POOL'
)
library(genomalicious)
library(genomalicious)
# DAPC fit on all samples
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
library(genomalicious)
data("data_Genos")
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
# DAPC using training and testing partitions
DAPC.tt <- dapc_fit(data_Genos, pcPreds=3, method='train_test')
DAPC.fit
DAPC.fit %>% list
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?dapc_plot
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
?fst_calc
library(genomalicious)
data(data_Genos)
data(data_PoolFreqs)
genoGlobal <- fst_calc(
data_Genos,
type='genos',
global=TRUE,
permute=TRUE,
numIters=50)
genoGlobal$locus
# Genome-wide estimate
genoGlobal$genome
# Permutations
genoGlobal$permute$fst
genoGlobal$permute$pval
genoPairs <- fst_calc(
data_Genos,
type='genos',
global=FALSE,
pairwise=TRUE
)
# Locus specific estimates
genoPairs$locus
# Genome-wide estimates
genoPairs$genome
# Permutations (there are none!)
genoPairs$permute
genoPairsPerms <- fst_calc(
data_Genos,
type='genos',
global=FALSE,
pairwise=TRUE,
permute=TRUE,
numIters=10
)
genoPairsPerms$permute$fst
genoPairsPerms$permute$pval
colnames(data_PoolFreqs)
# There is no $POP column, but there is a $POOL column that contains
# the population pool ID. Need to manually specify this.
freqPairs <- fst_calc(
data_PoolFreqs,
type='freqs',
global=FALSE,
pairwise=TRUE,
popCol='POOL'
)
freqPairs
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
#' Plot PCA results
#'
#' Plots results of a PCA, e.g., scatterplot, screeplot, and cumulative
#' explained variance plots. Takes \code{prcomp} object as the main PCA fit.
#'
#' @param pcaObj Prcomp object: A PCA of genotype data fitted using the
#' \code{prcomp} function. Either manually fitted, or using \code{genomalicious::pca_genos}.
#'
#' @param type Character: What type of plot to make: a scatterplot (\code{'scatter'}),
#' a screeplot of explained variances (\code{'scree'}), or the cumulative explained
#' variance (\code{'cumvar'}).
#'
#' @param axisIndex Integer: The PC axes to plot. If \code{type=='scatter'},
#' then must be exactly 2 values, the two PC axes to plot as a scatterplot.
#' If either \code{type=='scree'} or \code{type=='cumvar'}, then can be of
#' length from 1 to p, where p is the number of PC axes, and values again
#' represent the desired PC axes to plot.
#'
#' @param pops Character: A vector of population IDs, should match the
#' rows in \code{pcaObj$x}, but is an optional argument. Default = \code{NULL}.
#' The function will search for \code{pcaObj$pops} to assign to this argument
#' if not specified. Only valid when \code{type=='scatter'}.
#'
#' @param plotColours Character: A vector of colours to use for plotting,
#' but is an optional argument. Default = \code{NULL}.
#' When \code{type=='scatter'}, this must be a named list with one colour
#' per population. When \code{type=='scree'} or \code{type=='cumvar'}, only
#' a single colour is required, which is the colour of bars in the screeplot
#' or cumulative variance plot, respectively, and will default to 'grey20'
#' if unspecified.
#'
#' @param look Character: The look of the plot. Default = \code{'ggplot'}, the
#' typical gray background with gridlines produced by \code{ggplot2}. Alternatively,
#' when set to \code{'classic'}, produces a base R style plot.
#'
#' @param showPlot Logical: Should the plot be shown automatically? Default is
#' \code{TRUE}, otherwise \code{FALSE}.
#'
#' @return Prints the plot to screen, and also returns an object of
#' \code{gg}/\code{ggplot} class.
#'
#' @examples
#' # Data
#' data(data_Genos)
#' datGt <- data_Genos
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_genos(dat=datGt, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot(pca)
#'
#' # Get more specific on scatter
#' pca_plot(pca
#'             , axisIndex=c(2,3)
#'             , pops=pca$pops
#'             , plotColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
#'             , look='classic', showPlot=TRUE)
#'
#'
#' @export
pca_plot <- function(
pcaObj, type='scatter', axisIndex=NULL, pops=NULL,
plotColours=NULL, look='ggplot', showPlot=TRUE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'ggplot2')){ require(lib, character.only = TRUE)}
# Check the pcaObj is the correct data class
if(!'prcomp' %in% class(pcaObj)){
stop("Argument `pcaObj` must be a prcomp class object.")
}
# Check that type is specified correctly
if(!type %in% c('scatter', 'scree', 'cumvar')){
stop("Argument `type` must be either: 'scatter', 'scree', or 'cumvar'.")
}
# Check that axisIndex is only length == 2
if(type=='scatter' & length(axisIndex)>2){
stop("Argument `axisIndex` should only contain two integer values for type=='scatter'.")
}
if(type%in%c('scree','cumvar') & sum(!axisIndex %in% 1:length(pcaObj$sdev))){
stop("Argument `axisIndex` should only contain values for indexes present in
pcaObj$sdev for type=='scree' or type=='cumvar'.")
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument `look` is not one of: 'ggplot' or 'classic'.")
}
# Check if there is a $pops index in pcaObj and assign populations if the
# argument pops is NULL
if(is.null(pops)){
if(is.null(pcaObj$pops)==FALSE){ pops <- pcaObj$pops}
}
# Check that specified populations in plotColours are all in pops.
if(type=='scatter' & is.null(pops)==FALSE & is.null(plotColours)==FALSE &
!sum(names(plotColours)%in%unique(pops))==length(unique(pops))){
stop("Argument plotColours misspecified: names of colours must be in argument pops.")
}
# Specify axes if unassigned
if(type=='scatter' & is.null(axisIndex)){
axisIndex <- c(1,2)
}
if(type%in%c('scree','cumvar') & is.null(axisIndex)){
axisIndex <- 1:length(pcaObj$sdev)
}
# Assign colour if unspecified for scree and cumulative variance plots.
if(type%in%c('scree','cumvar') & is.null(plotColours)){
plotColours <- 'grey20'
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top', axis.ticks.length = unit(0.2, 'cm'))
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(
panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top'
, axis.ticks.length=unit(0.2, 'cm'))
}
# Make pcaObj a data table of PC scores
if(class(pcaObj)=='prcomp'){ plot.tab <- as.data.table(pcaObj$x) }
# If pops has been assigned, add this as a column to new pcaObj
if(is.null(pops)==FALSE){
plot.tab$POP <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Percent explained variance
eigvals <- pcaObj$sdev^2
varX <- round(eigvals[axisIndex[1]]/sum(eigvals) * 100, 2)
varY <- round(eigvals[axisIndex[2]]/sum(eigvals) * 100, 2)
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) +
plotTheme +
labs(
x=paste0('PC', axisIndex[1], ' (', varX, '%)')
, y=paste0('PC', axisIndex[2], ' (', varY, '%)')
)
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(plotColours)==TRUE){
gg <- gg + geom_point(aes(colour=POP)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(plotColours)==FALSE){
gg <- gg + geom_point(aes(colour=POP)) + scale_colour_manual(values=plotColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'cumvar')){
# Vector of number PCs for X axis
S <- pcaObj$sdev^2
X <- 1:length(S)
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='cumvar'){
Y <- unlist(lapply(1:length(S), function(i){
sum(S[1:i])/sum(S)
}))
axY <- 'Cumulative variance'
} else if(type=='expvar'){
Y <- S/sum(S)
axY <- 'Explained variance'
}
# The plot
gg <- (data.frame(X=X[axisIndex], Y=Y[axisIndex]) %>%
ggplot(., aes(x=X, y=Y))
+ plotTheme
+ geom_col(fill=plotColours)
+ scale_x_continuous(breaks = ~round(unique(pretty(.))))
+ labs(x='PC axis', y=axY)
)
}
# Plot and return
if(showPlot==TRUE){plot(gg)}
return(gg)
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
library(genomalicious)
