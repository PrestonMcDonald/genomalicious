plot(PCA)
plot(PCA$x)
45/35
3/4
4/3
7/5
10/8
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
#' Convert a data table of genotypes into a matrix (or vice versa)
#'
#' Takes a data table of genotypes in long format and converts it into
#' a matrix in wide format (loci in columns and individuals in rows). The reverse
#' can also be done. See also \code{DT2Mat_freqs} for converting matrix of frequencies.
#'
#' @param dat Data table or Matrix: The object to transform. If this is a long data table
#' # of genotypes coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The sampled individual ID (see param \code{sampCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The Ref allele frequency (see param \code{genoCol}).
#' }
#' The sampled individual ID column serves as the pivot point to convert the long data table into a wide matrix.
#' If converting from a genotypes matrix to a data table, see argument \code{flip}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param gneoCol Character: The column name with the genotype information.
#'
#' @param flip Logical: Instead of converting a (long) data table to a (wide) matrix,
#' should a (wide) matrix be converted into a (long) data table? Default = \code{FALSE}.
#' If \code{TRUE}, then param \code{dat} must be a matrix, with loci names as column headers,
#' sample IDs in the row names, and frequencies in the cells. When \code{TRUE}, params
#' \code{sampCol}, \code{locusCol}, and \code{genoCol} are used to structure the new matrix.
#'
#' @return When \code{flip=FALSE}, converts a data table into a frequency matrix. When
#' \code{flip=TRUE}, converts a matrix into a data table with three columns: (1) \code{$SAMPLE},
#' the sample ID; (2) \code{$LOCUS}, the locus ID; and (3) \code{FREQ},
#' the Ref allele frequency.
#'
#' @examples
#' data(genomaliciousPi)
#'
#' # Convert a long data table to a wide matrix
#' freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, sampCol='SAMPLE', locusCol='LOCUS', genoCol='FREQ', flip=FALSE)
#'
#' # Convert a wide matrix back to a data table
#' freqDT <- DT2Mat_freqs(freqMat, flip=TRUE)
#'
#' @export
DT2Mat_genos <- function(dat, sampCol=NA, locusCol=NA, genoCol=NA, genoScore='counts', flip=FALSE){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('tidyr', 'data.table')){require(lib, character.only=TRUE)}
# If going from long data table to wide matrix, make sure dat is a data table.
if(flip==FALSE & !'data.table' %in% class(dat)){
stop("Argument flip==FALSE, but class(dat) isn't 'data.table'.")
}
# If going from a wide matrix to long data table, make sure dat is a matrix.
if(flip==TRUE & !'matrix' %in% class(dat)){
stop("Argument flip==TRUE, but class(dat) isn't 'matrix'.")
}
# If providing a matrix, check that their are row names.
if(class(dat)[1]=='matrix' & is.null(rownames(dat))==TRUE){
stop("Argument dat is a genotype matrix, but has no individual IDs in the row names.")
}
# If providing a data table, check that sampCol, locusCol, and genoCol are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c(sampCol, locusCol, genoCol) %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat does not have columns specified in arguments sampCol, locusCol, or genoCol.")
}
}
# Check that genoScore option specified properly
if(!genoScore %in% c('counts', 'sep')){
stop("Argument genoScore must be either 'counts' or 'sep': see details.")
}
# Check the column arguments are specified
if(flip==FALSE){
if(is.na(sampCol)){
stop("Argument sampCol unspecified.")
}
if(is.na(locusCol)){
stop("Argument locusCol unspecified.")
}
if(is.na(genoCol)){
stop("Argument genoCol unspecified.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(flip==FALSE){
genoMat <- spread(dat[, c(sampCol, locusCol, genoCol), with=FALSE], key=locusCol, value=genoCol)
sampVals <- genoMat[[sampCol]]
genoMat <- as.matrix(genoMat[, !(sampCol), with=FALSE])
row.names(genoMat) <- sampVals
# Return genos as separated alleles, per VCF format?
# Or return as counts of the Ref alleles?
if(genoScore=='sep'){
return(genoMat)
} else if(genoScore=='counts'){
genoMat <- apply(genoMat, 2, function(X){
XX <- lapply(strsplit(x=X, split='/', fixed=TRUE)
, function(Y){ sum(as.integer(Y))})
return(unlist(XX))
})
return(genoMat)
}
} else if(flip==TRUE){
# Convert the matrix into a data table, keeping row names
genoDT <- data.table(dat, keep.rownames=TRUE)
# The row names are turned into a column 'rn', replace.
colnames(genoDT)[which(colnames(genoDT)=='rn')] <- sampCol
# Rejig data table
genoDT <- melt(genoDT, id.vars=sampCol, variable.name=locusCol, value.name=genoCol)
return(genoDT)
}
}
data(genomaliciousPi)
freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, sampCol='SAMPLE', locusCol='LOCUS', genoCol='FREQ', flip=FALSE)
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
#' Filter loci by minor allele frequency (MAF)
#'
#' Parses a matrix of allele frequencies to determine which loci conform to the
#' desired minor allele frequency.
#'
#' @param dat Matrix or data table: Default expectation is that user is supplying a matrix of Ref allele
#' frequencies; i.e., loci in columns, populations in rows, and allele frequencies in cells. Alternatively,
#' a data table of genotypes can be supplied and allele frequencies will be calculated. It is expected that
#' there are only two alleles, and therefore, only three possible genotypes: 0/0, 0/1 (or 1/0), and 1/1, where
#' the Ref allele is '0'. This data table needs the following columns: \code{$POP}, the population ID; \code{$IND},
#' the individual ID; \code{$LOCUS}, the locus ID; and \code{$GT}, the genotype.
#'
#' @param maf Numeric: The minor allele frequency. E.g. 0.05 will filter for 5%, which will remove
#' a locus if its frequency is < 0.05 or > 0.95.
#'
#' @param type Character: Default = 'freqs', expected that \code{dat} is a matrix of allele frequencies.
#' Alternatively, if \code{dat} is a data table of of genotypes, set \code{type} to 'genos'.
#'
#' @return Returns an integer vector of column numbers in \code{dat} that conform
#' to the MAF value specified. These values can then be used to filter the allele frequency matrix.
#'
#' @examples
#' ####   Matrix of allele frequencies   ####
#' data(genomaliciousFreqs)
#'
#' # Filter for MAF=0.05 to remove Chrom_8_64, leaving all other loci
#' filter_maf(genomaliciousFreqs, maf=0.05, type='freqs')
#'
#' ####   Long data table of genotypes   ####
#' data(genomaliciousGenos)
#'
#' # Allele frequencies
#' genomalicious::genos2freqs(genomaliciousGenos)
#'
#' # Filter for MAF=0.05 to remove Locus3, return Locus1 and Locus2
#' filter_maf(genomaliciousGenos, maf=0.05, type='genos')
#'
#'
#' @export
filter_maf <- function(dat, maf=0.05, type='freqs'){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
libs <- library(data.table)
for(L in libs){ require(L, character.only=TRUE)}
# Make sure the class of dat matches the type of data specified.
if('matrix'%in%class(dat) & type!='freqs'){
stop("Argument dat is a matrix. Check this is a matrix of allele frequencies
and set argument type to 'freqs'.")
}
if ("data.table" %in% class(dat) & type!="genos") {
stop("Argument dat is a data table. Check this is a data table of genotypes\n
and set argument type to 'genos'.")
}
# Check that the MAF is between 0 and 1.
if(maf < 0 | maf > 1){
stop("Argument maf needs to be a numeric between 0 and 1.")
}
# Check that all the correct columns are in dat.
if(class(dat)[1]=='data.table'){
if(length(which((c('POP', 'SAMPLE', 'LOCUS', 'GT') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POP, $SAMPLE, $LOCUS, and $GT.")
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Specify the min and max MAF
minF <- maf
maxF <- 1 - maf
# If the input is a matrix of allele frequencies (columns = loci, rows = pops)
if(type=='freqs'){
test <- apply(dat, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
# If the input if a data.table of indiviudals and genotypes.
# Needs a column $POP (pop info), $IND (individual ID), $LOCUS
if(type=='genos'){
freqs <- genos2freqs(dat)
test <- apply(freqs, 2, function(f){
if(min(f) >= minF & max(f) <= maxF){ return('Yes')
} else {
return('No')
}
})
return(names(which(test=='Yes')))
}
}
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
library(genomalicious)
genomalicious4pops <- readRDS('inst/extdata/genomalicious_FastSimCoal_30Diploids.RDS')
setnames(genomalicious4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
goodloci <- filter_maf(genomalicious4pops, 0.01, 'genos')
genomalicious4pops <- genomalicious4pops[LOCUS %in% goodloci]
save(genomalicious4pops, file='data/genomalicious4pops.Rdata')
roxygenise('./', clean=TRUE)
#' Proability of locus overlap between two groups
#'
#' This test returns a probability that sets of "significant" loci
#' identified in two groups do not overlap by chance. For example,
#' if outlier tests are carried out in two different groups, the overlap
#' between these groups can be assessed to determine if the number of outliers
#' shared is significant or could be observed due to random chance.
#'
#' @param sigA Character/Integer: A vector of loci in group A.
#'
#' @param sigB Character/Integer: A vector of loci in group B.
#'
#' @param lociA Character/Integer: A vector of loci analysed in group A.
#'
#' @param lociB Character/Integer: A vector of loci analysed in group B.
#'
#' @param perm Integer: The number of permutations to run for significance testing.
#'
#' @details The hypothesis being tested is that the number of observed loci overlapping
#' between two groups is greater than that observed due to random chance. Permutations
#' are run where loci are randomly drawn from each groups set of loci at a size equivalent
#' to that deemed statistically significant. In other words, if a test determined 2 loci out
#' of 100 were significant, a null draw would randomly sample 2 loci from the set of 100.
#'
#' @return The value returned is the proportion of null permutations that were greater or
#' equal to the observed value (i.e. the empirical number of significant loci shared between groups).
#'
#' @example
#' locus_overlap_2groups(sigA=c(1,5), sigB=5, lociA=1:100, lociB=1:100, perm=1000)
#'
#' @export
locus_overlap_2groups <- function(sigA, sigB, lociA, lociB, perms){
# BEGIN ............
# The observed number of shared loci between group A and B
shareObs <- length(intersect(sigA, sigB))
# Generate null distribution of shared loci
shareNull <- lapply(1:perms, function(i){
# Take loci sets from both groups and draw the same number of loci
# as observed under selection
randA <- sample(x=lociA, size=length(sigA), replace=FALSE)
randB <- sample(x=lociB, size=length(sigB), replace=FALSE)
# Compare the intersect
return(length(intersect(randA, randB)))
})
shareNull <- unlist(shareNull)
# Probability that null permutations produced equal or higher numbers
# of overlap between two groups
sum(shareNull >= shareObs)/perms
# .......... END
}
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
#' @export
C <- DT2Mat_genos(genomalicious4pops, 'SAMPLE', 'LOCUS', 'GT')
C <- apply(C, 2, function(j){ 2 - j})
C
# Iterate over each j locus, normalise genotypes
M <- apply(C, 2, function(j){
# Locus j correction factor
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
# The normalised genotypes
corrected_genos <- j - u
drift_effect <- sqrt(p * (1-p))
return(corrected_genos/drift_effect)
})
M.svd <- svd(M)
M.svd
PCA <- prcomp(M, scale=FALSE, center=FALSE)
plot(PCA)
plot(PCA$x)
X <- (1/4) * M %*% t(M)
eig <- eigen(X)
# Iterate over each j locus, normalise genotypes
M <- apply(dat, 2, function(j){
# Locus j correction factor
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
# The normalised genotypes
corrected_genos <- j - u
drift_effect <- sqrt(p * (1-p))
return(corrected_genos/drift_effect)
})
dat <- C
# Locus j correction factor
u <- sum(j)/length(j)
# Iterate over each j locus, normalise genotypes
M <- apply(dat, 2, function(j){
# Locus j correction factor
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
# The normalised genotypes
corrected_genos <- j - u
drift_effect <- sqrt(p * (1-p))
return(corrected_genos/drift_effect)
})
M
M[, 1:5]
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
roxygenise('./', clean=TRUE)
library(genomalicious)
data(genomaliciousGenos)
genoMat <- DT2Mat_genos(genomaliciousGenos, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=FALSE)
genoMat
genoDT <- DT2Mat_genoMat(genoMat, flip=TRUE)
genoDT <- DT2Mat_genos(genoMat, flip=TRUE)
genoDT <- DT2Mat_genos(genoMat, flip=TRUE)
genoDT <- DT2Mat_genos(genoMat, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', flip=TRUE)
genoDT
data(genomaliciousPi)
genomaliciousPi
freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', locusCol='LOCUS', freqCol='PI', flip=FALSE)
data(genomaliciousFreqsLong)
load("~/GitHub/genomalicious/data/genomaliciousFreqsLong.Rdata")
genomaliciousFreqsLong
data(genomaliciousFreqsLong)
freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', locusCol='LOCUS', freqCol='PI', flip=FALSE)
freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', locusCol='LOCUS', freqCol='FREQS', flip=FALSE)
genomaliciousFreqsLong
freqMat <- DT2Mat_freqs(genomaliciousFreqsLong, popCol='POP', locusCol='LOCUS', freqCol='FREQ', flip=FALSE)
freqDT <- DT2Mat_freqs(freqMat, popCol='POP', locusCol='LOCUS', freqCol='FREQ', flip=TRUE)
freqDT
library(genomalicious)
#' Bootstrap FST values from \code{poolfstat}
#'
#' Takes a data table of read counts and bootstraps the estimate of FST
#' calcualted from the function \code{poolfstat::computeFST}. Also requires
#' pool size information.
#'
#' @param dat Data table: Contains read counts, e.g. like that been
#' produced by the function \code{vcf2DT}. Must contain all the following columns:
#' \code{$CHROM}, \code{$POS}, \code{$REF}, \code{$ALT}, \code{$LOCUS}, \code{$POOL},
#' \code{$DP}, \code{$RO}.
#'
#' @param pool.info Data table: Contains the sample sample sizes (number of diploids) for
#' for each unique pool listed in \code{dat$POOL}. Requires two columns: \cr
#' \enumerate{
#'    \item \code{$POOL} The pools listed in \code{$dat$POOL}.
#'    \item \code{$INDS} The number of diploid individuals for the pools.
#' }
#'
#' @param num.sims Integer: The number of bootstrap simulations to run. Default = 100.
#'
#' @return Returns a vector of FST values produced by bootstrapping loci in the
#' original read count dataset, \code{dat}.
#'
#' @examples
#' #' # Load in the pool metadata and reads
#' data(genomaliciousInfo)
#' data(genomaliciousReads)
#'
#' # Subset to keep only Rep1 reads.
#' X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
#'
#' # Need to add pool ID.
#' X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
#'
#' # Bootstrap FST
#' bootFST <- poolfstat_boot(X, genomaliciousInfo, 100)
#'
#' @export
poolfstat_boot <- function(dat, pool.info, num.sims=100){
# Get the ID and number of unique loci
idLoci <- unique(dat$LOCUS)
numLoci <- length(idLoci)
# Create a vector to hold bootstrapped FST
bsFst <- numeric()
# Iterate for num.sims
for(i in 1:num.sims){
# Create the bootstrapped loci names
bsLoci <- data.table(LOCUS.BS=paste0('Locus', 1:numLoci)
, LOCUS.OG=sample(x=idLoci, replace=TRUE)
)
# Create the bootstrapped dataset
bsDat <- apply(bsLoci, 1, function(L){
data.table(LOCUS=L['LOCUS.BS']
, dat[LOCUS==L['LOCUS.OG']
, c('CHROM', 'POS', 'REF', 'ALT', 'POOL', 'DP', 'RO')]
)
})
bsDat <- do.call('rbind', bsDat)
# Calculate FST from the bootstrapped dataset
X <- poolfstat_fromDT(bsDat, pool.info)
bsFst <- c(bsFst, X$Fst$FST)
}
# Return the bootstrapped FST values
return(bsFst)
}
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
library(genomalicious)
data("genomaliciousFreqsLong"
)
dat <- genomalicious4pops
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
genoMat
genoMat[, 1:5]
apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
normalise_patterson(genoMat)
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
normalise_patterson(genoMat)[, 1:4]
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
pca
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
if(scaling=='center'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
}
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
pca
plot(pca)
plot(pca$x)
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
genoMat <- normalise_patterson(genoMat)
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
plot(pca$x)
plot(pca)
genomalicious4pops$SAMPLE
unique(genomalicious4pops$SAMPLE)
#' Conduct a PCA on individual genotypes stored in a data table
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled? Set to
#' \code{'center'} (default) to scale to mean = 0 and variance = 1. Set to
#' \code{'patterson'} to use the Patteron et al. (2006) normalisation.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
pca_DTinds <- function(dat, scaling='center', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
if(!scaling %in% c('center', 'patterson')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
# Scale
if(scaling=='center'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
}
if(scaling=='patterson'){
genoMat <- normalise_patterson(genoMat)
}
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
return(PCA)
}
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
