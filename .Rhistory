}
# Check that axisIndex is only length == 2
if(length(axisIndex)>2){
stop('Argument axisIndex should only contain two integer values.')
}
# Check that look is ggplot or classic.
if(!look%in%c('ggplot', 'classic')){
stop("Argument look is not one of: 'ggplot' or 'classic'.")
}
# If dat is a prcomp obect, and if there is a $pops index in dat,
# assign the pops variable the $pops.
if(class(dat)=='prcomp'){
if(is.null(dat$pops)==FALSE){ pops <- dat$pops}
}
# Check that specified populations in popColours are all in pops.
if(is.null(pops)==FALSE & is.null(popColours)==FALSE &
!sum(names(popColours)%in%unique(pops))==length(unique(pops))){
stop("Argument popColours misspecified: names of colours must be in argument pops.")
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top')
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position='top')
}
# Make dat a data table of PC scores
if(class(dat)=='prcomp'){ plot.tab <- as.data.table(dat$x)
} else{ plot.tab <- as.data.table(dat) }
# If pops has been assigned, add this as a column to new dat
if(is.null(pops)==FALSE){
plot.tab$POPS <- pops
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(type=='scatter'){
# Get axes
axX <- colnames(plot.tab)[axisIndex[1]]
axY <- colnames(plot.tab)[axisIndex[2]]
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY)) + plotTheme
# Add points and population colours if specified
if(is.null(pops)==TRUE){ gg <- gg + geom_point()
} else if(is.null(pops)==FALSE & is.null(popColours)==TRUE){
gg <- gg + geom_point(aes(colour=POPS)) + labs(colour=NULL)
} else if(is.null(pops)==FALSE & is.null(popColours)==FALSE){
gg <- gg + geom_point(aes(colour=POPS)) + scale_colour_manual(values=popColours) + labs(colour=NULL)
}
}
if(type %in% c('scree', 'expvar')){
# Vector of number PCs for X axis
if(class(dat)=='prcomp'){
dat <- dat$sdev^2
X <- 1:length(dat)
} else if(class(dat)=='numeric'){
X <- 1:length(dat)
}
# If explained variance, divide eigenvalues by sum,
# also create Y axis label
if(type=='expvar'){
Y <- 1- dat/sum(dat); axY <- 'Cumulative explained variance'
} else{ Y <- dat; axY <- 'Eigenvalue'}
# The plot
gg <- (ggplot(data.frame(X, Y), aes(x=X, y=Y))
+ plotTheme
+ geom_line()
+ geom_point()
+ labs(x='PC axis', y=axY)
)
}
# Plot and return
plot(gg)
return(gg)
}
pca_plot(pca, type='scree')
pca_plot(pca$sdev^2, type='scree')
pca_plot(pca, type='expvar', look='classic')
pca_plot(pca$sdev^2, type='expvar', look='classic')
pca_plot(pca$sdev^2, type='expvar', look='classic')
pca_plot(pca)
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
pca_plot(pca)
# Get more specific on scatter
pca_plot(pca
, axisIndex=c(2,3)
, pops=pca$pops
, popColours=c(Pop1='gray30', Pop2='royalblue', Pop3='palevioletred3', Pop4='plum2')
, look='classic')
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
X
poolfstat_DT(X, genomalicious_PoolInfo)
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
class(Y)
Y$Fst
Y$pooldat
class(Y$pooldat)
Y$pooldat
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomaliciousReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
poolFst <- poolfstat_DT(X, genomalicious_PoolInfo)
bootFst <- poolfstat_boot(poolFst$pooldat, 100)
bootFst
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
data("genomalicious_4pops")
?genomalicious_4pops
?poolfstat_boot
?idip_DTfreqs
?idip_DTgenos
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=T)}
# Load currently installed genomalicious
library(genomalicious)
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomaliciousReads$SAMPLE)]
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
class(Y)
Y$Fst
class(Y$pooldat)
Y$pooldat
data(genomalicious_PoolInfo)
data(genomalicious_PoolReads)
X <- genomalicious_PoolReads[grep(pattern='Rep1', x=genomalicious_PoolReads$SAMPLE)]
X$POOL <- unlist(lapply(strsplit(X$SAMPLE, '_'), function(X){ return(X[1]) }))
poolFst <- poolfstat_DT(X, genomalicious_PoolInfo)
Y <- poolfstat_DT(X, genomalicious_PoolInfo)
Yboot <- poolfstat_boot(Y$pooldat, 100)
Yboot
quantile(Yboot, c(0.025, 0.975))
genomalicious_PoolInfo
genomalicious_PoolReads
View(normalise_patterson)
data(genomalicious_4pops)
datGt <- genomalicious_4pops
scaling='covar'
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
popCol='POP'
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
dat <- datGt
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
prcomp(genoMat, scale=FALSE, center=FALSE)
# Scale
if(scaling=='covar'){
genoMat <- apply(genoMat, 2, scale, center=FALSE, scale=FALSE)
} else if(scaling=='corr'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
} else if(scaling=='patterson'){
genoMat <- normalise_patterson(genoMat)
}
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
pca
popCol
is.null(popCol)
is.null(popCol)==FALSE
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- subset(unique(popMems))
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(rownames(genoMat), popMems[[sampCol]])]
}
pca$pops
genoMat
genoMat[, 1:5]
DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')[, 1:3]
row.names(genoMat)
rownames(genoMat)
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# Get individuals in rows
sampRos <- rownames(genoMat)
# Get individuals in rows
sampRows <- rownames(genoMat)
rownames(genoMat) <- sampRows
genoMat
genoMat[,1:4]
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- subset(unique(popMems))
popMems
match(sampRows, popMems[[sampCol]]
)
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
unique(popMems)
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- unique(popMems)
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(sampRows, popMems[[sampCol]])]
pca$pops
#' Perform the Patterson et al. (2006) normalisation to a genotype matrix
#' @param dat Matrix: Counts of Ref allele per individual (0, 1, or 2)
#' , e.g. the C(i,j) table described in Patterson et al. (2006).
#'
#' @return Returns a matrix with the same deminsions as \code{dat}, but with
#' genotypes normalised.
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @export
normalise_patterson <- function(dat){
# Iterate over each j locus, normalise genotypes
M <- apply(dat, 2, function(j){
# Locus j correction factor ("mean genotype")
u <- sum(j)/length(j)
# The underlying allele frequency
p <- u/2
# The normalised genotypes
corrected_genos <- j - u
drift_effect <- sqrt(p * (1-p))
return(corrected_genos/drift_effect)
})
return(M)
}
pca_DTgenos <- function(dat, scaling='covar', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', popCol=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# Get individuals in rows
sampRows <- rownames(genoMat)
# Scale
if(scaling=='covar'){
genoMat <- apply(genoMat, 2, scale, center=FALSE, scale=FALSE)
} else if(scaling=='corr'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
} else if(scaling=='patterson'){
genoMat <- normalise_patterson(genoMat)
}
rownames(genoMat) <- sampRows
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- unique(popMems)
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(sampRows, popMems[[sampCol]])]
}
return(pca)
# ........... END
}
data(genomalicious_4pops)
datGt <- genomalicious_4pops
pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
pca_plot(pca)
pca_DTgenos(dat=datGt[POP %in% c('Pop3', 'Pop4')], scaling='patterson', popCol='POP')
pcaPat <- pca_DTgenos(dat=datGt[POP %in% c('Pop3', 'Pop4')], scaling='patterson', popCol='POP')
pcaCov <- pca_DTgenos(dat=datGt[POP %in% c('Pop3', 'Pop4')], scaling='covar', popCol='POP')
summary(pcaPat)
summary(pcaCov)
#' Conduct a PCA on individual genotypes stored in a (long) data table
#'
#' Takes a long data table of genotypes and conducts a PCA using R's
#' \code{prcomp()} function. Different options for scaling the genotypes
#' pre-PCA are available.
#'
#' @param dat Data table: A long data table, e.g. like that imported from
#' \code{vcf2DT}.
#'
#' @param scaling Character: How should the data (loci) be scaled?
#' Set to \code{'covar'} to scale to mean = 0, but variance is not
#' adjusted, i.e. PCA on a covariance matrix. Set to \code{'corr'}
#' to scale to mean = 0 and variance = 1, i.e. PCA on a
#' correlation matrix. Set to \code{'patterson'} to use the
#' Patteron et al. (2006) normalisation. Set to \code{'none'} to
#' if you do not want to do any scaling before PCA.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default is \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype information.
#' Default is \code{'GT'}.
#'
#' @param popCol Character: An optional argument. The column name with the
#' population information. Default is \code{NULL}. If specified, population
#' membership is stored in the returned object.
#'
#' @return Returns a \code{prcomp} object. If argumet \code{popCols} was specified,
#' and additional index of \code{$pops} is also also present.
#'
#' @references
#' Patterson et al. (2006) Population structure and eigenanalysis. PLOS Genetics.
#'
#' @examples
#' # Data
#' data(genomalicious_4pops)
#' datGt <- genomalicious_4pops
#'
#' # Conduct the PCA with Patterson et al.'s (2006) normalisation, and
#' # population specified
#' pca <- pca_DTgenos(dat=datGt, scaling='patterson', popCol='POP')
#'
#' # Plot the PCA
#' pca_plot(pca)
#'
#' @export
pca_DTgenos <- function(dat, scaling='covar', sampCol='SAMPLE'
, locusCol='LOCUS', genoCol='GT', popCol=NULL){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
if(!scaling %in% c('covar', 'corr', 'patterson', 'none')){
stop('Argument scaling is invalid')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert to a genotype matrix
genoMat <- DT2Mat_genos(dat
, sampCol=sampCol
, locusCol=locusCol
, genoCol=genoCol
, genoScore='counts')
# Get individuals in rows
sampRows <- rownames(genoMat)
# Scale
if(scaling=='covar'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=FALSE)
} else if(scaling=='corr'){
genoMat <- apply(genoMat, 2, scale, center=TRUE, scale=TRUE)
} else if(scaling=='patterson'){
genoMat <- normalise_patterson(genoMat)
}
rownames(genoMat) <- sampRows
# The PCA
pca <- prcomp(genoMat, scale=FALSE, center=FALSE)
# Was the population ID column specified?
if(is.null(popCol)==FALSE){
# Get population memberships for each sample
popMems <- dat[, c(popCol, sampCol), with=FALSE]
popMems <- unique(popMems)
# Match individuals in rows from genoMat with popMems
pca$pops <- popMems[[popCol]][match(sampRows, popMems[[sampCol]])]
}
return(pca)
# ........... END
}
pcaPat <- pca_DTgenos(dat=datGt[POP %in% c('Pop3', 'Pop4')], scaling='patterson', popCol='POP')
pcaCov <- pca_DTgenos(dat=datGt[POP %in% c('Pop3', 'Pop4')], scaling='covar', popCol='POP')
summary(pcaPat)[, 1:3]
summary(pcaPat)
summary(pcaCov)
install.packages("RMTstat")
library(LEO)
library(LEA)
?tracy.widom()
?tracy.widom
View(tracy.widom)
plot(pcaPat$x, pch=21, bg=as.factor(pcaPat$pops))
plot(pcaCov$x, pch=21, bg=as.factor(pcaCov$pops))
plot(pcaPat$x[,1], pcaCov$x[,1])
library(RMTstat)
d <- rtw(1000)
plot(d)
hist(d)
density(d)
c <- density(d)
c$x
plot(c$x, c$y)
line(c$x, c$y)
hist(d)
line(c$x, c$y)
lines(c$x, c$y)
plot(c$x, c$y)
plot(c)
d1 <- rtw(1000, 1)
d2 <- rtw(1000, 2)
d3 <- rtw(1000, 3)
d3 <- rtw(1000, 4)
c <- density(d)
c1 <- density(d1)
c2 <- density(d2)
c4 <- density(d4)
plot(c1)
lines(c2)
lines(c4)
c4 <- density(d4)
d4 <- rtw(1000, 4)
c4 <- density(d4)
lines(c4)
d1 <- rtw(1000, 1)
d2 <- rtw(1000, 2)
d4 <- rtw(1000, 4)
hist(d)
c1 <- density(d1)
c2 <- density(d2)
c4 <- density(d4)
plot(c1, col='red', ylim=c(0, 0.6))
lines(c2, col='black')
lines(c4, col='blue')
d1 <- rtw(5000, 1)
d2 <- rtw(5000, 2)
d4 <- rtw(5000, 4)
hist(d)
c1 <- density(d1)
c2 <- density(d2)
c4 <- density(d4)
plot(c1, col='red', ylim=c(0, 0.6))
lines(c2, col='black')
lines(c4, col='blue')
d1 <- rtw(5000, 1)
d2 <- rtw(5000, 2)
d4 <- rtw(5000, 4)
c1 <- density(d1)
c2 <- density(d2)
c4 <- density(d4)
plot(c1, col='red', ylim=c(0, 0.6))
lines(c2, col='black')
lines(c4, col='blue')
0.084 > d1
sum(0.084 > d1)/length(d1)
ptw(0.084, 1)
ptw(0.084, 1, lower.tail = FALSE)
sum(0.084 < d1)/length(d1)
ptw(0.084, 1, lower.tail = FALSE)
# Make documents
roxygenise('./', clean=TRUE)
library(genomalicious)
