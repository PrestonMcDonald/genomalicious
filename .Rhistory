#'
#' @param boots Integer: The number of bootstrap replicates. Default = 100.
#'
#' @param doDist Logical: Should a a distance matrix of FST be returned?
#' Default = \code{FALSE}. Only applied when \code{doPairs==TRUE}.
#'
#' @param perLocus Logical: Should the per locus FST be returned?
#' Default = \code{FALSE}.
#'
#' @return A list with up to three different indices.
#' \enumerate{
#'    \item \code{$fst.mean}: contains the mean FST across loci. For among populations,
#'          this is a vector, whereas for pairwise analyses it is a data table
#'          with a \code{$POP1}, \code{$POP2}, and \code{$FST} column.
#'    \item \code{$fst.locus}: contains the locus-specific FST values
#'          if \code{perLocus==TRUE}. For amonong populations, this is a vector,
#'          but for pairwise analyses, this is a data table with population pairs.
#'    \item \code{$fst.dist}: will contain a distance matrix of FST values
#'          if \code{doPairs==TRUE} and \code{doDist==TRUE}.
#'
#' @references
#' Weir, Cockerham (1984) Estimating F-statistics for the analysis of population structure. Evol. \cr
#' Weir, Hill (2002) Estimating F-statistics. Annu. Rev. Genet
#'
#' @examples
#' data(genomalicious_Freqs)
#' freqMat <- genomalicious_Freqs
#' sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
#' rownames(sampMat) <- paste0('Pop', 1:4)
#' colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
#'
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
#' fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
#'
#' @export
fstWC_freqs <- function(freqMat, sampMat, doPairs=FALSE, bootCI=FALSE, boots=100, doDist=FALSE, perLocus=FALSE){
# --------------------------------------------+
# Assertions and environment
# --------------------------------------------+
require(data.table)
# Check dimensions
if(sum(dim(freqMat) == dim(sampMat))!=2){
stop('The dimensions of arguments freqMat and sampMat are not equivalent.')
}
# Check class
if(sum(c(class(freqMat), class(sampMat))=='matrix')!=2){
stop('Arguments freqMat and sampMat must both be matrices.')
}
# Check all samples and loci are present in both matrices
if(sum(rownames(freqMat) %in% rownames(sampMat))!=nrow(sampMat)){
stop('Make sure all row names in freqMat are also in sampMat.')
}
if(sum(colnames(freqMat) %in% colnames(sampMat))!=ncol(sampMat)){
stop('Make sure all column names in freqMat are also in sampMat.')
}
if(doDist==TRUE & doPairs==FALSE){
warning('Argument doDist set to TRUE, but doPairs set to FALSE: Will
only calcualte a distance matrix for pairwise analyses.')
}
# Make sure sampMat and freqMat are in the same order row-wise
sampMat <- sampMat[rownames(freqMat), ]
# Output list
fstList <- list()
# --------------------------------------------+
# Code: FST among all populations
# --------------------------------------------+
# Calculate among populations
if(doPairs==FALSE){
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat, input_type='freqs', samp_size=sampMat)
# Theta across loci
fstList$multilocus.mean <- sum(lociVar$NUMER) / sum(lociVar$DENOM)
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat, samp_size=sampMat, input_type='freqs')
fstList$multilocus.boot <- fst.boot
fstList$multilocus.ci <- quantile(fst.boot, c(0.025, 0.975))
}
# Theta per locus
if(perLocus==TRUE){
fst.locus <- lociVar$NUMER / lociVar$DENOM
names(fst.locus) <- lociVar$LOCUS
fstList$perlocus <- fst.locus
}
# Return among population analyses
return(fstList)
}
# --------------------------------------------+
# Code: FST between population pairs
# --------------------------------------------+
if(doPairs==TRUE){
# Population pairs
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairList <- apply(pairCombos, 2, function(X){
# Output for each Xth pair
Xlist <- list()
# Pair ID
pair_id <- paste(X, collapse='/')
# Calculate variance per locus
lociVar <- fstWC_varcomps(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,])
# Theta across loci
Xlist$mean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Bootstrap theta
if(bootCI==TRUE){
fst.boot <- fstWC_boot(dat=freqMat[X,], input_type='freqs', samp_size=sampMat[X,], boots=boots)
fst.ci <- quantile(fst.boot, c(0.025, 0.975))
Xlist$boots <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], BOOT=1:boots, FST=fst.boot)
Xlist$ci <- data.table(PAIR=pair_id, POP1=X[1], POP2=X[2], CI025=fst.ci[1], CI975=fst.ci[2])
}
# Theta per locus
if(perLocus==TRUE){
Xlist$perlocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
}
# Return the data for Xth pair
return(Xlist)
})
# Combine multilocus estimates
fstList$multilocus.mean <- do.call('rbind', lapply(pairList, function(xx){ xx$mean }))
# Combine bootstrap replicates
if(bootCI==TRUE){
fstList$multilocus.boot <- do.call('rbind', lapply(pairList, function(xx){ xx$boot }))
fstList$multilocus.ci <- do.call('rbind', lapply(pairList, function(xx){ xx$ci }))
}
# If an FST distance matrix was requested:
if(doDist==TRUE){
# Empty matrix
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
# Get the pairwise info and fill the distance matrix
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fstList$multilocus.mean[POP1==pop1 & POP2==pop2]$FST
}
# Add to the output list
fstList$multilocus.dist <- as.dist(fst.dist, diag=TRUE)
}
# Combine the per locus estimates
if(perLocus==TRUE){
fstList$perlocus <- do.call('rbind', lapply(pairList, function(xx){ xx$perlocus }))
}
# Return pairwise analyses
return(fstList)
}
}
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=FALSE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE)
fstWC_freqs(freqMat=freqMat, sampMat=sampMat, doPairs=TRUE, doDist=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
roxygenise()
library(genomalicious)
?fstWC_genos
?fstWC_varcomps
?fstWC_boot
View(fstWC_boot)
?fstWC_perm
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
roxygenise()
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
#' Parametric bootstrap of \code{poolne_estim} allele frequencies
#'
#' Takes the results of \code{poolne_estim} (Gautier et al. 2013) and
#' performs a parametric bootstrap of Ref allele frequencies based on their
#' pi (estimated Ref allele frequency) and sd (the standard deviation).
#'
#' @param dat Data table: the \code{poolne_estim} data. For example, the
#' output from \code{genomalicious::poolne_estim_output()}. Requires 4 columns: \cr
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$PI}, the estimated population frequency for the Ref allele. \cr
#'    \item \code{$SD}, the standard deviation for PI.
#' }
#'
#' @param num.sims Numeric, the number of simulations to generate. Default = \code{100}.
#'
#' @return A data table, with the following columns:
#' \enumerate{
#'    \item \code{$POOL}, the population pool ID. \cr
#'    \item \code{$LOCUS}, the locus ID. \cr
#'    \item \code{$BOOT.NUM}, the simulation number. \cr
#'    \item \code{$BOOT.PI}, the simulated pi (Ref allele frequency).
#' }
#'
#' @details The values of \code{PI} and \code{SD} in \code{dat} are used to generate
#' the alpha and beta paramters of a beta distribution, where: \cr
#' \cr
#' \code{alpha = ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2} \cr
#' \code{beta = alpha * (1 / Mu - 1)} \cr
#' \cr
#' Here, values of \code{dat$PI} take on the values of \code{Mu} (the mean) and
#' \code{(dat$SD)^2} take on the values of \code{Var} (the variance). \cr
#' \cr
#' From the resulting beta distribution, \code{num.sims} values are drawn to create
#' a distribution of possible allele frequencies (for each locus) that might exist in the sampled
#' populations (given the associated mean and error estimated by \code{poolne_estim}).
#'
#' @examples
#' # Create a link to raw external datasets in genomalicious
#' genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
#'
#' # Get the poolne estimat pi estimates
#' pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
#'
#' # Simulate potential distributions
#' pi.sims <- poolne_estim_boot_pi(pi.data, 100)
#' pi.sims
#'
#' @export
poolne_estim_boot_pi <- function(dat, num.sims=100){
# BEGIN ...................
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'pbapply')){ require(lib, character.only=TRUE)}
# Check the class of dat.
if(!'data.table' %in% class(dat)){
stop("Argument dat needs to be class 'data.table'.")
}
# Check that the correct columns are in dat.
if(length(which((c('POOL', 'LOCUS', 'PI', 'SD') %in% colnames(dat))==FALSE)) > 0){
stop("Argument dat needs the columns $POOL, $LOCUS, $PI, and $SD.")
}
# --------------------------------------------+
# Internal function
# --------------------------------------------+
beta_est <- function(Mu, Var) {
# Estimates beta distribution shape params from the mean and variance of
# a sample.
#
# INPUTS:
#   Mu    (numeric)   The sample mean
#   Var   (numeric)   The sample variance
#
# OUTPUTS:
#   A list: $alpha = alpha param, $beta = beta param
# BEGIN ............
alpha <- ((1 - Mu) / Var - 1 / Mu) * Mu ^ 2
beta <- alpha * (1 / Mu - 1)
return(params = list(alpha = alpha, beta = beta))
# ............ END
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get index for PI and SD
index.pi <- which(names(dat)=='PI'); index.sd <- which(names(dat)=='SD')
# Split the dataset on LOCUS
dat.spl <- split(dat, dat$LOCUS)
# This function works on each LOCUS
cat('Conducting parametric bootstrap on observed frequencies', sep='\n')
freq.sims <- pblapply(dat.spl, function(W){
# This function work on each POOL (i.e. the rows). Subset W so it only contains
# PI (columns = 1) and SD (column = 2)
Y <- apply(W[,c('POOL','LOCUS','PI','SD')], 1, function(X){
# Calculate the beta shape params (alpha and beta) from PI and SD (square SD to
# make it into variance).
beta.params <- beta_est(as.numeric(X['PI']), as.numeric(X['SD'])^2)
# Generate a vector of length num.sims of pi values from a beta distribution
# using the calculated shape params
pi.sims <- rbeta(num.sims, beta.params$alpha, beta.params$beta)
# Return the vector of simulated pi values.
return(data.table(POOL=X['POOL'], LOCUS=X['LOCUS']
, BOOT.NUM=1:num.sims, BOOT.PI=pi.sims))
})
# Return locus simulations
return(do.call('rbind', Y))
})
# Return final dataset
return(do.call('rbind', freq.sims))
# ................... END
}
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
roxygenise()
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
pi.data <- poolne_estim_output(stat='pi', datDir=genomaliciousExtData, lociDir=genomaliciousExtData)
pi.sims <- poolne_estim_boot_pi(pi.data, 100)
pi.sims
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
install.packages('pbapply')
roxygenise()
install.packages('gridExtra')
roxygenise()
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), 'inst/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath)
# Now read it in as a data table
readVcf1 <- vcf2DT(vcfPath)
readVcf1
# Create a link to raw external datasets in genomalicious
genomaliciousExtData <- paste0(find.package('genomalicious'), 'inst/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath)
genomaliciousExtData <- paste0(find.package('genomalicious'), 'inst/extdata')
list.files(genomaliciousExtData, pattern='_poolseq.vcf')
list.files(genomaliciousExtData, pattern='indseq.vcf')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
list.files(path=genomaliciousExtData)
genomaliciousExtData <- paste0(find.package('genomalicious'), 'inst/extdata')
genomaliciousExtData
genomaliciousExtData
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), 'inst/extdata')
genomaliciousExtData
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
genomaliciousExtData <- paste0(find.package('genomalicious'), '/inst/extdata')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
genomaliciousExtData
list.files(path=genomaliciousExtData)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
vcfPath <- paste0(genomaliciousExtData, '/genomalicious_poolseq.vcf')
vcfFile=vcfPath
vcfValues=list(loci='LOCUS'
, variants=c('CHROM', 'POS', 'REF', 'ALT')
, format=c('GT', 'DP', 'RO', 'AO')
, samples='SAMPLE')
keepInfo=FALSE)
keepInfo=FALSE
keepComments=FALSE
dropCols=NULL
readLines(vcfPath)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table)
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- cbind(LOCUS=vcfDT[, paste(CHROM, POS, sep='_')], vcfDT)
# Get the locus info as a vector and drop from data table
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(data=vcfDT, id.vars=1:(sampCols[1]-1), measure.vars=sampCols, variable.name='SAMPLE', value.name='DATA')
vcfDT
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
vcfDT <- cbind(vcfDT, as.data.table(formatDat))
vcfDT
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
formatDat[which(formatDat=='.')] <- NA
formatDat
vcfDT <- cbind(vcfDT, as.data.table(formatDat))
vcfDT[, strsplit(DATA, ':')]
strsplit(DATA, ':')
vcfDT[, strsplit(DATA, ':')]
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat
# Split the $FORMAT column, identify NAs, rotate, rename columns, and bind.
formatDat <- t(vcfDT[, strsplit(DATA, ':')])
formatDat[which(formatDat=='.')] <- NA
colnames(formatDat) <- unlist(strsplit(vcfDT$FORMAT[1], ':'))
formatDat
vcfDT
head(vcfDT)
head(formatDat)
getwd()
setwd('../genomalicious/inst/extdata/')
list.files()
setwd('C:\Users\jt101\Documents\GitHub\genomalicious\inst\extdata')
list.files()
f <- list.files()
n <- gsub('genomalicious_', 'data_', f)
n
file.rename(from=f, to=n)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyr')
for(L in libs){require(L, character.only=TRUE)}
# Make pool info data
data_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(data_PoolInfo, file='data/data_PoolInfo.RData')
setwd()
setwd('../../')
# Make pool info data
data_PoolInfo <- data.table(POOL=paste0('Pop', 1:4), INDS=30)
save(data_PoolInfo, file='data/data_PoolInfo.RData')
# Make pool reads data
data_PoolReads <- fread('inst/extdata/data_PoolReads.csv')
save(data_PoolReads, file='data/data_PoolReads.RData')
refalt <- unique(data_PoolReads[, c('LOCUS', 'REF', 'ALT')])
# Make pool ref allele (pi) frequency estimate data
data_PoolPi <- fread('inst/extdata/data_PoolPi.csv')
data_PoolPi <- cbind(data_PoolPi, refalt[match(data_PoolPi$LOCUS, refalt$LOCUS), c('REF', 'ALT')]
, INDS=data_PoolInfo$INDS[match(data_PoolPi$POOL, data_PoolInfo$POOL)]
)
save(data_PoolPi, file='data/data_PoolPi.RData')
# Make a wide matrix of allele frequencies
data_Freqs <- as.data.frame(
spread(fread('inst/extdata/data_PoolPi.csv')[, c('POOL', 'LOCUS', 'PI')]
, key=LOCUS, value=PI))
rownames(data_Freqs) <- data_Freqs$POOL
data_Freqs <- as.matrix(data_Freqs[, -which(colnames(data_Freqs)=='POOL')])
save(data_Freqs, file='data/data_Freqs.RData')
# Make the 4 pop genotype dataset
data_4pops <- readRDS('inst/extdata/data_FastSimCoal_30Diploids.RDS')
setnames(data_4pops, c('IND', 'GENO'), c('SAMPLE', 'GT'))
data_4pops$GT[data_4pops$GT=='1/0'] <- '0/1'
goodloci <- filter_maf(data_4pops, 0.01, 'genos')
data_4pops <- data_4pops[LOCUS %in% goodloci]
save(data_4pops, file='data/data_4pops.RData')
# Make a VCF from 4 pop genotypes
data("data_4pops")
sub4pops <- data_4pops[
LOCUS %in% sample(x=unique(data_4pops$LOCUS), size=8, replace=FALSE)
& SAMPLE %in% data_4pops[, unique(SAMPLE)[1:8], by=POP]$V1, ]
sub4pops[, DP:=rnbinom(nrow(sub4pops), mu=30, size=1)]
hist(sub4pops$DP)
sub4pops[, DP:=rnbinom(nrow(sub4pops), mu=30, size=2)]
hist(sub4pops$DP)
sub4pops[, DP:=rnbinom(nrow(sub4pops), mu=30, size=1)]
hist(sub4pops$DP)
sub4pops[, DP:=rnbinom(nrow(sub4pops), mu=30, size=2)]
hist(sub4pops$DP)
sub4pops[, RO:=sum(rbinom(DP, size=1, prob=0.5)), by=c('SAMPLE', 'LOCUS')]
sub4pops[, RO:=sum(rbinom(DP, size=1, prob=1)), by=c('SAMPLE', 'LOCUS')]
sub4pops[, AO:=DP-RO]
badDP4pops <- which(sub4pops$DP==0 | sub4pops$DP==1)
sub4pops$GT[badDP4pops] <- './.'
vcf4pops <- do.call('rbind', lapply(unique(sub4pops$LOCUS), function(locus){
X <- sub4pops[LOCUS==locus]
alleles <- sample(size=2, x=c('G', 'A', 'T', 'C'), replace=FALSE)
col_names <- c('CHROM', 'POS', 'ID', 'REF', 'ALT', 'QUAL', 'FILTER', 'INFO', 'FORMAT', X$SAMPLE)
vcfRow <- matrix('.', nrow=1, ncol=9+nrow(X), dimnames=list(NULL, col_names))
vcfRow[,'CHROM'] <- X$CHROM[1]
vcfRow[1,'POS'] <- strsplit(locus, '_')[[1]][3]
vcfRow[1,'REF'] <- alleles[1]
vcfRow[1,'ALT'] <- alleles[2]
vcfRow[1,'INFO'] <- paste0('DP=', sum(X$DP))
vcfRow[1,'QUAL'] <- 30
vcfRow[1,'FORMAT'] <- 'GT:DP:RO:AO'
for(samp in unique(X$SAMPLE)){
xsamp <- unlist(X[SAMPLE==samp, c('GT', 'DP', 'RO', 'AO')])
vcfRow[, samp] <- paste(xsamp, collapse=':')
}
return(vcfRow)
}))
fwrite(vcf4pops, 'inst/extdata/data_indseq.vcf', sep='\t')
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
