#' @param biallelic Logical: Is the data biallelic? If alleles separated
#' by '/' (character vector), expect \code{dat} to take form: '0/0', '0/1', or '1/1'.
#' If alleles coded as counts of Ref allele, expect \code{dat} to take form:
#' 0, 1, or 2. Default =\code{TRUE}.
#'
#' @return A vector of alleles counts.
#'
#' @examples
#' allele_counts(c('1/1', '0/1', '0/1', '0/0', '0/0'))
#' allele_counts(c('1/1', '2/3', '1/3', '0/0', '2/2'), biallelic=FALSE)
#' allele_counts(c(2, 1, 1, 0, 2))
#'
#' @export
allele_counts <- function(dat, biallelic=TRUE){
# --------------------------------------------+
# Libraries and assertins
# --------------------------------------------+
# Get the alleles
als <- unlist(strsplit(dat, split='/'))
# Get unique allelles
uniqAls <- unique(als)
if(class(dat)=='numeric'){ dat <- as.integer(dat)}
if(length(uniqAls)==2 & sum(c('1', '0') %in% uniqAls)==1 & biallelic==FALSE){
warning('Argument biallelic==FALSE, but argument dat looks biallelic.')
}
if(length(uniqAls)>2){ biallelic <- FALSE }
if(class(dat)=='integer' & biallelic==FALSE){
stop('Argument dat is an integer, and argument biallelic==FALSE.
Cannot count alleles in dat if there are >2 alleles.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Sample size
n <- length(dat)*2
# If given a character vector:
if(class(dat)=='character'){
# If data is biallelic
if(biallelic==TRUE){
ref <- sum(genoscore_converter(dat))
alt <- n - ref
return(c(ref=ref, alt=alt))
# Else, if >2 alleles
} else{
tab <- table(als)
vec <- as.vector(tab)
names(vec) <- names(tab)
return(vec)
}
# If given counts of bialleles
} else if(class(dat)=='integer'){
ref <- sum(dat)
alt <- n - ref
return(c(ref=ref, alt=alt))
}
}
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
als <- do.call('rbind', als)
# For each locus, get Ref and Alt allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
als <- list(allele_counts(snpDat[LOCUS==locus & POP==pop]$GT), c('1'=6, '0'=5))
als
uniqAls <- unlist(unique(als))
uniqAls
unlist(als)
names(unlist(als))
uniqAls <- unique(names(unlist(als)))
uniqAls
lapply(als, function(pop){
pop[uniqueAls]
})
lapply(als, function(pop){
pop[uniqAls]
})
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
})
x <- pop[uniqAls]
names(x) <- uniqAls
x
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
# is.na(x) <- 0
})
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
return(x)
})
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
x
pop <- als[[2]]
pop
x <- pop[uniqAls]
names(x) <- uniqAls
is.na(x) <- 0
x
x
is.na(x)
lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
als
als <- do.call('rbind', als)
rownames(als) <- uniqPops
data(genomalicious_4pops)
snpDat <- genomalicious_4pops
strucMat <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
# Population check
uniqPops <- unique(snpDat$POP)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
lociDivpar[,1:4]
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=strucMat
, popCol='POP', locusCol='LOCUS', genoCol='GT')
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=strucMat
, popCol='POP', locusCol='LOCUS', genoCol='GT')
metapop <- matrix(c(rep('metapop', 4)
, paste('Group', c(1,1,2,2))
, paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#' Calculate diversity statistics with \code{IDIP} from a data table of genotypes
#'
#' @param snpDat Data table: a long-format data table with SNP genotypes
#' coded as per VCF specifications, e.g. ('0/0', '0/1', '1/1').
#' Three columns are required:
#' \enumerate{
#'    \item (1) The population ID (see param \code{popCol}).
#'    \item (2) The locus ID (see param \code{locusCol}).
#'    \item (3) The genotype (see param \code{genoCol}).
#' }
#'
#' @param strucMat Matrix: Hierarchy of "aggregates", minimum of 2 rows and
#' as many columns as the lowest units of the hierarchy. 1st row is the top most
#' level (e.g. ecosystem or metapopulation), with lower levels in proceding rows.
#'
#' @param popCol Character: The column name with the population information, i.e.
#' the lowest levels of the population hierarchy (last row of \code{strucMat}).
#'
#' @param locusCol Character: The column name with the locus information.
#'
#' @param genoCol Character: The column name with the genotype information.
#'
#' @return A matrix with columns representing loci, rows are the statistics
#' from the \code{IDIP} analysis.
#'
#' @examples
#' data(genomalicious_4pops)
#'
#' # Create a population hierarchy
#' metapop <- matrix(c(rep('metapop', 4)
#'                , paste('Group', c(1,1,2,2))
#'                , paste('Pop', 1:4, sep='')), ncol=4, byrow=TRUE)
#'
#' # Run IDIP
#' idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
#'              , popCol='POP', locusCol='LOCUS', genoCol='GT')
#'
#' @export
idip_DTgenos <- function(snpDat, strucMat, popCol='POP'
, locusCol='LOCUS', genoCol='GT'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(libs in c('HierDpart', 'data.table')){ require(libs, character.only=TRUE) }
# Stop if strucMat doesn't meet min rows
if(nrow(strucMat)<2){
stop('Argument strucMat must be a matrix with at least 2 rows.')}
# Population check
uniqPops <- unique(snpDat$POP)
if(sum(uniqPops %in% strucMat[nrow(strucMat),]) < length(uniqPops)){
stop('All unique populations in snpDat must be in the last row (lowest level)
in the strucMat matrix of population aggregate hierarchy.')
}
# Rename columns
colnames(snpDat)[
which(colnames(snpDat)%in%c(popCol, locusCol, genoCol))] <- c(
'POP', 'LOCUS', 'GT')
# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci
uniqLoci <- unique(snpDat$LOCUS)
# Run IDIP for each locus
lociDivpar <- lapply(uniqLoci, function(locus){
# For each locus, get allele counts per population
als <- lapply(uniqPops, function(pop){
allele_counts(snpDat[LOCUS==locus & POP==pop]$GT)
})
uniqAls <- unique(names(unlist(als)))
# Correction in case some alleles are not recorded
# for all populations (mostly a problem for non-biallelic data).
als <- lapply(als, function(pop){
x <- pop[uniqAls]
names(x) <- uniqAls
x[is.na(x)] <- 0
return(x)
})
# Combine into a matrx
als <- do.call('rbind', als)
rownames(als) <- uniqPops
# Run IDIP
idip <- IDIP(abun=t(as.matrix(als)), struc=strucMat)
return(idip)
})
lociDivpar <- do.call('cbind', lociDivpar)
colnames(lociDivpar) <- uniqLoci
return(lociDivpar)
}
idip_DTgenos(snpDat=genomalicious_4pops, strucMat=metapop
, popCol='POP', locusCol='LOCUS', genoCol='GT')
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
library(genomalicious)
library(genomalicious)
freqMat <- genomaliciousFreqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
freqMat <- genomaliciousFreqs
data(genomaliciousFreqs)
data(genomalicious_Freqs)
freqMat <- genomalicious_Freqs
sampMat <- matrix(rep(30, 32), nrow=4, ncol=8)
rownames(sampMat) <- paste0('Pop', 1:4)
colnames(sampMat) <- colnames(freqMat); rownames(sampMat) <- rownames(freqMat)
fstWC(freqMat, sampMat, pairs=FALSE)
fstWC(freqMat, sampMat, pairs=TRUE)
dat <- fstWC(freqMat, sampMat, pairs=TRUE)$fst.mean
dat
matrix(0, nrow=nrow(snpMat), ncol=nrow(snpMat))
matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat))
fstMat <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat))
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
#' Calculate the variance components of Weir & Cockerham's FST
#'
#' @param freqMat Matrix: Ref allele counts. Rows = populations,
#' columns = loci; make sure both are named. Row names used to label output FST matrix.
#'
#' @param sampMat Matrix: Number of sampled individuals. Rows = populations,
#' columns = loci.
fstWC_varcomps <- function(freqMat, sampleMat){
lociNames <- colnames(freqMat)
numPops <- nrow(freqMat)
lociVar <- lapply(lociNames, function(locus){
# Allele frequency and sample size for each ith population
pi <- freqMat[,locus]
ni <- sampMat[,locus]
# Mean weighted allele frequency
p.mean <- sum( pi * (ni/sum(ni)) )
# Sum squared deviations, population
ssp <- sum(ni * (pi - p.mean)^2)
# Variance, gametes
varg <- sum(ni * pi * (1-pi))
# Mean squares variance components
msp <- (1/(length(ni)-1)) * ssp
msg <- (1/sum(ni-1)) * varg
# Sample size correction factor
nc <- (1/(length(ni)-1)) * ( sum(ni) - (sum(ni^2)/sum(ni)) )
# Return the locus specific parameters
return(data.table(LOCUS=locus
, NUMER=msp - msg
, DENOM=msp + (nc-1) * msg))
})
lociVar <- do.call('rbind', lociVar)
return(lociVar)
}
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
fst.mean <- do.call('rbind', lapply(pairLs, function(X){ X$mean}))
fst.locus <- do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
fst.mean
fst.locus
pairCombos[,j]
j <- 1
pairCombos[,j]
fstDist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
fstDist
pop1 <- pairCombos[i,j]
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
pop1
pop2
fst.dist[pop2, pop1]
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
fst.dist[pop2, pop1]
fst.dist[pop2, pop1] <- fst.mean(POP1==pop1 & POP2==pop2)
pairCombos <- combn(x=rownames(freqMat), m=2)
# For the Xth pair
pairLs <- apply(pairCombos, 2, function(X){
# Calculate variance per locus
lociVar <- fstWC_varcomps(freqMat[X,], sampleMat[X,])
# Theta across loci
thetaMean <- data.table(POP1=X[1], POP2=X[2]
, FST=sum(lociVar$NUMER) / sum(lociVar$DENOM))
# Theta per locus
thetaLocus <- data.table(POP1=X[1], POP2=X[2]
, LOCUS=lociVar$LOCUS
, FST=lociVar$NUMER / lociVar$DENOM)
# Return list
return(list(mean=thetaMean, bylocus=thetaLocus))
})
fst.mean <- do.call('rbind', lapply(pairLs, function(X){ X$mean}))
fst.locus <- do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fst.mean(POP1==pop1 & POP2==pop2)
fst.dist[pop2, pop1] <- fst.mean[POP1==pop1 & POP2==pop2]$FST
fst.dist
fst.dist <- matrix(0, nrow=nrow(freqMat), ncol=nrow(freqMat)
, dimnames=list(rownames(freqMat), rownames(freqMat)))
for(j in 1:ncol(pairCombos)){
pop1 <- pairCombos[1,j]
pop2 <- pairCombos[2,j]
fst.dist[pop2, pop1] <- fst.mean[POP1==pop1 & POP2==pop2]$FST
}
fst.dist
as.dist(fst.dist)
as.dist(fst.dist, diag=TRUE)
outLs <- list(fst.mean=do.call('rbind', lapply(pairLs, function(X){ X$mean}))
, fst.locus=do.call('rbind', lapply(pairLs, function(X){ X$bylocus}))
)
outLs
roxygenise('./', clean=TRUE)
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr')
for(L in libs){require(L, character.only=T)}
roxygenise('./', clean=TRUE)
les
#'
#' dat <- genomalicious_4pops
t missing data, by samples
#'
#' dat <- genomalicious_4pops
#' dat
dat
dat <- genomalicious_4pops
dat
by samples
#'
#' dat <- genomalicious_4pops
#' sample(1:nrow(dat)
sample(1:nrow(dat))
nrow(dat)
?sample
sample(1:nrow(dat), size=0.1*nrow(dat), replace=FALSE)
dat <- genomalicious_4pops
missIdx <- sample(1:nrow(dat), size=0.1*nrow(dat), replace=FALSE)
dat$GT[missIds] <- NA
dat$GT[missIds] <- NA
dat$GT[missIdx] <- NA
dat$GT
#' Plot missing data, by samples
#'
dat <- genomalicious_4pops
missIdx <- sample(1:nrow(dat), size=0.15*nrow(dat), replace=FALSE)
dat$GT[missIdx] <- NA
valCol <- 'GT'
type <- 'hist'
stats <- FALSE
rm(valCol)
##############
which(colnames(dat)%in%c(popCol, locusCol, respCol, sampCol))
sampCol <- 'SAMPLE'
respCol <- 'GT'
popCol <- 'POP'
locusCol <- 'LOCUS'
type <- 'hist'
stats <- FALSE
##############
which(colnames(dat)%in%c(popCol, locusCol, respCol, sampCol))
##############
match(c(popCol, locusCol, respCol, sampCol), colnames(dat))
##############
colnames(dat)[
match(c(popCol, locusCol, respCol, sampCol), colnames(dat))
] <- c('POP', 'LOCUS', 'RESP', 'SAMPLE')
dat
dat <- genomalicious_4pops
missIdx <- sample(1:nrow(dat), size=0.15*nrow(dat), replace=FALSE)
dat$GT[missIdx] <- NA
sampCol <- 'SAMPLE'
respCol <- 'GT'
popCol <- NA
locusCol <- 'LOCUS'
type <- 'hist'
stats <- FALSE
##############
colnames(dat)[
match(c(popCol, locusCol, respCol, sampCol), colnames(dat))
] <- c('POP', 'LOCUS', 'RESP', 'SAMPLE')
##############
colnames(dat)[
match(c(locusCol, respCol, sampCol), colnames(dat))
] <- c('LOCUS', 'RESP', 'SAMPLE')
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
dat
is.na(popCol)
dat[, sum(NA), by=SAMPLE]
dat[, sum(RESP), by=SAMPLE]
dat[, is.na(RESP), by=SAMPLE]
dat[, sum(is.na(RESP)), by=SAMPLE]
dat
dat
dat[SAMPLE=='Ind1.115 ']
dat[SAMPLE=='Ind1.115']$RESP
is.na(dat[SAMPLE=='Ind1.115']$RESP)
sum(is.na(dat[SAMPLE=='Ind1.115']$RESP))
dat[, sum(is.na(RESP)), by=SAMPLE]
stats <- dat[, sum(is.na(RESP)), by=c(SAMPLE, POP)]
stats <- dat[, sum(is.na(RESP)), by=c('SAMPLE', 'POP')]
stats
hist(stats$V1)
unique(dat$LOCUS)
length(hist(stats$V1))
length(unique(dat$LOCUS))
261/length(unique(dat$LOCUS))
290/length(unique(dat$LOCUS))
220/length(unique(dat$LOCUS))
roxygenise('./', clean=TRUE)
