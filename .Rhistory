REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
) %>%
return()
}
# .......... END
}
library(genomalicious)
dadi_inputs(dat=data_Genos, popSub=c('Pop1', 'Pop2'))
#' @examples
#' library(genomalicious)
#'
#' data(data_Genos)
#' datGt <- copy(data_Genos)
#'
#' # Make the dadi input
#' dadi_inputs(dat=data_Genos, popSub=c('Pop1', 'Pop2'))
#'
#' @export
dadi_inputs <- function(
dat, type, sampCol='SAMPLE', popCol='POP', locusCol='LOCUS',
refCol='REF', altCol='ALT', genoCol='GT', freqCol='FREQ', indsCol='INDS',
freqMethod='probs', popSub=NULL, popLevels=NULL
){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
for(lib in c('data.table', 'dplyr')){ require(lib, character.only = TRUE)}
# Reassign names
if(type=='genos'){
colReass <- match(c(sampCol, popCol, locusCol, refCol, altCol, genoCol), colnames(dat))
colnames(dat)[colReass] <- c('SAMPLE', 'POP', 'LOCUS', 'REF', 'ALT', 'GT')
}
if(type=='freqs'){
colReass <- match(c(popCol, locusCol, refCol, altCol, freqCol, indsCol), colnames(dat))
colnames(dat)[colReass] <- c('POP', 'LOCUS', 'REF', 'ALT', 'FREQ', 'INDS')
}
# Sub out the populations if specified
if(is.null(popSub)==FALSE){
dat <- dat[POP %in% popSub]
}
# Genotype scores
if(type=='genos'){
# Get the class of the genotypes
gtClass <- class(dat$GT)
# Check that genotypes are characters or counts
if(!gtClass %in% c('character', 'numeric', 'integer')){
stop("Check that genotypes are coded as '/' separated characters or as
counts of the Alt allele.")
}
# Convert characters of separated alleles to counts
if(gtClass=='character'){
dat$GT <- genoscore_converter(dat$GT)
}
# Convert numeric allele counts to integers
if(gtClass=='numeric'){
dat$GT <- as.integer(dat$GT)
}
}
# Check that the `freqMethod` argument has been assigned properly for
# allele frequency estimates
if((freqMethod %in% c('counts', 'probs'))==FALSE & type=='freqs'){
stop(
"Argument `freqMethod` must be 'probs' or 'counts' for allele frequency
data. See ?dadi_inputs_freqs.")
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# For genotype data
if(type=='genos'){
r <- spread(dat[, (length(SAMPLE)*2) - sum(GT), by=c('LOCUS', 'POP', 'REF')]
, key='POP', value='V1')
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[, sum(GT), by=c('LOCUS', 'POP', 'ALT')], key='POP', value='V1')
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
if(!is.null(popLevels)){
r <- r[, c('LOCUS','Allele1',popLevels),with=FALSE]
a <- a[, c('LOCUS','Allele2',popLevels),with=FALSE]
}
return(
data.table(REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS)
)
}
# For allele frequencies
if(type=='freqs'){
# Simple REF counts
if(freqMethod=='counts'){
# Convert frequency into estimated counts of individuals with each allele
dat$REF.COUNT <- apply(dat[, c('FREQ', 'INDS')], 1, function(X){
p <- X[['FREQ']]
inds <- X[['INDS']]
ref.count <- p * (inds * 2)
if(p != 0 & ref.count < 1){ ref.count <- 1
} else if(p != 1 & ref.count < 1){ ref.count <- 1
} else{ ref.count <- round(ref.count)
}
return(ref.count)
})
}
# Probabilistic REF counts
if(freqMethod=='probs'){
# Get probabilistic counts of alleles using binomial draws
dat$REF.COUNT <- apply(dat[, c('FREQ', 'INDS')], 1, function(X){
rbinom(n=1, size=X['INDS']*2, prob=X['FREQ'])
})
}
# Get the ALT allele counts
dat[, ALT.COUNT:=(INDS*2)-REF.COUNT]
# Some manipulations
r <- spread(dat[,c('LOCUS', 'REF', 'POP', 'REF.COUNT')], key=POP, value=REF.COUNT)
setorder(r, 'LOCUS'); setnames(r, 'REF', 'Allele1')
a <- spread(dat[,c('LOCUS', 'ALT', 'POP', 'ALT.COUNT')], key=POP, value=ALT.COUNT)
setorder(a, 'LOCUS'); setnames(a, 'ALT', 'Allele2')
if(!is.null(popLevels)){
r <- r[, c('LOCUS','Allele1',popLevels),with=FALSE]
a <- a[, c('LOCUS','Allele2',popLevels),with=FALSE]
}
# Mash it all together
data.table(
REF=paste0('-', r$Allele1, '-')
, ALT=paste0('-', a$Allele2, '-')
, r[, !'LOCUS']
, a[, !'LOCUS']
, LOCUS=r$LOCUS
) %>%
return()
}
# .......... END
}
dadi_inputs(dat=data_Genos, popSub=c('Pop1', 'Pop2'))
dadi_inputs(dat=data_Genos, type='genos', popSub=c('Pop1', 'Pop2'))
data_Genos
data(data_PoolFreqs)
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
newFreqData
dadi_inputs(newFreqData, type='freqs', freqMethod='probs')
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
df2genind
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# Convert long format data table into a wide matrix
mat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
df2genind
# Create the genind object
genInd <- df2genind(X=mat, sep='/', ind.names=rownames(mat), loc.names=colnames(mat), ploidy=n, NA.char='./.')
dat <- data_Genos
sampCol='SAMPLE'
locusCol='LOCUS'
genoCol='GT'
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert long format data table into a wide matrix
mat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
mat
# Create the genind object
genInd <- df2genind(X=mat, sep='/', ind.names=rownames(mat), loc.names=colnames(mat), ploidy=n, NA.char='./.')
mat
?df2genind
class(dat[[genoCol]])=='integer' | class(dat[[genoCol]])=='numeric'
# What is the genotype scoring method? Convert to characters if needed.
if(class(dat[[genoCol]])=='integer' | class(dat[[genoCol]])=='numeric'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert long format data table into a wide matrix
mat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
mat
# Create the genind object
genInd <- df2genind(X=mat, sep='/', ind.names=rownames(mat), loc.names=colnames(mat), ploidy=n, NA.char='./.')
genInd
# Create the genind object
genInd <- df2genind(X=mat, sep='/', ind.names=rownames(mat), loc.names=colnames(mat), ploidy=2, NA.char='./.')
genInd
genInd@tab
if(is.null(popCol)==FALSE){
# The population and samples
popDat <- unique(dat[, c(sampCol, popCol), with=FALSE])
# Assign
genInd@pop <- as.factor(popDat[[popCol]][match(rownames(mat), popDat$SAMPLE)])
}
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
genoMat <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
genLight <- new('genlight', as.list(as.data.frame(t(genoMat))))
genLight
# Add in locus names
genLight@loc.names <- colnames(genoMat)
genLight
adegenet_DT2genX(data_Genos)
#'
#' data(data_Genos)
#'
#' data_Genos
#'
#' # Genind without and with populations
#' adegenet_DT2genX(data_Genos)
#' adegenet_DT2genX(data_Genos, popCol='POP')
#'
#' @export
adegenet_DT2genX <- function(dat, genX, sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT', popCol=NULL){
for(lib in c('data.table', 'adegenet')){require(lib, character.only=TRUE)}
# Create a genind object
if(genX=='genind'){
# What is the genotype scoring method? Convert to characters if needed.
if(class(dat[[genoCol]])=='integer' | class(dat[[genoCol]])=='numeric'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
# Convert long format data table into a wide matrix
mat <- DT2Mat_genos(dat, sampCol=sampCol, locusCol=locusCol, genoCol=genoCol)
# Create the genind object
genInd <- df2genind(X=mat, sep='/', ind.names=rownames(mat), loc.names=colnames(mat), ploidy=2, NA.char='./.')
# Add in populations?
if(is.null(popCol)==FALSE){
# The population and samples
popDat <- unique(dat[, c(sampCol, popCol), with=FALSE])
# Assign
genInd@pop <- as.factor(popDat[[popCol]][match(rownames(mat), popDat$SAMPLE)])
}
# Output
return(genInd)
}
# Create a genlight object
if(genX=='genlight'){
# What is the genotype scoring method? Convert to counts if needed.
if(class(dat[[genoCol]])=='character'){
dat[[genoCol]] <- genoscore_converter(dat[[genoCol]])
}
genoMat <- DT2Mat_genos(dat, 'SAMPLE', 'LOCUS', 'GT')
genLight <- new('genlight', as.list(as.data.frame(t(genoMat))))
# Add in locus names
genLight@loc.names <- colnames(genoMat)
# Add in populations?
if(is.null(popCol)==FALSE){
# The population and samples
popDat <- unique(dat[, c(sampCol, popCol), with=FALSE])
genLight@pop <- as.factor(popDat[[popCol]][match(genLight@ind.names, popDat[[sampCol]])])
}
# Output
return(genLight)
}
}
adegenet_DT2genX(data_Genos)
adegenet_DT2genX(data_Genos, genX='genInd')
adegenet_DT2genX(data_Genos, genX='genInd')
adegenet_DT2genX(data_Genos, genX='genInd')
adegenet_DT2genX(data_Genos, genX='genind')
adegenet_DT2genX(data_Genos, genX='genind', popCol='POP')
?genpop()
adegenet_DT2genX(data_Genos, genX='genlight')
adegenet_DT2genX(data_Genos, genX='genlight', popCol='POP')
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
library(genomalicious)
PCOA$fst <- pair.fst[['genome']]
PCOA <-pcoa_freqs(newFreqData)
#' @param popCol Character: The column name with the population information.
#' Default is \code{'POP'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param freqCol Character: The column name with the allele freuqency information.
#' Default is \code{'FREQ'}.
#'
#' @param indsCol Character: The column name with the number of individuals
#' contributing to the allele freuqency estimate. Default is \code{indsCol}.
#'
#' @examples
#' data(data_PoolFreqs)
#' data(data_PoolInfo)
#'
#' # Note columns in data_PoolFreqs
#' colnames(data_PoolFreqs)
#'
#' # We need to add in the number of diploid individuals, $INDS
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#' head(newFreqData)
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#'
#' # Fit the PCoA
#' PCOA <-pcoa_freqs(newFreqData)
#'
#' # Ordination
#' PCOA$vectors %>% plot
#'
#' # Eigenvalues
#' PCOA$values
#'
#' # Pairwise FST in long-format data table
#' PCOA$fst
pcoa_freqs <- function(
dat, popCol='POP', locusCol='LOCUS', freqCol='FREQ', indsCol='INDS'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(ape); require(data.table); require(tidyverse)
if(sum(c(popCol,locusCol,freqCol,indsCol) %in% colnames(dat))!=4){
stop(
'Argument `dat` requires columns `popCol`, `locusCol`, `freqCol`, and
`indsCol` to estimate F-statistics from allele frequencies. See ?fstat_calc.')
}
dat <- as.data.table
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
PCOA <- pcoa(pair.mat)
PCOA$vectors %>% pairs
PCOA$fst <- pair.fst[['genome']]
}
PCOA <-pcoa_freqs(newFreqData)
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
data(data_PoolFreqs)
data(data_PoolInfo)
# Note columns in data_PoolFreqs
colnames(data_PoolFreqs)
# We need to add in the number of diploid individuals, $INDS
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
head(newFreqData)
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
# Fit the PCoA
PCOA <-pcoa_freqs(newFreqData)
library(genomalicious)
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
head(newFreqData)
newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
PCOA <-pcoa_freqs(newFreqData)
dat <- as.data.table(dat)
#' @param popCol Character: The column name with the population information.
#' Default is \code{'POP'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param freqCol Character: The column name with the allele freuqency information.
#' Default is \code{'FREQ'}.
#'
#' @param indsCol Character: The column name with the number of individuals
#' contributing to the allele freuqency estimate. Default is \code{indsCol}.
#'
#' @examples
#' library(genomalicious)
#' data(data_PoolFreqs)
#' data(data_PoolInfo)
#'
#' # Note columns in data_PoolFreqs
#' colnames(data_PoolFreqs)
#'
#' # We need to add in the number of diploid individuals, $INDS
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#' head(newFreqData)
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#'
#' # Fit the PCoA
#' PCOA <-pcoa_freqs(newFreqData)
#'
#' # Ordination
#' PCOA$vectors %>% plot
#'
#' # Eigenvalues
#' PCOA$values
#'
#' # Pairwise FST in long-format data table
#' PCOA$fst
pcoa_freqs <- function(
dat, popCol='POP', locusCol='LOCUS', freqCol='FREQ', indsCol='INDS'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(ape); require(data.table); require(tidyverse)
if(sum(c(popCol,locusCol,freqCol,indsCol) %in% colnames(dat))!=4){
stop(
'Argument `dat` requires columns `popCol`, `locusCol`, `freqCol`, and
`indsCol` to estimate F-statistics from allele frequencies. See ?fstat_calc.')
}
dat <- as.data.table(dat)
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
PCOA <- pcoa(pair.mat)
PCOA$vectors %>% pairs
PCOA$fst <- pair.fst[['genome']]
}
PCOA <-pcoa_freqs(newFreqData)
PCOA$vectors %>% plot
PCOA <-pcoa_freqs(newFreqData)
PCOA$vectors %>% plot
PCOA$vectors
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
dat <- newFreqData
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
PCOA <- pcoa(pair.mat)
PCOA
PCOA
pair.fst[['genome']]
PCOA$fst <- pair.fst[['genome']]
return(PCOA)
#' @param popCol Character: The column name with the population information.
#' Default is \code{'POP'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default is \code{'LOCUS'}.
#'
#' @param freqCol Character: The column name with the allele freuqency information.
#' Default is \code{'FREQ'}.
#'
#' @param indsCol Character: The column name with the number of individuals
#' contributing to the allele freuqency estimate. Default is \code{indsCol}.
#'
#' @examples
#' library(genomalicious)
#' data(data_PoolFreqs)
#' data(data_PoolInfo)
#'
#' # Note columns in data_PoolFreqs
#' colnames(data_PoolFreqs)
#'
#' # We need to add in the number of diploid individuals, $INDS
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#' head(newFreqData)
#' newFreqData <- left_join(data_PoolFreqs, data_PoolInfo)
#'
#' # Fit the PCoA
#' PCOA <-pcoa_freqs(newFreqData)
#'
#' # Ordination
#' PCOA$ %>% plot
#'
#' # Eigenvalues
#' PCOA$values
#'
#' # Pairwise FST in long-format data table
#' PCOA$fst
pcoa_freqs <- function(
dat, popCol='POP', locusCol='LOCUS', freqCol='FREQ', indsCol='INDS'){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(ape); require(data.table); require(tidyverse)
if(sum(c(popCol,locusCol,freqCol,indsCol) %in% colnames(dat))!=4){
stop(
'Argument `dat` requires columns `popCol`, `locusCol`, `freqCol`, and
`indsCol` to estimate F-statistics from allele frequencies. See ?fstat_calc.')
}
dat <- as.data.table(dat)
# --------------------------------------------+
# Code
# --------------------------------------------+
pair.fst <- dat %>%
fstat_calc(., type='freqs', pairwise=TRUE, global=FALSE)
pair.mat <- pair.fst$genome %>%
pairwiseMat2DT(., flip=TRUE, X1='POP1', X2='POP2', Y='FST')
PCOA <- pcoa(pair.mat)
PCOA$fst <- pair.fst[['genome']]
return(PCOA)
}
PCOA <-pcoa_freqs(newFreqData)
PCOA$ %>% plot
PCOA$vectors %>% plot
PCOA$vectors
PCOA$values
PCOA$fst
# Make documents
roxygenise(clean=TRUE)
# CODE FOR BUILDING PACKAGE #
# Good website:
#   http://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make documents
roxygenise(clean=TRUE)
roxygenise()
library(genomalicious)
?pcoa_freqs
class(PCOA)
roxygenise()
library(genomalicious)
