snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
as.data.frame() %>%
rownames_to_column(., 'LOCUS') %>%
as.data.table
DA.tab <- da2DT(DA, sampVec=rownames(X), obsPops=pops)
PCA.tab <- pca2DT(PCA) %>%
.[AXIS %in% paste0('PC', 1:pcaPreds)]
list(da.fit=DA, da.tab=DA.tab, pca.fit=PCA, pca.tab=PCA.tab, snp.contrib=snp.da.contr)
snp.da.contr$LD1 %>%  sum
# Leave-one-out CV
samps <- dat$SAMPLE %>% unique
samps
i=1
pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcaPreds])
rm(pcaPreds)
pcPreds <- 3
colnames(dat)[match(c(sampCol, locusCol, popCol, genoCol),colnames(dat))] <- c(
'SAMPLE','LOCUS','POP','GT'
)
FUN_snp_da_contrib <- function(x){
temp <- sum(x*x)
if(temp < 1e-12) return(rep(0, length(x)))
return(x*x / temp)
}
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds])
DA <- lda(pops ~ X, prior=rep(1,k)/k, tol=1e-30, CV=TRUE)
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
dat[SAMPLE==samps[i],]
pca_genos(dat[SAMPLE==samps[i],], scaling=scaling, popCol='POP')
DT2Mat_genos(dat[SAMPLE==samps[i],])
DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation
DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds]
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds]
predict(DA.i, newdata = ynew)
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
as.data.frame()
ynew
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
as.data.frame() %>%
t()
ynew
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1)
predict(DA.i, newdata = ynew)
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame()
predict(DA.i, newdata = ynew)
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame()
ynew
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=c('PC', 1:pcPreds))
DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame()
pcPreds
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
predict(DA.i, newdata = ynew)
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
DA.i
DA.i$scaling
ynew
predict(DA.i, newdata = ynew)
?predict.lda
predict(DA.i, newdata = ynew)$class
tr <- sample(1:50, 25)
train <- rbind(iris3[tr,,1], iris3[tr,,2], iris3[tr,,3])
test <- rbind(iris3[-tr,,1], iris3[-tr,,2], iris3[-tr,,3])
cl <- factor(c(rep("s",25), rep("c",25), rep("v",25)))
z <- lda(train, cl)
z
test
predict(z, test[1,])
predict(z, test[1,])
predict(z, test[1,])
test[1,]
class(test)
predict(DA.i, newdata = ynew[1,])$class
predict(DA.i, newdata = ynew[1,])
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
ynew
class(ynew)
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds)) %>%
as.matrix()
ynew
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds)) %>%
as.matrix()
predict(DA.i, newdata = ynew[1,])
X.i <- PCA$x[, 1:pcPreds]
X.i
DA.i <- lda(PCA$pops ~ X.i, prior=rep(1,k)/k, tol=1e-30)
DA.i
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
DA.i
snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
PCA <- pca_genos(dat, scaling=scaling, popCol=popCol)
pops <- PCA$pops %>%  as.factor()
k <- length(unique(pops))
X <- PCA$x[, 1:pcPreds]
DA <- lda(pops ~ X, prior=rep(1,k)/k, tol=1e-30)
snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
as.data.frame() %>%
rownames_to_column(., 'LOCUS') %>%
as.data.table
DA.tab <- da2DT(DA, sampVec=rownames(X), obsPops=pops)
PCA.tab <- pca2DT(PCA) %>%
.[AXIS %in% paste0('PC', 1:pcPreds)]
snp.da.contr
snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
as.data.frame() %>%
rownames_to_column(., 'LOCUS') %>%
as.data.table
DA.tab <- da2DT(DA, sampVec=rownames(X), obsPops=pops)
PCA.tab <- pca2DT(PCA) %>%
.[AXIS %in% paste0('PC', 1:pcPreds)]
list(da.fit=DA, da.tab=DA.tab, pca.fit=PCA, pca.tab=PCA.tab, snp.contrib=snp.da.contr)
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(PCA$pops ~ PCA$x[, 1:pcPreds], prior=rep(1,k)/k, tol=1e-30)
PCA$x[, 1:pcPreds]
DA.i <- lda(PCA$x[, 1:pcPreds], PCA.i$pops=pops prior=rep(1,k)/k, tol=1e-30)
DA.i <- lda(PCA$x[, 1:pcPreds], PCA.i$pops=pops, prior=rep(1,k)/k, tol=1e-30)
DA.i <- lda(PCA$x[, 1:pcPreds], PCA.i$pops=pops, prior=rep(1,k)/k, tol=1e-30)
?lda
PCA$x[, 1:pcPreds]
DA.i <- lda(
as.data.frame(PCA$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k, tol=1e-30)
as.data.frame(PCA$x[, 1:pcPreds])
DA.i <- lda(
as.data.frame(PCA$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
DA.i <- lda(
as.data.frame(PCA.i$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
DA.i
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds)) %>%
predict(DA.i, newdata = ynew[1,])
# Training-testing partitioning
train.samps <- dat %>%
.[, sample(SAMPLE, round(length(unique(SAMPLE)))), by=POP] %>%
.[['V1']]
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds)) %>%
predict(DA.i, newdata = ynew[1,])
ynew <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
predict(DA.i, newdata = ynew[1,])
X <- PCA$x[, 1:pcPreds] %>% as.data.frame()
DA <- lda(pops ~ X, prior=rep(1,k)/k, tol=1e-30)
DA <- lda(X, pops, prior=rep(1,k)/k, tol=1e-30)
DA
snp.da.load <- as.matrix(PCA$rotation[, 1:pcPreds]) %*% as.matrix(DA$scaling)
snp.da.contr <- apply(snp.da.load, 2, FUN_snp_da_contrib) %>%
as.data.frame() %>%
rownames_to_column(., 'LOCUS') %>%
as.data.table
DA.tab <- da2DT(DA, sampVec=rownames(X), obsPops=pops)
PCA.tab <- pca2DT(PCA) %>%
.[AXIS %in% paste0('PC', 1:pcPreds)]
list(da.fit=DA, da.tab=DA.tab, pca.fit=PCA, pca.tab=PCA.tab, snp.contrib=snp.da.contr)
snp.da.contr[,1]
snp.da.contr[,2]
snp.da.contr[,2] %>% hist
snp.da.contr$LD1 %>% hist
snp.da.contr$LD2 %>% hist
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(
as.data.frame(PCA.i$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
ynew.i <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
Xnew.i <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
Xnew.i <- DT2Mat_genos(dat[SAMPLE==samps[i],]) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
predict(DA.i, newdata = Xnew.i[1,])
predict(DA.i, newdata = Xnew.i[1,])$class
Xnew.i
Xnew.i
Xnew.i
Xnew.i
Xnew.i
dat.i <- dat[SAMPLE==samps[i],]
dat.i
Xnew.i <- DT2Mat_genos(dat.i) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
data.table(
POP=dat.i$POP[1],
SAMPLE=samps[i],
POP.PRED=predict(DA.i, newdata = Xnew.i[1,])$class
)
lapply(1:length(sampls), function(i){
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(
as.data.frame(PCA.i$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
dat.i <- dat[SAMPLE==samps[i],]
Xnew.i <- DT2Mat_genos(dat.i) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
data.table(
POP=dat.i$POP[1],
SAMPLE=samps[i],
POP.PRED=predict(DA.i, newdata = Xnew.i[1,])$class
)
}) %>%
do.call('rbind',.)
lapply(1:length(samps), function(i){
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(
as.data.frame(PCA.i$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
dat.i <- dat[SAMPLE==samps[i],]
Xnew.i <- DT2Mat_genos(dat.i) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
data.table(
POP=dat.i$POP[1],
SAMPLE=samps[i],
POP.PRED=predict(DA.i, newdata = Xnew.i[1,])$class
)
}) %>%
do.call('rbind',.)
predTab <- lapply(1:length(samps), function(i){
PCA.i <- pca_genos(dat[SAMPLE!=samps[i],], scaling=scaling, popCol='POP')
DA.i <- lda(
as.data.frame(PCA.i$x[, 1:pcPreds]),
PCA.i$pops,
prior=rep(1,k)/k,
tol=1e-30)
dat.i <- dat[SAMPLE==samps[i],]
Xnew.i <- DT2Mat_genos(dat.i) %*% PCA.i$rotation %>%
.[, 1:pcPreds] %>%
matrix(., ncol=pcPreds, nrow=1) %>%
as.data.frame() %>%
setnames(., new=paste0('PC', 1:pcPreds))
data.table(
POP=dat.i$POP[1],
SAMPLE=samps[i],
POP.PRED=predict(DA.i, newdata = Xnew.i[1,])$class
)
}) %>%
do.call('rbind',.)
predTab[POP==POP.PRED]
predTab
predTab[, sum(POP==POP.PRED)/length(SAMPLE)]
predTab[, sum(POP==POP.PRED)/length(SAMPLE), by=POP]
pops.uniq <- dat$POP %>% unique
pops.uniq
CJ(POP1=pops, POP2=pops)
CJ(POP1=pops.uniq, POP2=pops.uniq)
popComps <- CJ(POP1=pops.uniq, POP2=pops.uniq)
popComps <- CJ(POP=pops.uniq, POP.PRED=pops.uniq)
popComps
# CV statistics
predTab[, sum(POP==POP.PRED)/length(SAMPLE)]
predTab
#' Convert a \code{lda} object to a long-format \code{data.table}
#'
#' @param daObj Lda: An object produced by \code{lda}.
#'
#' @param sampVec Character: The sample IDs, which need to match the sample
#' order in \code{predict(daObj)$x}.
#'
#' @param obsPops Character/Factor: The observed population IDs, which need to
#' match sample order in \code{predict(daObj)$x}.
#'
#' @returns Returns a long-format data.table with columns \code{$POP}, the
#' population IDs, \code{$SAMPLE}, the sample IDs, \code{$AXIS}, the LD axis ID,
#' and \code{$SCORE}, the score on the LD axis, and \code{POP.PRED},
#' the predicted population ID.
#'
#' @examples
#' data(data_4pops)
#'
#' PCA <- pca_genos(data_4pops, popCol='POP')
#' DA <- lda(PCA$pops ~ PCA$x[,1:3])
#'
#' da2DT(DA, sampVec=rownames(PCA$x), obsPops=PCA$pops)
#'
#' @export
da2DT <- function(daObj, sampVec, obsPops){
require(data.table); require(tidyverse)
if(!c('lda')%in%class(daObj)){
stop('Argument `daObj` must be of "lda" class.')
}
# Get DA predictions
DA.pred <- predict(daObj)
# Add in populations then convert to long-format
data.table(POP=obsPops, POP.PRED=DA.pred$class, SAMPLE=sampVec, DA.pred$x) %>%
melt(., id.vars=c('POP','POP.PRED','SAMPLE'), variable.name='AXIS', value.name='SCORE') %>%
return()
}
data(data_4pops)
PCA <- pca_genos(data_4pops, popCol='POP')
DA <- lda(PCA$pops ~ PCA$x[,1:3])
da2DT(DA, sampVec=rownames(PCA$x), obsPops=PCA$pops)
#' Convert a \code{lda} object to a long-format \code{data.table}
#'
#' @param daObj Lda: An object produced by \code{lda}.
#'
#' @param sampVec Character: The sample IDs, which need to match the sample
#' order in \code{predict(daObj)$x}.
#'
#' @param obsPops Character/Factor: The observed population IDs, which need to
#' match sample order in \code{predict(daObj)$x}.
#'
#' @returns Returns a long-format data.table with columns \code{$POP}, the
#' population IDs, \code{$SAMPLE}, the sample IDs, \code{$AXIS}, the LD axis ID,
#' and \code{$SCORE}, the score on the LD axis.
#'
#' @examples
#' data(data_4pops)
#'
#' PCA <- pca_genos(data_4pops, popCol='POP')
#' DA <- lda(PCA$pops ~ PCA$x[,1:3])
#'
#' da2DT(DA, sampVec=rownames(PCA$x), obsPops=PCA$pops)
#'
#' @export
da2DT <- function(daObj, sampVec, obsPops){
require(data.table); require(tidyverse)
if(!c('lda')%in%class(daObj)){
stop('Argument `daObj` must be of "lda" class.')
}
# Get DA predictions
DA.pred <- predict(daObj)
# Add in populations then convert to long-format
data.table(POP=obsPops, SAMPLE=sampVec, DA.pred$x) %>%
melt(., id.vars=c('POP','SAMPLE'), variable.name='AXIS', value.name='SCORE') %>%
return()
}
data(data_4pops)
PCA <- pca_genos(data_4pops, popCol='POP')
DA <- lda(PCA$pops ~ PCA$x[,1:3])
da2DT(DA, sampVec=rownames(PCA$x), obsPops=PCA$pops)
# CV statistics
predTab[, sum(POP==POP.PRED)/length(SAMPLE)]
popComps <- CJ(POP=pops.uniq, POP.PRED=pops.uniq)
pop.obs <- popComp$POP[i]
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
pop.obs
pop.pred
predTab[POP==pop.obs & POP.PRED==pop.pred, sum(POP==POP.PRED)/length(SAMPLE)]
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
predTab[POP==pop.obs & POP.PRED==pop.pred, sum(POP==POP.PRED)/length(SAMPLE)]
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
predTab[POP==pop.obs & POP.PRED==pop.pred] %>%
nrow()
})
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/predTab[POP==popObs]
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/predTab[POP==popObs]
})
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/predTab[POP==pop.obs]
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/predTab[POP==pop.obs]
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/predTab[POP==pop.obs]
})
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs]) %>%
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN.RATE=.)
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs]) %>%
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=.)
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
})
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
}) %>%
do.call('rbind', .)
# CV statistics
predTab[, sum(POP==POP.PRED)/length(SAMPLE)]
popComps <- CJ(POP=pops.uniq, POP.PRED=pops.uniq)
lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
}) %>%
do.call('rbind', .)
predPairs <- lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
}) %>%
do.call('rbind', .)
predPairsLong <- lapply(1:nrow(popComps), function(i){
pop.obs <- popComps$POP[i]
pop.pred <- popComps$POP.PRED[i]
assign <- nrow(predTab[POP==pop.obs & POP.PRED==pop.pred])/nrow(predTab[POP==pop.obs])
data.table(POP=pop.obs, POP.PRED=pop.pred, ASSIGN=assign)
}) %>%
do.call('rbind', .)
predPairsLong %>%
dcast(., POP~POP.PRED)
predPairsLong %>%
dcast(., POP~POP.PRED, value.var='ASSIGN')
predPairsWide <- predPairsLong %>%
dcast(., POP~POP.PRED, value.var='ASSIGN')
# CV statistics
predTab[, sum(POP==POP.PRED)/length(SAMPLE)]
# Make documents
roxygenise(clean=TRUE) # Sometimes this throws an error?
library(genomalicious)
